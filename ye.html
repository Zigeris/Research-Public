<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>BNP Sim — NNMs + Logic + Math + Ricci Flow + Lensing</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0c0f14;--fg:#e7edf5;--muted:#9aa0a6;--panel:#11161c;--accent:#6ee7ff;--ok:#7efc8a;--warn:#ffd166;--mag:#ff6bd6}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .wrap{display:grid;grid-template-columns:440px 1fr;gap:14px;height:100%}
  .left{background:var(--panel);padding:14px;border-right:1px solid #1c2530;overflow:auto}
  h1{font-size:16px;margin:0 0 8px}
  h2{font-size:13px;margin:16px 0 6px;color:var(--muted);text-transform:uppercase;letter-spacing:.06em}
  input[type=text]{width:100%;padding:8px 10px;background:#0f151b;border:1px solid #253241;color:var(--fg);border-radius:8px}
  select,button,input[type=range]{width:100%}
  select{padding:8px 10px;background:#0f151b;border:1px solid #253241;color:var(--fg);border-radius:8px}
  button{padding:8px 10px;margin:6px 0;background:#17212b;border:1px solid #253241;color:var(--fg);border-radius:8px}
  button:hover{border-color:#39526d}
  .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .val{color:var(--accent)}
  .pill{display:inline-block;padding:2px 6px;border:1px solid #2b3a4b;border-radius:999px;background:#0c1218;color:#b6c1cc;margin-right:6px}
  .kvs{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;align-items:center}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .small{font-size:12px}
  .code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#0f151b;border:1px solid #253241;border-radius:8px;padding:8px;white-space:pre-wrap}
  .twocol{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .canvwrap{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:10px}
  canvas{background:#0a0e13;border:1px solid #1a2430;border-radius:10px;image-rendering:pixelated}
  .legend{font-size:12px;color:#b6c1cc}
  .hr{height:1px;background:#1c2530;margin:10px 0}
  label.inline{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1>BNP Micro-NNMs + Logic + Math + Physics</h1>
    <div class="kvs">
      <div>Sheet size</div><div class="mono" id="sz">–</div>
      <div>FPS</div><div class="mono" id="fps">–</div>
      <div>Flips/frame</div><div class="mono" id="flips">–</div>
      <div>Events (rail≠0)</div><div class="mono" id="events">–</div>
    </div>

    <h2>Run</h2>
    <div class="row"><button id="btnToggle">▶ Start</button><span class="pill" id="state">paused</span></div>
    <div class="row"><button id="btnStep">Step (1 tick)</button><span class="pill">deterministic per tick</span></div>
    <div class="row"><button id="btnReset">Reset / Reseed</button><span></span></div>

    <h2>Data mode</h2>
    <label class="inline"><input type="checkbox" id="meaning" checked> Meaningful dataset (tri-cluster + payload)</label>
    <div style="margin-top:6px">
      <label class="mono small">Payload (encoded into S):</label>
      <input type="text" id="payload" value="BNP">
    </div>

    <h2>Events (“noise”)</h2>
    <div class="row">
      <label>Base flip prob / texel <span class="val" id="pFlipVal"></span></label>
      <input type="range" id="pFlip" min="0" max="0.05" step="0.0005" value="0.002">
    </div>
    <div class="row">
      <label>Edge bias (×) <span class="val" id="edgeBiasVal"></span></label>
      <input type="range" id="edgeBias" min="0" max="3" step="0.1" value="1.5">
    </div>
    <div class="row">
      <label>Rail radius R (±) <span class="val" id="radVal"></span></label>
      <input type="range" id="rad" min="1" max="12" step="1" value="5">
    </div>

    <h2>BNP Systems</h2>
    <label class="inline"><input type="checkbox" id="q2Enable" checked> Q2 Event Bus (2-bit tokens)</label><br>
    <label class="small" style="margin-left:18px;"><input type="checkbox" id="q2Morton" checked> Include Morton region key (KEY=7)</label><br>
    <div class="row">
      <label>Q2 buffer cap (KB) <span class="val" id="q2CapVal"></span></label>
      <input type="range" id="q2Cap" min="1" max="128" step="1" value="16">
    </div>
    <div class="twocol">
      <button id="q2Reset">Reset Q2 Bus</button>
      <button id="q2Copy">Copy Codons</button>
    </div>

    <!-- Gate controls -->
    <label class="inline" style="margin-top:10px;"><input type="checkbox" id="gateEnable" checked> Domain Gate Mask (tiles)</label><br>
    <div class="row small" style="margin-left:18px;">
      <label>Gate coverage (%) <span class="val" id="gateCovVal"></span></label>
      <input type="range" id="gateCov" min="0" max="100" step="5" value="60">
    </div>
    <div class="row small" style="margin-left:18px;">
      <label>Gate rails too</label>
      <input type="checkbox" id="gateRails" checked>
    </div>
    <div class="row small" style="margin-left:18px;">
      <button id="gateReseed">Reseed gates</button><span></span>
    </div>

    <label class="inline" style="margin-top:8px;"><input type="checkbox" id="schedOverlay" checked> Show Morton scheduling overlay</label>

    <h2>Logic Layer</h2>
    <label class="inline"><input type="checkbox" id="logicEnable" checked> Enable logic (per-tile)</label><br>
    <div class="row">
      <label>Function</label>
      <select id="logicFn">
        <option value="FA">Full Adder: SUM=A⊕B⊕C, CARRY=maj(A,B,C)</option>
        <option value="HA">Half Adder: SUM=A⊕B, CARRY=A·B (C ignored)</option>
        <option value="MAJ">Majority: OUT=maj(A,B,C), SUM=OUT, CARRY=0</option>
        <option value="XOR3">XOR3: OUT=A⊕B⊕C, SUM=OUT, CARRY=0</option>
      </select>
    </div>
    <div class="row">
      <label>Fusion threshold <span class="val" id="thrVal"></span></label>
      <input type="range" id="thr" min="0.05" max="0.9" step="0.01" value="0.42">
    </div>
    <div class="row small">
      <label>Fusion weights preset</label>
      <select id="wPreset">
        <option value="balanced" selected>Balanced</option>
        <option value="railHeavy">Rail-heavy</option>
        <option value="semHeavy">Semantic-heavy</option>
        <option value="rgbHeavy">RGB-heavy</option>
      </select>
    </div>

    <div class="hr"></div>
    <h2>BNP Extras</h2>
    <b class="small">Proper-time cτ</b>
    <div class="row small">
      <label>cτ spread (±) <span class="val" id="ctauVal"></span></label>
      <input type="range" id="ctauSpread" min="0" max="0.9" step="0.05" value="0.5">
    </div>
    <div class="twocol">
      <button id="ctauReseed">Reseed cτ</button>
      <label class="small inline"><input type="checkbox" id="ctauOverlay" checked> Show cτ heat</label>
    </div>

    <b class="small">BitBias + Scheduler</b>
    <label class="small inline"><input type="checkbox" id="bbOverlay" checked> Show BitBias overlay</label>
    <div class="row small">
      <label>Scheduler</label>
      <select id="schedMode">
        <option value="round" selected>Round-robin (all tiles)</option>
        <option value="bitonic">Bitonic (top-K admitted)</option>
      </select>
    </div>
    <div class="row small">
      <label>Admit top-K (%) <span class="val" id="admitVal"></span></label>
      <input type="range" id="admitPct" min="10" max="100" step="5" value="60">
    </div>

    <b class="small">REQ/ACK Protocol</b>
    <label class="small inline"><input type="checkbox" id="protoEnable" checked> Enable REQ/ACK</label>
    <div class="row small">
      <label>Start prob / tile <span class="val" id="protoStartVal"></span></label>
      <input type="range" id="protoStart" min="0" max="0.05" step="0.001" value="0.01">
    </div>
    <div class="row small">
      <label>Fault drop (%) <span class="val" id="faultVal"></span></label>
      <input type="range" id="faultPct" min="0" max="50" step="1" value="5">
    </div>
    <label class="small inline"><input type="checkbox" id="protoOverlay" checked> Show REQ/ACK links (2D)</label>
    <div class="kvs small" style="margin-top:6px">
      <div>Handshakes</div><div class="mono" id="hsCount">0</div>
      <div>REQ↑</div><div class="mono" id="reqEdges">0</div>
      <div>ACK↑</div><div class="mono" id="ackEdges">0</div>
    </div>

    <h2>3D View</h2>
    <div class="row">
      <label>Point sample (%) <span class="val" id="sampVal"></span></label>
      <input type="range" id="samp" min="5" max="100" step="5" value="40">
    </div>
    <label class="inline"><input type="checkbox" id="autorot" checked> Auto-rotate</label><br>

    <div class="hr"></div>
    <h2>3D Node Graph</h2>
    <label class="small inline"><input type="checkbox" id="graph3D" checked> Show NNM node graph (tile centroids)</label><br>
    <label class="small inline"><input type="checkbox" id="graphTrails" checked> Show REQ/ACK trails (fading)</label><br>
    <label class="small inline"><input type="checkbox" id="graphFlow3D" checked> Show rail-flow hints</label>
    <div class="row small">
      <label>Trail lifetime (s) <span class="val" id="trailVal"></span></label>
      <input type="range" id="trailSec" min="1" max="12" step="1" value="6">
    </div>
    <div class="row small">
      <label>Node size scale <span class="val" id="nodeVal"></span></label>
      <input type="range" id="nodeScale" min="0.5" max="3" step="0.1" value="1.6">
    </div>

    <div class="hr"></div>
    <h2>Math Tasks</h2>
    <label class="inline"><input type="checkbox" id="mathEnable"> Enable math mode</label>
    <div class="row small">
      <label>Problem</label>
      <select id="mathProblem">
        <option value="NONE">—</option>
        <option value="ADD16">Add 16-bit  (A+B)</option>
        <option value="MUL16MOD" selected>Multiply 16-bit (A·B mod N)</option>
      </select>
    </div>
    <div class="row small"><label>A (hex)</label><input type="text" id="mathA" value="00B7"></div>
    <div class="row small"><label>B (hex)</label><input type="text" id="mathB" value="013D"></div>
    <div class="row small"><label>N (hex)</label><input type="text" id="mathN" value="F2A5"></div>
    <div class="twocol"><button id="mathLoad">Load</button><button id="mathRun">Run / Restart</button></div>
    <label class="small inline"><input type="checkbox" id="mathOverlay" checked> Highlight math tiles (2D)</label>
    <div class="mono small" id="mathStatus">idle</div>

    <div class="hr"></div>
    <h2>Physics: Ricci Flow + Geodesic Lensing</h2>
    <label class="inline"><input type="checkbox" id="physEnable" checked> Enable physics</label>
    <div class="row small">
      <label>Target curvature K<sub>tgt</sub> source</label>
      <select id="physSrc">
        <option value="S" selected>From S channel</option>
        <option value="SYN">Synthetic Gaussians</option>
        <option value="PAY">Payload-derived</option>
      </select>
    </div>
    <div class="row small">
      <label>α (descent step) <span class="val" id="alphaVal"></span></label>
      <input type="range" id="alpha" min="0.001" max="0.08" step="0.001" value="0.02">
    </div>
    <div class="row small">
      <label>λ (smoothness) <span class="val" id="lambdaVal"></span></label>
      <input type="range" id="lambda" min="0.0" max="0.2" step="0.005" value="0.03">
    </div>
    <label class="small inline"><input type="checkbox" id="uOverlay" checked> Show u heat overlay (2D)</label>
    <div class="mono small" id="physStatus">u-residual: –  | rays: –</div>

    <h3 class="small">Geodesic Rays</h3>
    <label class="small inline"><input type="checkbox" id="rayEnable" checked> Trace rays</label>
    <div class="row small">
      <label>Rays per burst <span class="val" id="rayCountVal"></span></label>
      <input type="range" id="rayCount" min="2" max="80" step="2" value="24">
    </div>
    <div class="row small">
      <label>Ray step (px) <span class="val" id="rayStepVal"></span></label>
      <input type="range" id="rayStep" min="0.2" max="2.0" step="0.1" value="0.8">
    </div>
    <div class="row small">
      <label>Max steps <span class="val" id="rayMaxVal"></span></label>
      <input type="range" id="rayMax" min="40" max="600" step="10" value="260">
    </div>
    <label class="small inline"><input type="checkbox" id="rayOverlay2D" checked> Draw rays on 2D</label><br>
    <label class="small inline"><input type="checkbox" id="rayOverlay3D" checked> Draw rays in 3D</label>

    <h2>Q2 Bus Status</h2>
    <div class="kvs">
      <div>Tokens</div><div class="mono" id="q2Tok">0</div>
      <div>Bytes</div><div class="mono" id="q2Bytes">0</div>
      <div>Codons</div><div class="mono" id="q2Codons">0</div>
    </div>
    <div class="code mono small" id="q2Preview">(hex preview…)</div>
  </div>

  <div class="canvwrap">
    <div>
      <canvas id="c2d" width="512" height="512"></canvas>
      <div class="legend">2D Texture Sheet (RGB). Logic rings: SUM(white) / CARRY(yellow). Physics overlay shows u heat; rays in cyan.</div>
    </div>
    <div>
      <canvas id="c3d" width="512" height="512"></canvas>
      <div class="legend">3D Semantic Space (Q,P,S → x,y,z) with node graph + trails (REQ/ACK & math & lensing paths).</div>
    </div>
  </div>
</div>

<script>
(function(){
  // --- Config ---
  const W=64,H=64,TILE=8, TX=W/TILE, TY=H/TILE, NT=TX*TY;
  const CH={R:0,G:1,B:2,Q:3,P:4,S:5};
  const EPS=1e-6;

  // Fusion presets
  const PRESETS={
    balanced:{wRail:0.40,wSem:0.25,wRGB:0.20,wTile:0.10,wCoh:0.05},
    railHeavy:{wRail:0.60,wSem:0.15,wRGB:0.10,wTile:0.10,wCoh:0.05},
    semHeavy:{wRail:0.25,wSem:0.45,wRGB:0.15,wTile:0.10,wCoh:0.05},
    rgbHeavy:{wRail:0.25,wSem:0.15,wRGB:0.45,wTile:0.10,wCoh:0.05},
  };
  let FW={...PRESETS.balanced};

  // --- Shared state ---
  const sheet=new Float32Array(W*H*6);
  const rails=new Uint8Array(W*H);          // 0 open, 1 X, 2 Y, 3 Z
  let prevRails=new Uint8Array(W*H);
  const railField=new Float32Array(W*H*3);  // X/Y/Z influence
  const tmpRGB=new Float32Array(W*H*3);
  const edgeMap=new Float32Array(W*H);
  const orient=new Uint8Array(W*H);
  const gateTile=new Uint8Array(NT);

  // Proper-time per tile
  const cTau=new Float32Array(NT);
  let cTauSpread=0.5;

  // BitBias & scheduling
  const bitBias=new Float32Array(NT);
  const tileActive=new Uint8Array(NT);
  let admitFrac=0.6;

  // Logic per-tile
  const tileA=new Uint8Array(NT), tileB=new Uint8Array(NT), tileC=new Uint8Array(NT);
  const tileSUM=new Uint8Array(NT), tileCAR=new Uint8Array(NT);
  let prevSUM=new Uint8Array(NT), prevCAR=new Uint8Array(NT);

  // REQ/ACK
  const reqPrev=new Uint8Array(NT), ackPrev=new Uint8Array(NT);
  const reqNow=new Uint8Array(NT), ackNow=new Uint8Array(NT);
  const partner=new Int32Array(NT);
  let hsTotal=0, reqEdges=0, ackEdges=0;

  // 3D node graph
  const tilePos=new Float32Array(NT*3);
  const tileFlow=new Uint8Array(NT);
  const trailEdges=[];
  const MAX_TRAILS=1400;

  let flipsLast=0, eventsLast=0, tickCount=0;

  // Q2 Event Bus
  let q2Tokens=[];
  let q2CapBytes=16*1024;
  const Q2_TYPE={TINY2:0, UINT3:1, SYM3:2, NEST:3};

  // --- Math mode ---
  const M = { NONE:'NONE', ADD16:'ADD16', MUL16MOD:'MUL16MOD' };
  let mathEnabled=false, mathProblem=M.NONE, mathBits=16;
  let regA=new Uint8Array(mathBits), regB=new Uint8Array(mathBits), regN=new Uint8Array(mathBits), regACC=new Uint8Array(mathBits);
  let mathStep=0, mathCarry=0, mathQueue=[];
  const ovA=new Uint8Array(NT), ovB=new Uint8Array(NT), ovC=new Uint8Array(NT);
  const ovSUM=new Int16Array(NT), ovCAR=new Int16Array(NT); // -1=no override
  const ovMask=new Uint8Array(NT);

  // --- Physics: Ricci Flow + Rays ---
  let physEnabled=true;
  const physU=new Float32Array(W*H);          // conformal factor u
  const physU2=new Float32Array(W*H);         // proposed u'
  const physKtgt=new Float32Array(W*H);       // target curvature
  const physRes=new Float32Array(W*H);        // residual R
  const physGx=new Float32Array(W*H);         // grad u x
  const physGy=new Float32Array(W*H);         // grad u y
  let alphaStep=0.02, lambdaSmooth=0.03;
  let physResidualAvg=0;

  // Geodesic rays
  let raysEnabled=true;
  const rays=[];                    // {x,y,vx,vy,life}
  const ray2DPath=[];               // segments for 2D draw: [x0,y0,x1,y1,age]
  const rayEdges=[];                // 3D edges between tile centroids {u,v,life,ttl}
  const MAX_RAY_EDGES=1200;
  let raysPerBurst=24, rayStepPx=0.8, rayMaxSteps=260;
  let lastRaySpawnTick=0;

  // --- UI refs ---
  const el=id=>document.getElementById(id);
  const c2d=el('c2d'), g2d=c2d.getContext('2d');
  const c3d=el('c3d'), g3d=c3d.getContext('2d');

  const pFlip=el('pFlip'), pFlipVal=el('pFlipVal');
  const edgeBiasRange=el('edgeBias'), edgeBiasVal=el('edgeBiasVal');
  const rad=el('rad'), radVal=el('radVal');
  const samp=el('samp'), sampVal=el('sampVal');
  const autorot=el('autorot'), statePill=el('state');
  const btnToggle=el('btnToggle'), btnStep=el('btnStep'), btnReset=el('btnReset');
  const meaning=el('meaning'), payload=el('payload');
  const fpsLabel=el('fps'), flipsLabel=el('flips'), eventsLabel=el('events');

  const q2Enable=el('q2Enable'), q2Morton=el('q2Morton'), q2Cap=el('q2Cap'), q2CapVal=el('q2CapVal');
  const q2Tok=el('q2Tok'), q2Bytes=el('q2Bytes'), q2Codons=el('q2Codons'), q2Preview=el('q2Preview');
  const q2Reset=el('q2Reset'), q2Copy=el('q2Copy');

  const schedOverlay=el('schedOverlay');
  const logicEnable=el('logicEnable'), logicFn=el('logicFn'), thr=el('thr'), thrVal=el('thrVal'), wPreset=el('wPreset');

  const ctauSpread=el('ctauSpread'), ctauVal=el('ctauVal'), ctauReseed=el('ctauReseed'), ctauOverlay=el('ctauOverlay');
  const bbOverlay=el('bbOverlay');
  const schedMode=el('schedMode'), admitPct=el('admitPct'), admitVal=el('admitVal');
  const protoEnable=el('protoEnable'), protoOverlay=el('protoOverlay'), protoStart=el('protoStart'), protoStartVal=el('protoStartVal'), faultPct=el('faultPct'), faultVal=el('faultVal');
  const hsCount=el('hsCount'), reqEdgesLbl=el('reqEdges'), ackEdgesLbl=el('ackEdges');

  const gateEnable=el('gateEnable'), gateCov=el('gateCov'), gateCovVal=el('gateCovVal'), gateRails=el('gateRails');

  const graph3D=el('graph3D'), graphTrails=el('graphTrails'), graphFlow3D=el('graphFlow3D');
  const trailSec=el('trailSec'), trailVal=el('trailVal');
  const nodeScale=el('nodeScale'), nodeVal=el('nodeVal');

  // Math UI
  const mathEnable=el('mathEnable'), mathProblemSel=el('mathProblem');
  const mathA=el('mathA'), mathB=el('mathB'), mathN=el('mathN');
  const mathLoad=el('mathLoad'), mathRun=el('mathRun'), mathOverlay=el('mathOverlay'), mathStatus=el('mathStatus');

  // Physics UI
  const physEnable=el('physEnable'), physSrc=el('physSrc');
  const alpha=el('alpha'), alphaVal=el('alphaVal');
  const lambdaR=el('lambda'), lambdaVal=el('lambdaVal');
  const uOverlay=el('uOverlay'), physStatus=el('physStatus');

  // Rays UI
  const rayEnable=el('rayEnable'), rayCount=el('rayCount'), rayStep=el('rayStep'), rayMax=el('rayMax');
  const rayCountVal=el('rayCountVal'), rayStepVal=el('rayStepVal'), rayMaxVal=el('rayMaxVal');
  const rayOverlay2D=el('rayOverlay2D'), rayOverlay3D=el('rayOverlay3D');

  el('sz').textContent=`${W} × ${H} (tiles ${TX}×${TY})`;

  // --- Controls state ---
  let running=false, lastT=performance.now(), fps=0, accum=0, frames=0, dtMs=16;
  let rotX=-0.6, rotY=0.8, dragging=false, lastMouse=null;

  // --- Helpers ---
  const clamp01=v=>Math.max(0,Math.min(1,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const hann=t=>(t<=1)?0.5*(1+Math.cos(Math.PI*t)):0;
  const idx=(x,y)=>((y+H)%H)*W + ((x+W)%W);
  const tIdx=(tx,ty)=>((ty+TY)%TY)*TX + ((tx+TX)%TX);
  const get=(i,ch)=>sheet[i*6+ch];
  const set=(i,ch,v)=>sheet[i*6+ch]=v;
  const hash2=(x,y)=>{ let h=(x*374761393 ^ y*668265263)>>>0; h=(h^(h>>>13))*1274126177>>>0; return h>>>0; };
  const on = (e, def=false)=> (e && typeof e.checked==='boolean') ? e.checked : def;
  const numVal = (e, def=0)=> (e && e.value!=null) ? +e.value : def;

  function forEachPixel(f){ for(let y=0;y<H;y++) for(let x=0;x<W;x++) f(x,y,idx(x,y)); }

  // Morton key for Q2
  function part1by1(n){ n&=0xFFFF; n=(n^(n<<8))&0x00FF00FF; n=(n^(n<<4))&0x0F0F0F0F; n=(n^(n<<2))&0x33333333; n=(n^(n<<1))&0x55555555; return n; }
  function mortonXY(x,y){ return (part1by1(y)<<1)|part1by1(x); }

  // --- Seed & fields ---
  function seedFromString(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=(h*16777619)>>>0; } return ()=>{ h^=h<<13; h^=h>>>17; h^=h<<5; return (h>>>0)/4294967295; }; }
  function writePayloadIntoS(text){
    const rnd=seedFromString(text||"BNP"); const w=16,h=16, ox=4, oy=4;
    for(let yy=0;yy<h;yy++) for(let xx=0;xx<w;xx++){
      const i=idx((ox+xx)%W,(oy+yy)%H);
      const bit = rnd()>0.5?1:0; const s0=get(i,CH.S);
      set(i,CH.S, clamp01(s0 + 0.25*bit));
    }
  }
  function computeEdgeAndOrientation(){
    let maxMag=1e-6;
    forEachPixel((x,y,i)=>{
      const xr=(x+1)%W, xl=(x-1+W)%W, yu=(y-1+H)%H, yd=(y+1)%H;
      const dQdx=(get(idx(xr,y),CH.Q)-get(idx(xl,y),CH.Q))*0.5;
      const dQdy=(get(idx(x,yu),CH.Q)-get(idx(x,yd),CH.Q))*0.5;
      const dPdx=(get(idx(xr,y),CH.P)-get(idx(xl,y),CH.P))*0.5;
      const dPdy=(get(idx(x,yu),CH.P)-get(idx(x,yd),CH.P))*0.5;
      const dSdx=(get(idx(xr,y),CH.S)-get(idx(xl,y),CH.S))*0.5;
      const dSdy=(get(idx(x,yu),CH.S)-get(idx(x,yd),CH.S))*0.5;
      const dxm=Math.abs(dQdx)+Math.abs(dPdx)+Math.abs(dSdx);
      const dym=Math.abs(dQdy)+Math.abs(dPdy)+Math.abs(dSdy);
      const mag=Math.hypot(dxm,dym); edgeMap[i]=mag; if(mag>maxMag) maxMag=mag;
      orient[i]=(Math.abs(dxm-dym)<0.02)?3:((dxm>dym)?1:2);
    });
    const inv=1/maxMag; for(let k=0;k<edgeMap.length;k++) edgeMap[k]=Math.min(1,edgeMap[k]*inv);
  }
  function smoothSemantic(iter=1){
    for(let k=0;k<iter;k++){
      forEachPixel((x,y,i)=>{
        let q=0,p=0,s=0,c=0;
        for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
          const j=idx(x+dx,y+dy);
          q+=get(j,CH.Q); p+=get(j,CH.P); s+=get(j,CH.S); c++;
        }
        set(i,CH.Q,q/c); set(i,CH.P,p/c); set(i,CH.S,s/c);
      });
    }
  }
  function buildMeaningful(){
    const A={x:16,y:18,col:[1,0.2,0.2]}, B={x:48,y:22,col:[0.2,1,0.2]}, C={x:28,y:48,col:[0.2,0.2,1]};
    const sigma=18, inv2s2=1/(2*sigma*sigma);
    forEachPixel((x,y,i)=>{
      const dA=(x-A.x)**2+(y-A.y)**2, dB=(x-B.x)**2+(y-B.y)**2, dC=(x-C.x)**2+(y-C.y)**2;
      let wA=Math.exp(-dA*inv2s2), wB=Math.exp(-dB*inv2s2), wC=Math.exp(-dC*inv2s2);
      const s=wA+wB+wC; wA/=s; wB/=s; wC/=s;
      set(i,CH.Q,wA); set(i,CH.P,wB); set(i,CH.S,clamp01(wC));
      const r=wA*A.col[0]+wB*B.col[0]+wC*C.col[0];
      const g=wA*A.col[1]+wB*B.col[1]+wC*C.col[1];
      const b=wA*A.col[2]+wB*B.col[2]+wC*C.col[2];
      set(i,CH.R,clamp01(r)); set(i,CH.G,clamp01(g)); set(i,CH.B,clamp01(b));
      rails[i]=0;
    });
    writePayloadIntoS(el('payload')?.value||"BNP");
    computeEdgeAndOrientation();
    forEachPixel((x,y,i)=>{
      const e=edgeMap[i];
      if(e>0.25 && Math.random()<0.35*e){ rails[i]=orient[i]; }
    });
  }
  function buildRandom(){
    forEachPixel((x,y,i)=>{
      const r=(Math.sin(x*12.9898+y*78.233)*43758.5453)%1;
      const g=(Math.sin(x*4.12+y*19.11+11.3)*9983.1)%1;
      const b=(Math.sin(x*7.77+y*5.55+3.3)*6007.7)%1;
      set(i,CH.R,clamp01(r<0?r+1:r));
      set(i,CH.G,clamp01(g<0?g+1:g));
      set(i,CH.B,clamp01(b<0?b+1:b));
      set(i,CH.Q,Math.random()); set(i,CH.P,Math.random()); set(i,CH.S,Math.random());
      rails[i]=(Math.random()<0.03)?(1+(Math.random()*3|0)):0;
    });
    for(let k=0;k<edgeMap.length;k++){ edgeMap[k]=0; orient[k]=((k&1)?1:2); }
  }

  // --- Gates ---
  function reseedGates(){
    const cov=numVal(gateCov,60)/100;
    for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
      const r=(hash2(tx,ty)%1000)/1000;
      gateTile[tIdx(tx,ty)] = (r<cov)?1:0;
    }
    if (gateCovVal) gateCovVal.textContent = Math.round(cov*100)+'%';
  }
  function gateAtPixel(i){
    if(!on(gateEnable,true)) return 1;
    const x=i%W, y=(i/W)|0, tx=(x/TILE)|0, ty=(y/TILE)|0;
    return gateTile[tIdx(tx,ty)];
  }
  function gateAtTile(t){ return on(gateEnable,true) ? gateTile[t] : 1; }

  // --- Proper-time cτ ---
  function reseedCTau(){
    for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
      const r=(hash2(tx*13,ty*17)%1000)/1000;
      const spread=cTauSpread;
      cTau[tIdx(tx,ty)] = 1.0 + (r*2-1)*spread;
    }
  }
  function ctOfTile(t){ return cTau[t]; }

  // --- Flips ---
  function meaningfulFlips(baseProb, biasMul){
    flipsLast=0;
    prevRails = new Uint8Array(rails);
    forEachPixel((x,y,i)=>{
      const p = baseProb * (0.25 + biasMul * edgeMap[i]);
      if(Math.random()<p){
        const prev=rails[i];
        let v = (prev!==0) ? 0 : orient[i]; if(v===0) v=1+(Math.random()*3|0);
        if(on(gateEnable,true) && on(gateRails,true) && !gateAtPixel(i)) v=prev;
        if(v!==prev){ rails[i]=v; flipsLast++; }
      }
    });
  }

  // --- Rail field ---
  function buildRailField(R){
    railField.fill(0);
    let events=0;
    const ker=[];
    for(let dy=-R;dy<=R;dy++) for(let dx=-R;dx<=R;dx++){
      const d=Math.hypot(dx,dy); if(d<=R) ker.push([dx,dy,hann(d/R)]);
    }
    forEachPixel((x,y,i)=>{
      const r=rails[i]; if(!r) return; events++;
      const lane=r-1;
      for(const [dx,dy,w] of ker){
        const j=idx(x+dx,y+dy);
        railField[j*3+lane]+=w;
      }
    });
    let maxw=1; for(let k=0;k<railField.length;k++) if(railField[k]>maxw) maxw=railField[k];
    const inv=1/maxw; for(let k=0;k<railField.length;k++) railField[k]*=inv;
    eventsLast=events;
  }

  // --- Micro-NNMs ---
  function tileActiveAt(tx,ty){
    if(schedMode.value!=='bitonic') return true;
    return !!tileActive[tIdx(tx,ty)];
  }
  function applyGate(oldVal,newVal,i){ const g=gateAtPixel(i); return g?newVal:oldVal; }

  function nnm1_gate(){
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        if(!tileActiveAt(tx,ty)) continue;
        const t=tIdx(tx,ty), ct=ctOfTile(t);
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const gx=railField[i*3+0], gy=railField[i*3+1], gz=railField[i*3+2];
          const gain=0.12*ct;
          const clampGain=v=>Math.max(0.9,Math.min(1.1,v));
          const fR=clampGain(1 + gain*(gx - (gy+gz)/2));
          const fG=clampGain(1 + gain*(gy - (gx+gz)/2));
          const fB=clampGain(1 + gain*(gz - (gx+gy)/2));
          const nR=clamp01(sheet[i*6+CH.R]*fR);
          const nG=clamp01(sheet[i*6+CH.G]*fG);
          const nB=clamp01(sheet[i*6+CH.B]*fB);
          sheet[i*6+CH.R]=applyGate(sheet[i*6+CH.R],nR,i);
          sheet[i*6+CH.G]=applyGate(sheet[i*6+CH.G],nG,i);
          sheet[i*6+CH.B]=applyGate(sheet[i*6+CH.B],nB,i);
        }
      }
    }
  }
  function nnm2_pixelDrift(){
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        if(!tileActiveAt(tx,ty)) continue;
        const t=tIdx(tx,ty), ct=ctOfTile(t);
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const mag=railField[i*3+0]+railField[i*3+1]+railField[i*3+2];
          const ctBlend=(0.05 + 0.25*get(i,CH.Q)) * (1+0.6*mag) * ct;
          let r=0,g=0,b=0,c=0;
          for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
            const j=idx(x+dx,y+dy);
            r+=sheet[j*6+CH.R]; g+=sheet[j*6+CH.G]; b+=sheet[j*6+CH.B]; c++;
          }
          const nR=lerp(sheet[i*6+CH.R], r/c, ctBlend);
          const nG=lerp(sheet[i*6+CH.G], g/c, ctBlend);
          const nB=lerp(sheet[i*6+CH.B], b/c, ctBlend);
          sheet[i*6+CH.R]=applyGate(sheet[i*6+CH.R],nR,i);
          sheet[i*6+CH.G]=applyGate(sheet[i*6+CH.G],nG,i);
          sheet[i*6+CH.B]=applyGate(sheet[i*6+CH.B],nB,i);
        }
      }
    }
  }
  function nnm3_tileMix(){
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        if(!tileActiveAt(tx,ty)) continue;
        const t=tIdx(tx,ty), ct=ctOfTile(t);
        let r=0,g=0,b=0,c=0,mag=0;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          r+=sheet[i*6+CH.R]; g+=sheet[i*6+CH.G]; b+=sheet[i*6+CH.B]; c++;
          mag+=railField[i*3+0]+railField[i*3+1]+railField[i*3+2];
        }
        r/=c; g/=c; b/=c; mag/=Math.max(1,c);
        const soft= (0.03+0.12*mag)*ct;
        const cx=tx*TILE+TILE/2, cy=ty*TILE+TILE/2;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const px=tx*TILE+x, py=ty*TILE+y, i=idx(px,py);
          const dx=Math.abs(px-cx)/(TILE/2), dy=Math.abs(py-cy)/(TILE/2);
          const w=hann(Math.max(dx,dy)); const t=w*soft;
          tmpRGB[i*3+0]=lerp(sheet[i*6+CH.R], r, t);
          tmpRGB[i*3+1]=lerp(sheet[i*6+CH.G], g, t);
          tmpRGB[i*3+2]=lerp(sheet[i*6+CH.B], b, t);
        }
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          sheet[i*6+CH.R]=applyGate(sheet[i*6+CH.R],tmpRGB[i*3+0],i);
          sheet[i*6+CH.G]=applyGate(sheet[i*6+CH.G],tmpRGB[i*3+1],i);
          sheet[i*6+CH.B]=applyGate(sheet[i*6+CH.B],tmpRGB[i*3+2],i);
        }
      }
    }
  }
  function keepEnergy(){
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        if(!tileActiveAt(tx,ty)) continue;
        const t=tIdx(tx,ty), ct=clamp01(ctOfTile(t));
        const target=0.55, alphaK=0.03*ct;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const r=sheet[i*6+CH.R], g=sheet[i*6+CH.G], b=sheet[i*6+CH.B];
          const l=0.2126*r+0.7152*g+0.0722*b, s=1+alphaK*(target-l);
          const nR=clamp01(r*s), nG=clamp01(g*s), nB=clamp01(b*s);
          sheet[i*6+CH.R]=applyGate(r,nR,i);
          sheet[i*6+CH.G]=applyGate(g,nG,i);
          sheet[i*6+CH.B]=applyGate(b,nB,i);
        }
      }
    }
  }
  function nnm4_domain(){
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        if(!tileActiveAt(tx,ty)) continue;
        const t=tIdx(tx,ty), ct=ctOfTile(t);
        let sx=0,sy=0,sz=0,c=0;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y); sx+=railField[i*3+0]; sy+=railField[i*3+1]; sz+=railField[i*3+2]; c++;
        }
        const ax=clamp01(sx/c), ay=clamp01(sy/c), az=clamp01(sz/c);
        const blend=0.2*ct;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          set(i,CH.Q, applyGate(get(i,CH.Q), lerp(get(i,CH.Q), ax, blend), i));
          set(i,CH.P, applyGate(get(i,CH.P), lerp(get(i,CH.P), ay, blend), i));
          set(i,CH.S, applyGate(get(i,CH.S), lerp(get(i,CH.S), az, blend), i));
        }
      }
    }
  }

  // --- Q2 Bus helpers ---
  function q2PushTok(t){ q2Tokens.push(t&3); }
  function q2EmitBase3(n){
    if(n===0){ q2PushTok(0); q2PushTok(3); return; }
    let digits=[]; while(n>0){ digits.push(n%3); n=Math.floor(n/3); }
    for(const d of digits) q2PushTok(d);
    q2PushTok(3);
  }
  function q2EmitKey(key){ q2EmitBase3(key+1); }
  function q2PackBytes(){
    const byteLen=Math.ceil(q2Tokens.length/4);
    const cap=q2CapBytes;
    const start=Math.max(0, byteLen - cap);
    if(start>0){ q2Tokens = q2Tokens.slice(start*4); }
    const bytes=new Uint8Array(Math.ceil(q2Tokens.length/4));
    for(let i=0;i<q2Tokens.length;i++){
      const lane = i&3, bi = i>>2;
      bytes[bi] |= (q2Tokens[i] & 3) << ((3-lane)*2);
    }
    return bytes;
  }
  function q2UpdatePreview(){
    const bytes=q2PackBytes();
    const hex=[...bytes].slice(0,256).map(b=>b.toString(16).padStart(2,'0')).join(' ');
    q2Tok.textContent = q2Tokens.length.toString();
    q2Bytes.textContent = bytes.length.toString();
    q2Codons.textContent = (q2Tokens.length).toString();
    q2Preview.textContent = bytes.length? hex : '(empty)';
  }
  function q2CodonString(){ const map=['A','C','G','T']; return q2Tokens.map(t=>map[t]).join(''); }

  function q2EmitFlipEvent(x,y,a,b,axisKey){
    if(a===b) return;
    let TYPE, value;
    if((a===0 && b>0) || (b===0 && a>0)){ TYPE=Q2_TYPE.TINY2; value=(b>0)?1:0; }
    else{
      TYPE=Q2_TYPE.SYM3;
      const s=Math.min(a,b), t=Math.max(a,b);
      value = (s===1 && t===2)?1 : (s===2 && t===3)?2 : 3;
    }
    q2EmitKey(axisKey); q2PushTok(TYPE);
    if(TYPE===Q2_TYPE.TINY2) q2PushTok(value); else q2EmitBase3(value);
    if(on(q2Morton)){ q2EmitKey(7); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(mortonXY(x,y)); }
    q2EmitKey(6); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(tickCount % 81);
  }
  function q2EmitLogicEvent(tile, kindCode, bit){
    if(!on(q2Enable)) return;
    q2EmitKey(5); q2PushTok(Q2_TYPE.SYM3); q2EmitBase3(kindCode);
    q2EmitKey(8); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(tile);
    if(on(q2Morton)){ const tx=tile%TX, ty=(tile/TX)|0; q2EmitKey(7); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(mortonXY(tx,ty)); }
    q2EmitKey(6); q2PushTok(Q2_TYPE.TINY2); q2PushTok(bit?1:0);
  }
  function q2EmitProto(tile, kindCode , peer){
    if(!on(q2Enable)) return;
    q2EmitKey(5); q2PushTok(Q2_TYPE.SYM3); q2EmitBase3(kindCode);
    q2EmitKey(8); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(tile);
    q2EmitKey(9); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(Math.max(0,peer|0));
    q2EmitKey(6); q2PushTok(Q2_TYPE.UINT3); q2EmitBase3(tickCount % 243);
  }

  // --- Tier-aware Logic ---
  function evalLogicTierAware(){
    const T=numVal(thr,0.42);
    prevSUM = new Uint8Array(tileSUM);
    prevCAR = new Uint8Array(tileCAR);

    for(let ty=0; ty<TY; ty++){
      for(let tx=0; tx<TX; tx++){
        let rx=0,ry=0,rz=0, mag=0;
        let rA=0,gA=0,bA=0, qA=0,pA=0,sA=0;
        let lSum=0,l2Sum=0,cnt=0;

        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const r=get(i,CH.R), g=get(i,CH.G), b=get(i,CH.B);
          const q=get(i,CH.Q), p=get(i,CH.P), s=get(i,CH.S);
          const fx=railField[i*3+0], fy=railField[i*3+1], fz=railField[i*3+2];
          rx+=fx; ry+=fy; rz+=fz; mag+=fx+fy+fz;
          rA+=r; gA+=g; bA+=b; qA+=q; pA+=p; sA+=s;
          const L=0.2126*r+0.7152*g+0.0722*b; lSum+=L; l2Sum+=L*L;
          cnt++;
        }

        rx/=cnt; ry/=cnt; rz/=cnt; mag = clamp01(mag/(cnt*1.5));
        rA/=cnt; gA/=cnt; bA/=cnt; qA/=cnt; pA/=cnt; sA/=cnt;

        const rgbSum = rA+gA+bA+EPS;
        const rgbDomA = clamp01(rA/rgbSum);
        const rgbDomB = clamp01(gA/rgbSum);
        const rgbDomC = clamp01(bA/rgbSum);

        const meanL = lSum/cnt;
        const varL = Math.max(0, l2Sum/cnt - meanL*meanL);
        const stdL = Math.sqrt(varL);
        const coh = clamp01(1 - 2.2*stdL);

        const aSoft = clamp01(FW.wRail*rx + FW.wRGB*rgbDomA + FW.wSem*qA + FW.wTile*mag + FW.wCoh*coh);
        const bSoft = clamp01(FW.wRail*ry + FW.wRGB*rgbDomB + FW.wSem*pA + FW.wTile*mag + FW.wCoh*coh);
        const cSoft = clamp01(FW.wRail*rz + FW.wRGB*rgbDomC + FW.wSem*sA + FW.wTile*mag + FW.wCoh*coh);

        const iTile=tIdx(tx,ty);
        tileA[iTile] = aSoft>=T ? 1 : 0;
        tileB[iTile] = bSoft>=T ? 1 : 0;
        tileC[iTile] = cSoft>=T ? 1 : 0;

        const m = Math.max(rx,ry,rz);
        tileFlow[iTile] = (m===rx)?1 : (m===ry)?2 : 3;

        const A=tileA[iTile], B=tileB[iTile], C=tileC[iTile];
        let SUM=0, CAR=0;
        switch((logicFn && logicFn.value) || 'FA'){
          case 'FA': SUM=(A^B)^C; CAR=(A&B)|(B&C)|(A&C); break;
          case 'HA': SUM=A^B;     CAR=A&B;               break;
          case 'MAJ':SUM=((A&B)|(B&C)|(A&C))?1:0; CAR=0; break;
          case 'XOR3':SUM=(A^B)^C; CAR=0;                break;
        }

        tileSUM[iTile]=SUM; tileCAR[iTile]=CAR;

        tilePos[iTile*3+0]=qA; tilePos[iTile*3+1]=pA; tilePos[iTile*3+2]=sA;
      }
    }

    // Apply math overrides
    for(let t=0;t<NT;t++){
      if(!ovMask[t]) continue;
      tileA[t]=ovA[t]; tileB[t]=ovB[t]; tileC[t]=ovC[t];
      if(ovSUM[t]!==-1) tileSUM[t]=ovSUM[t];
      if(ovCAR[t]!==-1) tileCAR[t]=ovCAR[t];
    }

    // Q2 logic events
    for(let t=0;t<NT;t++){
      if(tileSUM[t]!==prevSUM[t]) q2EmitLogicEvent(t, 1, tileSUM[t]);
      if(tileCAR[t]!==prevCAR[t]) q2EmitLogicEvent(t, 2, tileCAR[t]);
    }
  }

  // --- BitBias & scheduler ---
  function computeBitBias(){
    // Incorporate physics residual when enabled
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        let mag=0, lSum=0, l2Sum=0, eSum=0, rSum=0, c=0;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const r=get(i,CH.R), g=get(i,CH.G), b=get(i,CH.B);
          const L=0.2126*r+0.7152*g+0.0722*b; lSum+=L; l2Sum+=L*L;
          eSum+=edgeMap[i];
          mag+=railField[i*3+0]+railField[i*3+1]+railField[i*3+2];
          if(physEnabled) rSum+=Math.abs(physRes[i]);
          c++;
        }
        mag/=c; eSum/=c; rSum/=Math.max(1,c);
        const meanL=lSum/c, varL=Math.max(0, l2Sum/c-meanL*meanL);
        const coh=clamp01(1-2.2*Math.sqrt(varL));
        const resTerm = physEnabled ? clamp01(rSum/(1+Math.abs(physResidualAvg))) : 0;
        const score=clamp01(0.45*mag + 0.20*coh + 0.20*eSum + 0.15*resTerm);
        bitBias[tIdx(tx,ty)]=score;
      }
    }
  }
  function bitonicSortIdxDesc(arrScores){
    let idxs=Array.from({length:NT},(_,i)=>i);
    let n=1; while(n<idxs.length) n<<=1;
    while(idxs.length<n){ idxs.push(idxs[idxs.length-1]); }
    function compare(i,j,dir){
      const a=idxs[i], b=idxs[j];
      const sa=arrScores[a], sb=arrScores[b];
      const swap = dir ? (sa<sb) : (sa>sb);
      if(swap){ const t=idxs[i]; idxs[i]=idxs[j]; idxs[j]=t; }
    }
    function bitonicMerge(lo,cnt,dir){
      if(cnt>1){
        const k=cnt>>1;
        for(let i=lo;i<lo+cnt-k;i++) compare(i,i+k,dir);
        bitonicMerge(lo,k,dir); bitonicMerge(lo+k,k,dir);
      }
    }
    function bitonicSort(lo,cnt,dir){
      if(cnt>1){
        const k=cnt>>1;
        bitonicSort(lo,k,true);
        bitonicSort(lo+k,k,false);
        bitonicMerge(lo,cnt,dir);
      }
    }
    bitonicSort(0,n,true);
    return idxs.slice(0,NT);
  }
  function scheduleTiles(){
    if(schedMode.value!=='bitonic'){
      for(let t=0;t<NT;t++) tileActive[t]=1;
      return;
    }
    computeBitBias();
    const order=bitonicSortIdxDesc(bitBias);
    const K=Math.max(1, Math.floor(NT*admitFrac));
    for(let t=0;t<NT;t++) tileActive[t]=0;
    for(let k=0;k<K;k++){ tileActive[order[k]]=1; }
  }

  // --- Protocol step + trails ---
  function protoStep(){
    reqPrev.set(reqNow); ackPrev.set(ackNow);
    reqNow.fill(0); ackNow.fill(0);

    const startP=numVal(protoStart,0.01), faultP=numVal(faultPct,5)/100;

    if(on(protoEnable,true)){
      for(let t=0;t<NT;t++){
        if(Math.random()<startP*bitBias[t]){
          const tx=t%TX, ty=(t/TX)|0;
          const chooseRight = Math.random()<0.6;
          const nx = chooseRight ? (tx+1)%TX : tx;
          const ny = chooseRight ? ty : (ty+1)%TY;
          const nbr = tIdx(nx,ny);
          if(Math.random()>=faultP){ reqNow[t]=1; partner[t]=nbr; }
        }
      }
      for(let t=0;t<NT;t++){
        let gotReqFrom=-1;
        const tx=t%TX, ty=(t/TX)|0;
        const left=tIdx((tx-1+TX)%TX,ty), up=tIdx(tx,(ty-1+TY)%TY);
        if(reqNow[left] && partner[left]===t) gotReqFrom=left;
        else if(reqNow[tIdx((tx+1)%TX,ty)] && partner[tIdx((tx+1)%TX,ty)]===t) gotReqFrom=tIdx((tx+1)%TX,ty);
        else if(reqNow[up] && partner[up]===t) gotReqFrom=up;
        else if(reqNow[tIdx(tx,(ty+1)%TY)] && partner[tIdx(tx,(ty+1)%TY)]===t) gotReqFrom=tIdx(tx,(ty+1)%TY);
        if(gotReqFrom>=0){
          if(Math.random()>=faultP){ ackNow[t]=1; partner[t]=gotReqFrom; }
        }
      }
      for(let t=0;t<NT;t++){
        if(reqNow[t]){
          const dst=partner[t];
          if(ackNow[dst] && partner[dst]===t){
            hsTotal++;
            q2EmitProto(t,6,dst); q2EmitProto(dst,6,t);
            const ttl=numVal(trailSec,6);
            trailEdges.push({u:t,v:dst,life:ttl,ttl});
            while(trailEdges.length>MAX_TRAILS) trailEdges.shift();
            reqNow[t]=0; ackNow[dst]=0;
          }
        }
      }
    }

    let reqEdge=0, ackEdge=0;
    for(let t=0;t<NT;t++){
      if(reqNow[t] && !reqPrev[t]){ reqEdge++; q2EmitProto(t,4,partner[t]); }
      if(ackNow[t] && !ackPrev[t]){ ackEdge++; q2EmitProto(t,5,partner[t]); }
    }
    reqEdges+=reqEdge; ackEdges+=ackEdge;
    hsCount.textContent=hsTotal; reqEdgesLbl.textContent=reqEdges; ackEdgesLbl.textContent=ackEdges;
  }

  // --- 3D helpers ---
  function proj3D(x,y,z,w,h,rotX,rotY){
    const fov=420, cx=w/2, cy=h/2;
    const cosX=Math.cos(rotX), sinX=Math.sin(rotX), cosY=Math.cos(rotY), sinY=Math.sin(rotY);
    let zx=x*cosY+z*sinY, zz=-x*sinY+z*cosY;
    let yx=y*cosX-zz*sinX, yz=y*sinX+zz*cosX;
    const d=1.5+yz;
    return [cx+(zx*fov)/d, cy-(yx*fov)/d, d];
  }
  function neighborOf(t,dir){
    const tx=t%TX, ty=(t/TX)|0;
    if(dir===1) return tIdx((tx+1)%TX,ty);
    if(dir===2) return tIdx(tx,(ty+1)%TY);
    return tIdx((tx+1)%TX,(ty+1)%TY);
  }
  function decayTrails(dtSec){
    for(let i=trailEdges.length-1;i>=0;i--){
      const e=trailEdges[i]; e.life-=dtSec; if(e.life<=0) trailEdges.splice(i,1);
    }
    for(let i=rayEdges.length-1;i>=0;i--){
      const e=rayEdges[i]; e.life-=dtSec; if(e.life<=0) rayEdges.splice(i,1);
    }
    for(let i=ray2DPath.length-1;i>=0;i--){
      ray2DPath[i][4]-=dtSec; if(ray2DPath[i][4]<=0) ray2DPath.splice(i,1);
    }
  }

  // --- Math mapping & engine ---
  function bitToTile(bit){
    const row = (bit/ TX)|0;
    const col = bit % TX;
    const ty = TY-1 - row;
    const tx = col;
    return tIdx(tx,ty);
  }
  function clearOverrides(){
    ovA.fill(0); ovB.fill(0); ovC.fill(0);
    ovSUM.fill(-1); ovCAR.fill(-1); ovMask.fill(0);
  }
  function hexToBits(hex, bits){
    const v = parseInt(hex.replace(/[^0-9a-f]/ig,''),16)>>>0;
    const out=new Uint8Array(bits);
    for(let b=0;b<bits;b++) out[b]= (v>>b)&1;
    return out;
  }
  function bitsToHex(arr){
    let v=0; for(let b=0;b<arr.length;b++) v |= (arr[b]&1)<<b;
    return ('0000'+v.toString(16).toUpperCase()).slice(-4);
  }
  function accValue(){ let v=0; for(let b=0;b<mathBits;b++) v|=(regACC[b]&1)<<b; return v>>>0; }
  function nValue(){ let v=0; for(let b=0;b<mathBits;b++) v|=(regN[b]&1)<<b; return v>>>0; }

  function mathLoadRegs(){
    regA = hexToBits(mathA.value||'0000', mathBits);
    regB = hexToBits(mathB.value||'0000', mathBits);
    regN = hexToBits(mathN.value||'0000', mathBits);
    regACC = new Uint8Array(mathBits);
    mathStatus.textContent='loaded A='+mathA.value.toUpperCase()+'  B='+mathB.value.toUpperCase()+'  N='+mathN.value.toUpperCase();
  }
  function stageAdd(srcBits, shift){ mathQueue.push({op:'ADD', src:srcBits.slice(0), shift:shift|0}); }
  function stageSubN(){ mathQueue.push({op:'SUBN'}); }
  function maybeReduceMod(){
    const acc=accValue(), N=nValue();
    if(N===0) return;
    if(acc>=N) stageSubN();
  }
  function mathStart(){
    mathProblem = mathProblemSel.value;
    mathStep=0; mathCarry=0; mathQueue.length=0;
    clearOverrides();
    if(mathProblem===M.ADD16){
      stageAdd(regA,0); stageAdd(regB,0);
      mathStatus.textContent='ADD16: ACC=A+B';
    } else if(mathProblem===M.MUL16MOD){
      for(let k=0;k<mathBits;k++) if(regB[k]) stageAdd(regA,k);
      mathStatus.textContent='MUL16MOD: ACC=A·B mod N';
    } else {
      mathStatus.textContent='idle';
    }
  }
  function renderBitOverridesAllInputs(){
    for(let b=0;b<mathBits;b++){ const t=bitToTile(b); ovMask[t]=1; ovA[t]=regA[b]; ovB[t]=regB[b]; }
  }
  function mathTick(){
    if(!mathEnabled || mathProblem===M.NONE) return;
    renderBitOverridesAllInputs();
    for(let b=0;b<mathBits;b++){ const t=bitToTile(b); ovSUM[t]=-1; ovCAR[t]=-1; ovC[t]=0; }
    if(mathQueue.length===0){
      mathStatus.textContent = (mathProblem===M.MUL16MOD)
        ? `done: ACC=${bitsToHex(regACC)} (dec ${accValue()})`
        : `done: SUM=${bitsToHex(regACC)} (dec ${accValue()})`;
      return;
    }
    const cur = mathQueue[0];
    if(cur.op==='ADD'){
      const b = mathStep;
      if(b>=mathBits){
        mathQueue.shift(); mathStep=0; mathCarry=0;
        if(mathProblem===M.MUL16MOD) maybeReduceMod();
        return;
      }
      const srcBit = (b-cur.shift)>=0 ? (cur.src[b-cur.shift]||0) : 0;
      const accBit = regACC[b]||0;
      const A=accBit, B=srcBit, C=mathCarry;
      const SUM = (A^B)^C;
      const CAR = (A&B)|(B&C)|(A&C);
      regACC[b]=SUM; mathCarry=CAR;
      const t=bitToTile(b);
      ovMask[t]=1; ovA[t]=A; ovB[t]=B; ovC[t]=C; ovSUM[t]=SUM; ovCAR[t]=CAR;
      if(b<mathBits-1){
        const u=t, v=bitToTile(b+1);
        const ttl=numVal(trailSec,6)*0.5;
        trailEdges.push({u,v,life:ttl,ttl}); while(trailEdges.length>MAX_TRAILS) trailEdges.shift();
      }
      mathStatus.textContent=`ADD bit ${b}: ACC=${bitsToHex(regACC)}`;
      mathStep++;
      return;
    } else if(cur.op==='SUBN'){
      const b = mathStep;
      if(b===0){ mathCarry=1; }
      if(b>=mathBits){
        mathQueue.shift(); mathStep=0; mathCarry=0;
        mathStatus.textContent=`REDUCE: ACC mod N → ${bitsToHex(regACC)}`;
        return;
      }
      const A=regACC[b]||0, B=(regN[b]^1)||0, C=mathCarry;
      const SUM=(A^B)^C, CAR=(A&B)|(B&C)|(A&C);
      regACC[b]=SUM; mathCarry=CAR;
      const t=bitToTile(b);
      ovMask[t]=1; ovA[t]=A; ovB[t]=B; ovC[t]=C; ovSUM[t]=SUM; ovCAR[t]=CAR;
      if(b<mathBits-1){
        const u=t, v=bitToTile(b+1);
        const ttl=numVal(trailSec,6)*0.5;
        trailEdges.push({u,v,life:ttl,ttl}); while(trailEdges.length>MAX_TRAILS) trailEdges.shift();
      }
      mathStatus.textContent=`SUBN bit ${b}: ACC=${bitsToHex(regACC)}`;
      mathStep++;
      return;
    }
  }

  // --- Physics: target K and normalization ---
  function normFieldTo(arr, outCh){
    let mn=+1e9, mx=-1e9;
    for(let i=0;i<arr.length;i++){ const v=arr[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
    const den = (mx-mn)<1e-6?1:(mx-mn);
    for(let i=0;i<arr.length;i++){
      const t=(arr[i]-mn)/den;
      if(outCh!=null) set(i,outCh, clamp01(t));
    }
    return {min:mn,max:mx};
  }
  function buildKtgt(){
    const mode = physSrc.value || 'S';
    if(mode==='S'){
      for(let i=0;i<W*H;i++) physKtgt[i] = (get(i,CH.S)-0.5)*2.0; // centered
    } else if(mode==='SYN'){
      // three Gaussians
      const Gs=[{x:18,y:20,s:9,a:1.0},{x:46,y:22,s:7,a:-0.8},{x:30,y:46,s:11,a:0.6}];
      forEachPixel((x,y,i)=>{
        let v=0;
        for(const g of Gs){
          const dx=x-g.x, dy=y-g.y; v += g.a*Math.exp(-(dx*dx+dy*dy)/(2*g.s*g.s));
        }
        physKtgt[i]=v;
      });
    } else {
      // payload-derived: hash text into bumps
      const text=(el('payload')?.value || 'BNP');
      const rnd=seedFromString(text);
      const bumps=[];
      for(let k=0;k<4;k++){ bumps.push({x:(rnd()*W)|0, y:(rnd()*H)|0, s:6+rnd()*12, a: (rnd()<0.5?-1:1)*(0.5+0.7*rnd())}); }
      forEachPixel((x,y,i)=>{
        let v=0; for(const b of bumps){ const dx=x-b.x, dy=y-b.y; v+=b.a*Math.exp(-(dx*dx+dy*dy)/(2*b.s*b.s)); }
        physKtgt[i]=v;
      });
    }
    normFieldTo(physKtgt,null); // keep scale ~[0,1], but we want signed → recenter
    for(let i=0;i<W*H;i++) physKtgt[i]=(physKtgt[i]-0.5)*2.0;
  }

  function initU(){
    for(let i=0;i<W*H;i++) physU[i]=0; // start flat metric
    computeGradU();
    computeResidual();
  }

  // --- Discrete ops for physics ---
  function computeGradU(){
    forEachPixel((x,y,i)=>{
      const ux = (physU[idx(x+1,y)] - physU[idx(x-1,y)])*0.5;
      const uy = (physU[idx(x,y+1)] - physU[idx(x,y-1)])*0.5;
      physGx[i]=ux; physGy[i]=uy;
    });
  }
  function lapAnisotropic(i,x,y){
    // rail-biased 5+diag stencil
    const wx = 0.5 + 0.5*railField[i*3+0];
    const wy = 0.5 + 0.5*railField[i*3+1];
    const wz = 0.35*railField[i*3+2];
    const u00 = physU[i];
    const uxp = physU[idx(x+1,y)], uxm = physU[idx(x-1,y)];
    const uyp = physU[idx(x,y+1)], uym = physU[idx(x,y-1)];
    const uxpyp=physU[idx(x+1,y+1)], uxmyp=physU[idx(x-1,y+1)];
    const uxpym=physU[idx(x+1,y-1)], uxmym=physU[idx(x-1,y-1)];
    const lap5 = wx*(uxp - 2*u00 + uxm) + wy*(uyp - 2*u00 + uym);
    const lapD = wz*((uxpyp+uxpym+uxmyp+uxmym) - 4*u00);
    return lap5 + lapD;
  }
  function computeResidual(){
    let sum=0;
    forEachPixel((x,y,i)=>{
      const lap = lapAnisotropic(i,x,y);
      const Ku = Math.exp(2*physU[i]) * physKtgt[i];
      const R = lap + Ku;
      physRes[i]=R; sum+=R*R;
    });
    physResidualAvg = Math.sqrt(sum/(W*H));
  }
  function ricciStep(){
    if(!physEnabled) return;
    const a=alphaStep, lam=lambdaSmooth;

    // propose u'
    forEachPixel((x,y,i)=>{
      if(!gateAtPixel(i)){ physU2[i]=physU[i]; return; } // obstacle
      const lap = lapAnisotropic(i,x,y);
      const R = physRes[i];
      // gradient descent on R + smoothness
      physU2[i] = physU[i] - a*R + lam*lap;
    });

    // commit
    for(let i=0;i<W*H;i++) physU[i]=physU2[i];

    // refresh grads/residual
    computeGradU();
    computeResidual();

    // Per-tile accept visualization + Q2 proto
    const ttl=numVal(trailSec,6)*0.6;
    for(let ty=0;ty<TY;ty++){
      for(let tx=0;tx<TX;tx++){
        const t=tIdx(tx,ty);
        // pick a downhill neighbor by residual gradient
        // estimate gradR at tile center
        let gx=0,gy=0,c=0,avgR=0;
        for(let y=0;y<TILE;y++) for(let x=0;x<TILE;x++){
          const i=idx(tx*TILE+x,ty*TILE+y);
          const rx=(physRes[idx((tx*TILE+x)+1,ty*TILE+y)]-physRes[idx((tx*TILE+x)-1,ty*TILE+y)])*0.5;
          const ry=(physRes[idx(tx*TILE+x,(ty*TILE+y)+1)]-physRes[idx(tx*TILE+x,(ty*TILE+y)-1)])*0.5;
          gx+=rx; gy+=ry; avgR+=Math.abs(physRes[i]); c++;
        }
        gx/=c; gy/=c; avgR/=c;
        const nx = Math.abs(gx)>Math.abs(gy) ? (gx>0?-1:1) : 0;
        const ny = (nx===0) ? (gy>0?-1:1) : 0;
        const peer=tIdx(tx+nx,ty+ny);
        if(avgR>0.02 && gateAtTile(t) && gateAtTile(peer)){
          q2EmitProto(t, 7, peer); // class code 7 = "flow accept"
          rayEdges.push({u:t,v:peer,life:ttl,ttl});
          while(rayEdges.length>MAX_RAY_EDGES) rayEdges.shift();
        }
      }
    }

    // Map to Q,P,S for the semantic space
    const statU=normFieldTo(physU,null);
    const gmag=new Float32Array(W*H);
    for(let i=0;i<W*H;i++) gmag[i]=Math.hypot(physGx[i],physGy[i]);
    normFieldTo(physU,CH.Q);
    normFieldTo(gmag,CH.P);
    // Map Ktgt back to S (centered → shift to [0,1])
    const Kview=new Float32Array(W*H);
    for(let i=0;i<W*H;i++) Kview[i]=0.5+0.5*Math.tanh(physKtgt[i]);
    for(let i=0;i<W*H;i++) set(i,CH.S, clamp01(Kview[i]));
  }

  // --- Rays ---
  function spawnRays(){
    if(!raysEnabled) return;
    const N=raysPerBurst;
    for(let k=0;k<N;k++){
      // spawn from border with inward direction
      let x,y,vx,vy;
      const side=Math.floor(Math.random()*4);
      if(side===0){ x=0; y=Math.random()*H; vx=1; vy=(Math.random()*2-1); }
      else if(side===1){ x=W-1; y=Math.random()*H; vx=-1; vy=(Math.random()*2-1); }
      else if(side===2){ y=0; x=Math.random()*W; vy=1; vx=(Math.random()*2-1); }
      else { y=H-1; x=Math.random()*W; vy=-1; vx=(Math.random()*2-1); }
      const norm=Math.hypot(vx,vy)||1; vx/=norm; vy/=norm;
      rays.push({x,y,vx,vy,life:rayMaxSteps});
    }
  }
  function stepRays(){
    if(!raysEnabled) return;
    const h=rayStepPx;
    // optical index n = e^u, ∇ log n = ∇u = (physGx,physGy)
    for(let r=rays.length-1;r>=0;r--){
      const R=rays[r];
      if(R.life<=0){ rays.splice(r,1); continue; }

      const i=idx(Math.round(R.x), Math.round(R.y));
      const gx=physGx[i], gy=physGy[i];
      // acceleration projected orthogonal to velocity: a = g - (v·g) v
      const dot=R.vx*gx + R.vy*gy;
      let ax=gx - dot*R.vx;
      let ay=gy - dot*R.vy;
      // integrate (Heun/2-stage)
      let vx1=R.vx + ax*h*0.6;
      let vy1=R.vy + ay*h*0.6;
      const n1=Math.hypot(vx1,vy1)||1; vx1/=n1; vy1/=n1;

      const x1=R.x + vx1*h, y1=R.y + vy1*h;
      const i1=idx(Math.round(x1), Math.round(y1));
      const gx1=physGx[i1], gy1=physGy[i1];
      const dot1=vx1*gx1 + vy1*gy1;
      const ax1=gx1 - dot1*vx1, ay1=gy1 - dot1*vy1;

      R.vx = R.vx + 0.5*h*(ax+ax1);
      R.vy = R.vy + 0.5*h*(ay+ay1);
      const n2=Math.hypot(R.vx,R.vy)||1; R.vx/=n2; R.vy/=n2;

      const x0=R.x, y0=R.y;
      R.x += R.vx*h; R.y += R.vy*h;
      R.life--;

      // kill on gate or out of bounds
      if(R.x<0||R.x>=W||R.y<0||R.y>=H || !gateAtPixel(idx(Math.round(R.x),Math.round(R.y)))){
        rays.splice(r,1); continue;
      }

      // 2D path segment (fades ~2s)
      if(on(rayOverlay2D,true)){
        ray2DPath.push([x0,y0,R.x,R.y,2.0]);
        if(ray2DPath.length>2000) ray2DPath.shift();
      }

      // 3D edge between tiles crossed
      if(on(rayOverlay3D,true)){
        const t0=tIdx(((x0/TILE)|0), ((y0/TILE)|0));
        const t1=tIdx(((R.x/TILE)|0), ((R.y/TILE)|0));
        if(t0!==t1 && gateAtTile(t0) && gateAtTile(t1)){
          const ttl=6.0;
          rayEdges.push({u:t0,v:t1,life:ttl,ttl});
          while(rayEdges.length>MAX_RAY_EDGES) rayEdges.shift();
        }
      }
    }
  }

  // --- 2D draw ---
  function draw2D(){
    // base RGB
    const img=g2d.createImageData(W,H);
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const i=idx(x,y), p=i*6;
      const r=sheet[p+CH.R]*255|0, g=sheet[p+CH.G]*255|0, b=sheet[p+CH.B]*255|0;
      const k=(y*W+x)*4; img.data[k]=r; img.data[k+1]=g; img.data[k+2]=b; img.data[k+3]=255;
    }
    const off=document.createElement('canvas'); off.width=W; off.height=H;
    off.getContext('2d').putImageData(img,0,0);
    g2d.imageSmoothingEnabled=false; g2d.clearRect(0,0,c2d.width,c2d.height);
    g2d.drawImage(off,0,0,c2d.width,c2d.height);

    const scaleX=c2d.width/W, scaleY=c2d.height/H;

    // u heat overlay
    if(on(uOverlay,true) && physEnabled){
      // normalize u for display
      let mn=1e9,mx=-1e9; for(let i=0;i<W*H;i++){ const v=physU[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
      const den=(mx-mn)||1;
      g2d.globalAlpha=0.30;
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){
        const i=idx(x,y);
        const t=(physU[i]-mn)/den; // 0..1
        const r=(t*255)|0, b=(255-r)|0, a=0.35+0.35*Math.abs(physRes[i]);
        g2d.fillStyle=`rgba(${r},40,${b},${a})`;
        g2d.fillRect(x*scaleX,y*scaleY,scaleX,scaleY);
      }
      g2d.globalAlpha=1.0;
    }

    // cτ overlay
    if(on(ctauOverlay)){
      for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
        const t=tIdx(tx,ty), v=ctOfTile(t);
        const n=Math.max(0,Math.min(1,(v-0.5)/1.0));
        g2d.fillStyle=`rgba(${(n*255)|0},${(80*(1-n))|0},${(255*(1-n))|0},0.22)`;
        g2d.fillRect(tx*TILE*scaleX, ty*TILE*scaleY, TILE*scaleX, TILE*scaleY);
      }
    }

    // BitBias overlay
    if(on(bbOverlay)){
      for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
        const t=tIdx(tx,ty), v=bitBias[t];
        g2d.fillStyle=`rgba(0,255,120,${0.12 + 0.25*v})`;
        g2d.fillRect(tx*TILE*scaleX, ty*TILE*scaleY, TILE*scaleX, TILE*scaleY);
      }
    }

    // grid
    g2d.strokeStyle='#1c2530'; g2d.lineWidth=1;
    for(let x=0;x<=W;x+=TILE){ const X=x*scaleX; g2d.beginPath(); g2d.moveTo(X,0); g2d.lineTo(X,c2d.height); g2d.stroke(); }
    for(let y=0;y<=H;y+=TILE){ const Y=y*scaleY; g2d.beginPath(); g2d.moveTo(0,Y); g2d.lineTo(c2d.width,Y); g2d.stroke(); }

    // gates hashing
    if(on(gateEnable,true)){
      g2d.strokeStyle='rgba(255,209,102,0.45)'; g2d.lineWidth=1;
      for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
        if(!gateTile[tIdx(tx,ty)]){
          const x0=tx*TILE*scaleX, y0=ty*TILE*scaleY, w=TILE*scaleX, h=TILE*scaleY;
          for(let k=0;k<w+h; k+=8){
            g2d.beginPath();
            g2d.moveTo(x0+Math.max(0,k-h), y0+Math.min(h,k));
            g2d.lineTo(x0+Math.min(w,k), y0+Math.max(0,k-w));
            g2d.stroke();
          }
        }
      }
    }

    // rails dots
    g2d.fillStyle='#ffffff';
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const i=idx(x,y); if(rails[i]!==0){
        g2d.fillRect(x*scaleX+scaleX*0.35, y*scaleY+scaleY*0.35, Math.max(1,scaleX*0.3), Math.max(1,scaleY*0.3));
      }
    }

    // logic circles
    for(let ty=0;ty<TY;ty++) for(let tx=0;tx<TX;tx++){
      const X0=tx*TILE*scaleX, Y0=ty*TILE*scaleY, w=TILE*scaleX, h=TILE*scaleY;
      const centerX=X0+w/2, centerY=Y0+h/2;
      const t=tIdx(tx,ty), onA=tileA[t], onB=tileB[t], onC=tileC[t], onS=tileSUM[t], onK=tileCAR[t];
      g2d.beginPath(); g2d.fillStyle=`rgba(255,0,0,${onA?0.9:0.15})`; g2d.arc(X0+w*0.2,Y0+h*0.2, Math.max(2,Math.min(w,h)*0.08), 0, Math.PI*2); g2d.fill();
      g2d.beginPath(); g2d.fillStyle=`rgba(0,255,0,${onB?0.9:0.15})`; g2d.arc(X0+w*0.8,Y0+h*0.2, Math.max(2,Math.min(w,h)*0.08), 0, Math.PI*2); g2d.fill();
      g2d.beginPath(); g2d.fillStyle=`rgba(0,160,255,${onC?0.9:0.15})`; g2d.arc(X0+w*0.2,Y0+h*0.8, Math.max(2,Math.min(w,h)*0.08), 0, Math.PI*2); g2d.fill();
      g2d.beginPath(); g2d.fillStyle=`rgba(255,255,255,${onS?0.95:0.15})`; g2d.arc(X0+w*0.8,Y0+h*0.8, Math.max(2,Math.min(w,h)*0.09), 0, Math.PI*2); g2d.fill();
      g2d.beginPath(); g2d.fillStyle=`rgba(255,209,102,${onK?0.95:0.15})`; g2d.arc(centerX,centerY, Math.max(2,Math.min(w,h)*0.1), 0, Math.PI*2); g2d.fill();
    }

    // protocol links
    if(on(protoOverlay)){
      for(let t=0;t<NT;t++){
        if(reqNow[t]){
          const tx=t%TX, ty=(t/TX)|0;
          const dst=partner[t]; if(dst==null||dst<0) continue;
          const dx=dst%TX, dy=(dst/TX)|0;
          const x0=(tx*TILE+TILE/2)*scaleX, y0=(ty*TILE+TILE/2)*scaleY;
          const x1=(dx*TILE+TILE/2)*scaleX, y1=(dy*TILE+TILE/2)*scaleY;
          g2d.strokeStyle='rgba(110,231,255,0.9)'; g2d.beginPath(); g2d.moveTo(x0,y0); g2d.lineTo(x1,y1); g2d.stroke();
        }
        if(ackNow[t]){
          const tx=t%TX, ty=(t/TX)|0;
          const src=partner[t]; if(src==null||src<0) continue;
          const sx=src%TX, sy=(src/TX)|0;
          const x0=(sx*TILE+TILE/2)*scaleX, y0=(sy*TILE+TILE/2)*scaleY;
          const x1=(tx*TILE+TILE/2)*scaleX, y1=(ty*TILE+TILE/2)*scaleY;
          g2d.strokeStyle='rgba(255,214,102,0.9)'; g2d.beginPath(); g2d.moveTo(x0,y0); g2d.lineTo(x1,y1); g2d.stroke();
        }
      }
    }

    // Rays 2D overlay
    if(on(rayOverlay2D,true)){
      g2d.strokeStyle='rgba(110,231,255,0.9)'; g2d.lineWidth=1.5;
      for(const seg of ray2DPath){
        const [x0,y0,x1,y1,a]=seg;
        g2d.globalAlpha = Math.max(0,Math.min(1,a/2.0));
        g2d.beginPath(); g2d.moveTo(x0*scaleX,y0*scaleY); g2d.lineTo(x1*scaleX,y1*scaleY); g2d.stroke();
      }
      g2d.globalAlpha=1.0;
    }
  }

  // --- 3D draw ---
  function draw3D(){
    const w=c3d.width,h=c3d.height;
    g3d.clearRect(0,0,w,h); g3d.fillStyle='#0a0e13'; g3d.fillRect(0,0,w,h);
    g3d.strokeStyle='#1f2a36';
    g3d.beginPath(); g3d.moveTo(40,h-40); g3d.lineTo(w-40,h-40); g3d.stroke();
    g3d.beginPath(); g3d.moveTo(40,h-40); g3d.lineTo(40,40); g3d.stroke();

    const pct=numVal(samp,40)/100, count=(W*H*pct)|0;
    for(let n=0;n<count;n++){
      const i=(n*9973)%(W*H);
      const q=get(i,CH.Q), p=get(i,CH.P), s=get(i,CH.S);
      const [px,py]=proj3D(q*2-1,p*2-1,s*2-1,w,h,rotX,rotY);
      const r=get(i,CH.R)*255|0, g=get(i,CH.G)*255|0, b=get(i,CH.B)*255|0;
      g3d.fillStyle=`rgba(${r},${g},${b},0.65)`; g3d.fillRect(px,py,2,2);
    }

    if(on(graph3D,true)){
      // REQ/ACK + math trails (amber)
      if(on(graphTrails,true)){
        const ttl=numVal(trailSec,6);
        for(const e of trailEdges){
          const u=e.u, v=e.v;
          const ux=tilePos[u*3+0]*2-1, uy=tilePos[u*3+1]*2-1, uz=tilePos[u*3+2]*2-1;
          const vx=tilePos[v*3+0]*2-1, vy=tilePos[v*3+1]*2-1, vz=tilePos[v*3+2]*2-1;
          const [x0,y0]=proj3D(ux,uy,uz,w,h,rotX,rotY);
          const [x1,y1]=proj3D(vx,vy,vz,w,h,rotX,rotY);
          const a=Math.max(0,Math.min(1,e.life/ttl));
          g3d.strokeStyle=`rgba(255,214,102,${0.25+0.6*a})`;
          g3d.lineWidth=1.5;
          g3d.beginPath(); g3d.moveTo(x0,y0); g3d.lineTo(x1,y1); g3d.stroke();
        }
      }
      // Ray edges (magenta)
      if(on(rayOverlay3D,true)){
        for(const e of rayEdges){
          const u=e.u, v=e.v;
          const ux=tilePos[u*3+0]*2-1, uy=tilePos[u*3+1]*2-1, uz=tilePos[u*3+2]*2-1;
          const vx=tilePos[v*3+0]*2-1, vy=tilePos[v*3+1]*2-1, vz=tilePos[v*3+2]*2-1;
          const [x0,y0]=proj3D(ux,uy,uz,w,h,rotX,rotY);
          const [x1,y1]=proj3D(vx,vy,vz,w,h,rotX,rotY);
          const a=Math.max(0,Math.min(1,e.life/e.ttl));
          g3d.strokeStyle=`rgba(255,107,214,${0.20+0.65*a})`;
          g3d.lineWidth=1.7;
          g3d.beginPath(); g3d.moveTo(x0,y0); g3d.lineTo(x1,y1); g3d.stroke();
        }
      }
      // Flow hints
      if(on(graphFlow3D,true)){
        g3d.lineWidth=1;
        for(let t=0;t<NT;t++){
          const u=t, v=neighborOf(t,tileFlow[t]);
          const ux=tilePos[u*3+0]*2-1, uy=tilePos[u*3+1]*2-1, uz=tilePos[u*3+2]*2-1;
          const vx=tilePos[v*3+0]*2-1, vy=tilePos[v*3+1]*2-1, vz=tilePos[v*3+2]*2-1;
          const [x0,y0]=proj3D(ux,uy,uz,w,h,rotX,rotY);
          const [x1,y1]=proj3D(vx,vy,vz,w,h,rotX,rotY);
          g3d.strokeStyle='rgba(110,231,255,0.25)';
          g3d.beginPath(); g3d.moveTo(x0,y0); g3d.lineTo(lerp(x0,x1,0.35), lerp(y0,y1,0.35)); g3d.stroke();
        }
      }
      // Nodes
      const scale=numVal(nodeScale,1.6);
      for(let t=0;t<NT;t++){
        const x=tilePos[t*3+0]*2-1, y=tilePos[t*3+1]*2-1, z=tilePos[t*3+2]*2-1;
        const [px,py]=proj3D(x,y,z,w,h,rotX,rotY);
        const bb=bitBias[t]||0;
        const r=2 + 6*bb*scale;
        g3d.fillStyle=`rgba(126,252,138,${0.25+0.55*bb})`;
        g3d.beginPath(); g3d.arc(px,py,r,0,Math.PI*2); g3d.fill();
        if(tileSUM[t]){ g3d.strokeStyle='rgba(255,255,255,0.85)'; g3d.lineWidth=1.5; g3d.beginPath(); g3d.arc(px,py,r+1.2,0,Math.PI*2); g3d.stroke(); }
        if(tileCAR[t]){ g3d.strokeStyle='rgba(255,209,102,0.85)'; g3d.lineWidth=1.5; g3d.beginPath(); g3d.arc(px,py,Math.max(1,r-2),0,Math.PI*2); g3d.stroke(); }
      }
    }
    g3d.strokeStyle='#1c2530'; g3d.strokeRect(0,0,w,h);
  }

  // --- Tick & Loop ---
  function tick(){
    tickCount++;

    // Physics first (feeds semantics & scheduler)
    if(physEnabled){
      if(tickCount%1===0) ricciStep();           // every tick
      if(raysEnabled){
        if(tickCount - lastRaySpawnTick > 30){ spawnRays(); lastRaySpawnTick=tickCount; }
        stepRays();
      }
      physStatus.textContent = `u-residual≈${physResidualAvg.toFixed(3)} | rays ${rays.length}`;
    }

    // stochastic flips + Q2
    meaningfulFlips(numVal(pFlip,0.002), numVal(edgeBiasRange,1.5));
    if(on(q2Enable)){
      forEachPixel((x,y,i)=>{
        const a=prevRails[i], b=rails[i];
        if(a!==b){
          const axis = (orient[i]===1)?2 : (orient[i]===2)?3 : 4;
          q2EmitFlipEvent(x,y,a,b,axis);
        }
      });
      q2UpdatePreview();
    }

    buildRailField(Math.max(1, Math.min(12, numVal(rad,5))));
    scheduleTiles();

    // tiers
    nnm1_gate(); nnm2_pixelDrift(); nnm3_tileMix(); keepEnergy(); nnm4_domain();

    // math (overrides before logic evaluation)
    clearOverrides();
    mathTick();

    if(on(logicEnable)) evalLogicTierAware();

    protoStep();

    decayTrails(dtMs/1000);

    draw2D(); draw3D();
  }

  function loop(t){
    if(running){
      const dt=t-lastT; lastT=t; dtMs=dt; accum+=dt; frames++;
      tick();
      if(accum>500){ fps=Math.round(frames*1000/accum); accum=0; frames=0; }
      fpsLabel.textContent=fps; flipsLabel.textContent=flipsLast; eventsLabel.textContent=eventsLast;
      if(on(autorot)){ rotY+=0.004; }
    } else {
      lastT=t;
    }
    requestAnimationFrame(loop);
  }

  // --- UI wiring ---
  function refreshLabels(){
    pFlipVal.textContent=(numVal(pFlip)).toFixed(4);
    edgeBiasVal.textContent=(numVal(edgeBiasRange)).toFixed(1);
    radVal.textContent=numVal(rad).toString();
    sampVal.textContent=numVal(samp)+'%';
    thrVal.textContent=(numVal(thr)).toFixed(2);
    q2CapVal.textContent=numVal(q2Cap)+' KB';
    admitVal.textContent=(numVal(admitPct))+'%';
    protoStartVal.textContent=(numVal(protoStart)).toFixed(3);
    ctauVal.textContent='±'+numVal(ctauSpread).toFixed(2);
    faultVal.textContent=numVal(faultPct)+'%';
    if (gateCovVal && gateCov) gateCovVal.textContent=numVal(gateCov)+'%';
    trailVal.textContent=numVal(trailSec)+'s';
    nodeVal.textContent='×'+numVal(nodeScale).toFixed(1);
    alphaVal.textContent=numVal(alpha).toFixed(3);
    lambdaVal.textContent=numVal(lambdaR).toFixed(3);
    rayCountVal.textContent=numVal(rayCount).toString();
    rayStepVal.textContent=numVal(rayStep).toFixed(1);
    rayMaxVal.textContent=numVal(rayMax).toString();
  }
  pFlip.oninput = refreshLabels;
  edgeBiasRange.oninput = refreshLabels;
  rad.oninput = refreshLabels;
  samp.oninput = refreshLabels;
  thr.oninput = refreshLabels;
  q2Cap.oninput = ()=>{ q2CapBytes=numVal(q2Cap)*1024; refreshLabels(); q2UpdatePreview(); };
  admitPct.oninput = ()=>{ admitFrac = numVal(admitPct)/100; refreshLabels(); };
  wPreset.oninput = ()=>{ FW={...(PRESETS[wPreset.value]||PRESETS.balanced)}; };
  ctauSpread.oninput = ()=>{ cTauSpread=numVal(ctauSpread); refreshLabels(); };
  ctauReseed.onclick = ()=>{ reseedCTau(); draw2D(); };
  if (gateCov) gateCov.oninput = ()=>{ if(gateCovVal) gateCovVal.textContent=numVal(gateCov)+'%'; reseedGates(); draw2D(); };
  trailSec.oninput=refreshLabels;
  nodeScale.oninput=refreshLabels;

  q2Reset.onclick = ()=>{ q2Tokens=[]; q2UpdatePreview(); };
  q2Copy.onclick = ()=>{ const s=q2CodonString(); navigator.clipboard?.writeText(s); q2Preview.textContent='(codons copied to clipboard)'; };

  btnToggle.onclick=()=>{ running=!running; btnToggle.textContent=running?'⏸ Pause':'▶ Start'; statePill.textContent=running?'running':'paused'; statePill.style.color=running?'var(--ok)':'#b6c1cc'; };
  btnStep.onclick=()=>{ const was=running; running=false; tick(); if(was) running=true; };
  btnReset.onclick=()=>{ reseedAll(); draw2D(); draw3D(); };

  const gateReseedBtn=el('gateReseed'); if(gateReseedBtn) gateReseedBtn.onclick=()=>{ reseedGates(); draw2D(); };

  // Math UI
  mathEnable.oninput = ()=>{ mathEnabled=mathEnable.checked; };
  mathProblemSel.oninput = ()=>{ mathProblem=mathProblemSel.value; };
  mathLoad.onclick = ()=>{ mathLoadRegs(); };
  mathRun.onclick = ()=>{ mathLoadRegs(); mathStart(); };

  // Physics UI
  physEnable.oninput = ()=>{ physEnabled=physEnable.checked; };
  physSrc.oninput = ()=>{ buildKtgt(); };
  alpha.oninput = ()=>{ alphaStep=numVal(alpha,0.02); refreshLabels(); };
  lambdaR.oninput = ()=>{ lambdaSmooth=numVal(lambdaR,0.03); refreshLabels(); };
  uOverlay.oninput = ()=>{ /* just toggle drawing */ };

  // Rays UI
  rayEnable.oninput = ()=>{ raysEnabled=rayEnable.checked; };
  rayCount.oninput = ()=>{ raysPerBurst=numVal(rayCount,24); refreshLabels(); };
  rayStep.oninput = ()=>{ rayStepPx=numVal(rayStep,0.8); refreshLabels(); };
  rayMax.oninput = ()=>{ rayMaxSteps=numVal(rayMax,260); refreshLabels(); };
  rayOverlay2D.oninput = ()=>{};
  rayOverlay3D.oninput = ()=>{};

  // 3D controls
  c3d.addEventListener('mousedown',e=>{dragging=true; lastMouse=[e.clientX,e.clientY];});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging) return; const dx=e.clientX-lastMouse[0], dy=e.clientY-lastMouse[1]; lastMouse=[e.clientX,e.clientY]; rotY+=dx*0.005; rotX+=dy*0.005;
  });

  // --- Boot / reseed ---
  function reseedAll(){
    if(on(meaning,true)) buildMeaningful(); else buildRandom();
    smoothSemantic(1);
    prevRails = new Uint8Array(rails);
    reseedGates();
    reseedCTau();
    buildKtgt();
    initU();
    computeBitBias();
    scheduleTiles();
    tickCount=0; hsTotal=0; reqEdges=0; ackEdges=0;
    q2Tokens=[]; q2UpdatePreview();
    trailEdges.length=0; rayEdges.length=0; ray2DPath.length=0; rays.length=0;
    clearOverrides();
    mathEnabled=mathEnable.checked;
    mathProblem=mathProblemSel.value;
    mathLoadRegs();
  }

  // initial labels + run
  refreshLabels();
  reseedAll();
  draw2D(); draw3D();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
