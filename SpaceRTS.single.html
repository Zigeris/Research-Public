<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mini Space RTS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0c0f14; --fg:#e7edf5; --mut:#9aa0a6; --panel:#11161c;
      --accent:#6ee7ff; --ok:#7efc8a; --warn:#ffd166; --mag:#ff6bd6; --bad:#ff6b6b;
      --sky-grad-start:#061d43; --sky-grad-mid:#172551; --sky-grad-end:#240046;
      --star-core-color:#7dd3fc; --star-edge-color:#a78bfa;
    }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .wrap{display:grid;grid-template-columns:420px 1fr;gap:14px;height:100%}
    .left{background:var(--panel);padding:14px;border-right:1px solid #1c2530;overflow:auto}
    .right{padding:10px}
    h1{font-size:16px;margin:0 0 8px}
    h2{font-size:13px;margin:16px 0 6px;color:var(--mut);text-transform:uppercase;letter-spacing:.06em}
    input[type=text],textarea{width:100%;padding:8px 10px;background:#0f151b;border:1px solid #253241;color:var(--fg);border-radius:8px;box-sizing:border-box}
    select,button,input[type=range]{width:100%}
    select{padding:8px 10px;background:#0f151b;border:1px solid #253241;color:var(--fg);border-radius:8px}
    button{padding:8px 10px;margin:6px 0;background:#17212b;border:1px solid #253241;color:var(--fg);border-radius:8px;cursor:pointer}
    button:hover{border-color:#39526d}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .pill{display:inline-block;padding:2px 6px;border:1px solid #2b3a4b;border-radius:999px;background:#0c1218;color:#b6c1cc;margin-left:8px}
    .kvs{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;align-items:center}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .small{font-size:12px}
    .legend{font-size:12px;color:#b6c1cc}
    .hr{height:1px;background:#1c2530;margin:10px 0}
    .canvwrap{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:10px;box-sizing:border-box}
    .canvwrap.single{grid-template-columns:1fr}
    canvas{background:#0a0e13;border:1px solid #1a2430;border-radius:10px;image-rendering:pixelated;display:block}
    label.inline{display:flex;align-items:center;gap:6px}
    .tag{font-size:11px;color:#b6c1cc}
    .victory{padding:10px;border:1px solid #2b3a4b;border-radius:8px;background:#0f151b}
    .victory h3{margin:10px 0 4px;font-size:13px;color:#cfe5ff}
    .victory pre{white-space:pre-wrap;margin:0}
    .sel{padding:8px;border:1px solid #2b3a4b;border-radius:8px;background:#0f151b}
    /* Popup unit card */
    .card{position:fixed;min-width:260px;max-width:340px;background:#0f151b;border:1px solid #2b3a4b;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.4);padding:10px;z-index:9999;display:none}
    .card h3{margin:0 0 6px;font-size:14px;color:#cfe5ff}
    .card .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 8px;font-size:12px}
    .card .bar{height:6px;background:#0b0f14;border:1px solid #253241;border-radius:6px;overflow:hidden}
    .card .bar>i{display:block;height:100%;background:linear-gradient(90deg,#7efc8a,#6ee7ff)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <h1>Mini Space RTS</h1>
      <div class="kvs">
        <div>World</div><div class="mono" id="worldSz">-</div>
        <div>FPS</div><div class="mono" id="fps">-</div>
        <div>Sim speed</div><div class="mono" id="speedLbl">1.00x</div>
        <div>Objects</div><div class="mono" id="objCount">-</div>
      </div>

      <h2>Run</h2>
      <div class="row"><button id="btnToggle">â–¶ Start</button><span class="pill" id="state">paused</span></div>
      <div class="row"><button id="btnStep">Step (1 tick)</button><span class="pill">fixed dt</span></div>
      <div class="row"><button id="btnReset">Reset / Reseed</button><span class="pill">fresh world</span></div>

      <h2>Game</h2>
      <div class="row"><label>Speed</label><input type="range" id="speed" min="0.5" max="2" step="0.05" value="1"></div>
      <div class="row"><label>Zoom</label><input type="range" id="zoom" min="0.5" max="10" step="0.1" value="1"></div>
      <div class="row"><button id="fitMap">Fit Map</button><span class="pill">reset zoom</span></div>
      <div class="row"><button id="resetSky">Reset Skybox</button><span class="pill">reset sky</span></div>
      <label class="inline small"><input type="checkbox" id="showTeams" checked> Show team links</label>
      <label class="inline small"><input type="checkbox" id="showRanges"> Show weapon ranges</label>
      <label class="inline small"><input type="checkbox" id="showRadar"> Show radar LOS</label>
      <label class="inline small"><input type="checkbox" id="showEW" checked> Show EW/Jam bubbles</label>
      <label class="inline small"><input type="checkbox" id="showEco" checked> Show economy overlay</label>
      <label class="inline small"><input type="checkbox" id="fog" checked> Fog-of-war (radar)</label>
      <label class="inline small"><input type="checkbox" id="showSpecs"> Show specs</label>

      <div class="hr"></div>
      <h2>BNP Bridge</h2>
      <label class="inline small"><input type="checkbox" id="bnpEnable"> Enable BNP bridge</label>
      <label class="inline small"><input type="checkbox" id="bnpAutoDraw" checked> Auto‑draw BNP 2D</label>
      <div class="kvs small">
        <div>Status</div><div class="mono" id="bnpStatus">detached</div>
      </div>

      <h2>Config</h2>
      <textarea id="cfgText" rows="14" class="mono small"></textarea>
      <div class="row"><button id="applyCfg">Apply Config</button><span class="tag">live-safe</span></div>

      <h2>Victory</h2>
      <div id="victory" class="victory">-</div>

      <h2>Selected</h2>
      <div id="sel" class="sel">-</div>

      <h2>KPIs</h2>
      <div class="kvs">
        <div>Red Ore/Fuel</div><div class="mono" id="rOf">-</div>
        <div>Blue Ore/Fuel</div><div class="mono" id="bOf">-</div>
        <div>Red Store</div><div class="mono" id="rStore">-</div>
        <div>Blue Store</div><div class="mono" id="bStore">-</div>
        <div>Postures</div><div class="mono" id="postures">-</div>
        <div>Missions</div><div class="mono" id="missions">-</div>
        <div>Hangars</div><div class="mono" id="hangars">-</div>
        <div>Units Red</div><div class="mono" id="unitRed">-</div>
        <div>Units Blue</div><div class="mono" id="unitBlu">-</div>
        <div>Avg Fuel Range (Red)</div><div class="mono" id="rangeRed">0</div>
        <div>Avg Fuel Range (Blue)</div><div class="mono" id="rangeBlu">0</div>
        <div>Radar Share (Red)</div><div class="mono" id="radarShareRed">0</div>
        <div>Radar Share (Blue)</div><div class="mono" id="radarShareBlu">0</div>
        <div>Target Comp (Red)</div><div class="mono" id="tcompRed">0</div>
        <div>Target Comp (Blue)</div><div class="mono" id="tcompBlu">0</div>
      </div>
    </div>

    <div class="right">
      <div class="row"><button id="viewToggle">Switch to 3D</button><span class="tag">toggle view</span></div>
      <div class="canvwrap">
        <div id="view2D"><canvas id="c2d" width="1024" height="1024"></canvas></div>
        <div id="view3D" style="display:none"><canvas id="c3d" width="1024" height="1024"></canvas></div>
      </div>
    </div>
  </div>

  <!-- Popup unit card -->
  <div id="unitCard" class="card" role="dialog" aria-live="polite">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
      <h3 id="cardTitle" style="margin:0">Unit</h3>
      <button id="cardClose" class="small" style="min-width:auto;width:auto">Close</button>
    </div>
    <div class="kv">
      <div>Type</div><div id="cardType">-</div>
      <div>Faction</div><div id="cardFac">-</div>
      <div>Mode</div><div id="cardMode">-</div>
      <div>HP</div><div><div class="bar"><i id="cardHP" style="width:0%"></i></div></div>
      <div>Fuel</div><div><div class="bar"><i id="cardFuel" style="width:0%"></i></div></div>
      <div>Tank</div><div id="cardTank">-</div>
      <div>Weapons</div><div><ul id="cardWeapons" class="mono" style="margin:4px 0 0 0;padding-left:16px"></ul></div>
      <div>Sig</div><div id="cardSig">-</div>
      <div>Jam</div><div id="cardJam">-</div>
      <div>TC</div><div id="cardTC">-</div>
      <div>Mission</div><div id="cardMission">-</div>
      <div>Teamed</div><div id="cardTeam">-</div>
      <div>XP</div><div id="cardXP">-</div>
      <div>Assist</div><div id="cardAssist">-</div>
      <div>Status</div><div id="cardStatus">-</div>
    </div>
  </div>

  <script id="bundle" type="application/text">
(function(){
// Increase baseline ranges and world scale so gameplay spaces feel larger
const HEAVY_RANGE = 25; // km baseline for Heavy unit engagement/radar
const KM_TO_WORLD = 1024 / 1000; // world units per km (was 1024/25000)
const weaponCap = 10000;
const ammoCap = 200000;
const componentCap = 10000;

const defaultConfig = {
  components: {
    power: {
      Gen1: { kw: 65 },
      Gen2: { kw: 88 }
    },
    radar: {
      RAD1: { km: 4 },
      RAD5: { km: 15 },
      EWAC: { km: 8 }
    }
  },
  world: { size: 1024, hardReveal:12, startSeed: 987654 },
  resources: {
    clusters:[6,9], perCluster:[10,25],
    oreNode:{ cap:[800,1500], shareRate:7 },
    fuelNode:{ cap:[225,425], shareRate:2.25 }
  },
  economy: {
    ratios: { fuelToOreTarget: 1.4, fuelReserve: 105 },
    costs: {
      Constructor:{ ore:100, fuel:8, buildTime:6 },
      EW:{ ore:540, fuel:80, buildTime:7 },
      Light:{ ore:170, fuel:25, buildTime:6 },
      Heavy:{ ore:380, fuel:60, buildTime:10 },
      WeaponPlatform:{ ore:325, fuel:40, buildTime:8 },
      CollectorOutpost:{ ore:325, fuel:32.5, buildTime:8 },
      WeaponOutpost:{
        hp:10000, arm:0.30, powerKw:88, radar:15, batterySlots:8,
        storage:{ ore:600, fuel:150 }, weapons:["HeavyRail","SMG"]
      },
      ResourceOutpost:{ ore:325, fuel:32.5, buildTime:8 }
    },
    componentCosts: {
      powerSlot: { ore: 0, fuel: 0 },
      radarSlot: { ore: 0, fuel: 0 }
    },
    repair: {
      Light:{ hpPerSec:6, orePerHp:0.04 },
      Heavy:{ hpPerSec:4, orePerHp:0.04 }
    },
    buildUp:{ minConstructors:4, minCombat:6, minFuel:80, minOre:220 },
    logistics: { refuelRatePerSec:37.5, depositOrePerSec:240, depositFuelPerSec:60, minStorageReserve:60 }
  },
  docks: { mother:4, outpost:2, platform:2, callRange:2 },
  hangars: { mother:8, outpost:4 },
  units: {
    Mother:{ hp:20000, arm:0.40, spd:20, strafe:8, acc:5, tank:500, upkeep:0.175,
             generator:'Gen2', radarModel:'RAD5',
             batterySlots:16, storage:{ ore:4000, fuel:1000 }, weapons:["HeavyRail","HeavyRail","HeavyRail","HeavyRail"] },
    Constructor:{ hp:200, arm:0.10, spd:35, strafe:20, acc:8, tank:81.25, upkeep:0.07,
                  generator:'Gen1',
                  batterySlots:1, mine:{ oreRate:3.0, fuelRate:0.725 }, fuelCargoFactor:4 },
    EW:{ hp:110, arm:0.10, spd:38, strafe:28, acc:9, tank:180, upkeep:0.095,
         generator:'Gen2', radarModel:'EWAC',
         weaponRecharge:65, batterySlots:2, jammer:{ radius:12, strength:0.8, fuelPerSec:0.25 },
         weaponOptions:["SMG"] },
    Light:{ hp:100, arm:0.15, spd:45, strafe:40, acc:10, tank:205, upkeep:0.0925,
            generator:'Gen1', radarModel:'RAD1',
            batterySlots:2, weaponOptions:["SMG","BeamRifle"] },
    Heavy:{ hp:180, arm:0.30, spd:32, strafe:28, acc:8, tank:287.5, upkeep:0.12, radar:HEAVY_RANGE,
            generator:'Gen2',
            batterySlots:3, weapons:["HeavyRail"] }
  },
  buildings: {
    CollectorOutpost:{ hp:1500, arm:0.25, generator:'Gen1', storage:{ ore:1600, fuel:400 } },
    WeaponPlatform:{ hp:1600, arm:0.30, generator:'Gen2', radarModel:'RAD5', storage:{ ore:600, fuel:150 }, weapons:["HeavyRail"] },
    ResourceOutpost:{ hp:5000, arm:0.25, generator:'Gen1', radarModel:'RAD5', storage:{ ore:1600, fuel:400 } },
    WeaponOutpost:{
      hp:10000, arm:0.30, generator:'Gen2', radarModel:'RAD5', batterySlots:8,
      storage:{ ore:600, fuel:150 }, weapons:["HeavyRail","SMG"]
    }
  },
  weapons: {
    SMG:{ type:"projectile", range:20, rof:5.0, dmg:8, projSpeed:80, spread:3,
          targetComputer:{tracking:30, lead:1.0}, energy:false,
          ammo:{mag:30, max:2}, reload:{time:1.5, ore:5} },
    BeamRifle:{ type:"beam", range:35, rof:1.0, dmg:90, windup:0.1, spread:0, energy:true,
                ammo:{battery:10, max:2}, reload:{time:2.0, fuel:28} },
    HeavyRail:{ type:"projectile", range:HEAVY_RANGE, rof:0.5, dmg:240, projSpeed:70, spread:1,
                targetComputer:{tracking:25, lead:1.2}, energy:false,
                ammo:{mag:5, max:3}, reload:{time:3.0, ore:100} }
  },
  sensors: { baseUpkeep:0.015 },
  signature: { base:0.5, k:0.005, fuelK:0.02, weaponBoost:0.5 },
  flight: {
    damping: 0.995,
    arriveRadius: 7,
    formationGap: 2.2,
    planCooldown: 6,
    deadZone: { dist: 1.5, vel: 0.05 },
    dev: { vel: 0.5, rot: 0.1, xp: 0.3, over: 2 },
    modes: { coupled:{ spdMul:0.90, turnScale:1.00, lateralKill:1.0, baseFuelPerSec:0.0075 },
             decoupled:{ spdMul:1.08, turnScaleMin:0.55, lateralKill:0.0, baseFuelPerSec:0.00 } }
  },
  fuelUse: {
    coupled:   { movePerUnit:0.006, accelCost:0.00175, basePerSec:0.0075 },
    decoupled: { movePerUnit:0.00075, accelCost:0.001, basePerSec:0.000 },
    radarPerSec: 0.015
  },
  dodge: { base:0.02, kXP:0.004, kSpeed:0.05, kAccel:0.05, pMax:0.55, jinkAccel:24, jinkTime:0.22, fuelPulse:0.4, xpMax:100 },
  thresholds: { lowFuelUnit:0.30, veryLowFuelUnit:0.15, lowFuelTeamAvg:0.40, retreatHP:0.25 },
  ai: {
    posture: { thetaAM_low:0.85, thetaAM_exec:1.15, thetaFP_equalize:0.95, thetaFP_execute:1.10 },
    defendRadius: 24, siegeMinHeavies: 1, sadMinLights: 1, harassNeedEW: true
  },
  motherAI: { holdRadius: 9, reanchorEvery: 18, avoidEnemyDist: 22, cruiseSpeedMul: 0.35, fleeSpeedMul: 0.6 }
};

/**
 * Deeply merge two plain objects.
 * @param {Object} target Destination object.
 * @param {Object} source Source object.
 * @returns {Object} The merged object.
 */
function deepMerge(target, source){
  for(const [k,v] of Object.entries(source)){
    if(v && typeof v === 'object' && !Array.isArray(v)){
      if(!target[k]) target[k] = {};
      deepMerge(target[k], v);
    } else {
      target[k] = v;
    }
  }
  return target;
}

/**
 * Create a deep clone via JSON serialization.
 * @param {Object} obj Object to clone.
 * @returns {Object}
 */
function clone(obj){
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Apply world scaling to configuration values.
 * @param {Object} cfg Configuration to mutate.
 * @returns {void}
 */
function applyWorldScale(cfg){
  const s = KM_TO_WORLD;
  cfg.world.hardReveal *= s;
  for(const [name,u] of Object.entries(cfg.units)){
    if(u.radar && name !== 'Mother') u.radar *= s;
    if(u.jammer) u.jammer.radius *= s;
  }
  for(const b of Object.values(cfg.buildings)){
    if(b.radar) b.radar *= s;
  }
  for(const w of Object.values(cfg.weapons)){
    w.range *= s;
  }
}

// Fill numeric power/radar from component models (generator/radarModel)
function applyComponentModels(cfg){
  const gens = (cfg.components && cfg.components.power) || {};
  const rads = (cfg.components && cfg.components.radar) || {};
  // Units
  for(const [name,u] of Object.entries(cfg.units)){
    if(u.generator && gens[u.generator] && typeof gens[u.generator].kw === 'number'){
      u.powerKw = gens[u.generator].kw;
    }
    if(u.radarModel && rads[u.radarModel] && typeof rads[u.radarModel].km === 'number'){
      const km = rads[u.radarModel].km;
      u.radar = (name === 'Mother') ? km * KM_TO_WORLD : km;
    }
  }
  // Buildings
  for(const b of Object.values(cfg.buildings)){
    if(b.generator && gens[b.generator] && typeof gens[b.generator].kw === 'number'){
      b.powerKw = gens[b.generator].kw;
    }
    if(b.radarModel && rads[b.radarModel] && typeof rads[b.radarModel].km === 'number'){
      b.radar = rads[b.radarModel].km;
    }
  }
}

/**
 * Ensure weapon configuration objects contain expected fields.
 * @param {Object} cfg Configuration to mutate.
 * @returns {void}
 */
function normalizeWeapons(cfg){
  for(const w of Object.values(cfg.weapons)){
    if(!w.ammo) w.ammo = {max:0};
    if(w.energy === undefined) w.energy = false;
  }
}

/**
 * Load the game configuration merging any overrides.
 * @param {Object} [overrides={}] Partial configuration overrides.
 * @returns {Object} Normalized configuration object.
 */
function loadConfig(overrides={}){
  const cfg = clone(defaultConfig);
  deepMerge(cfg, overrides);
  applyComponentModels(cfg);
  applyWorldScale(cfg);
  normalizeWeapons(cfg);
  return cfg;
}

/**
 * Estimate radar signature from power output and other factors.
 * @param {Object} cfg Game configuration.
 * @param {number} powerKw Power output in kilowatts.
 * @param {Object} [opts]
 * @param {number} [opts.fuelUse]
 * @param {number} [opts.weaponFire]
 * @param {number} [opts.generatorTier]
 * @returns {number} Signature value.
 */
function sigFromPower(cfg, powerKw, opts={}){
  const S = cfg.signature || {base:0, k:1};
  let k = S.k;
  const tier = opts.generatorTier ?? (powerKw > 250 ? 3 : powerKw > 100 ? 2 : 1);
  if(tier >= 3) k *= 1.2;
  else if(tier === 2) k *= 1.1;
  let sig = S.base + k * powerKw;
  if(opts.fuelUse) sig += (S.fuelK || 0) * opts.fuelUse;
  if(opts.weaponFire) sig += S.weaponBoost || 0;
  return sig;
}
/**
 * Convert a world-space radius to a scaled 2D canvas size.
 * @param {number} value Radius in world units.
 * @param {number} canvasWidth Canvas width in pixels.
 * @param {number} zoom Current zoom level.
 * @param {number} worldSize Total world size in units.
 * @returns {number} Radius in pixels.
 */
function scaleRadius(value, canvasWidth, zoom, worldSize){
  if (!worldSize || worldSize <= 0) {
    return 0;
  }
  return value / worldSize * canvasWidth * zoom;
}

// Specific 2D range helpers (radarRadius2D, weaponRadius2D, fuelRadius2D)
// have been replaced by this generic scaleRadius helper.

/**
 * Convert world-space depth to a scaled value for 3D overlay.
 * @param {number} value Depth in world units.
 * @param {number} fov Field of view.
 * @param {number} depth Camera depth.
 * @returns {number}
 */
function scaleDepth(value, fov, depth){
  if (!depth || depth <= 0) {
    return 0;
  }
  return value * fov / depth;
}

// Specific 3D range helpers (radarRadius3D, weaponRadius3D, fuelRadius3D)
// have been replaced by this generic scaleDepth helper.

const overlayMath = {
  scaleRadius,
  scaleDepth
};
/**
 * Clamp a value between two bounds.
 * @param {number} v Value.
 * @param {number} lo Lower bound.
 * @param {number} hi Upper bound.
 * @returns {number}
 */
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

/** Collection of basic 3D vector operations. */
const V = {
  /** @param {number[]} a
   * @param {number[]} b
   * @returns {number[]} Sum of vectors.
   */
  add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]],
  /** @param {number[]} a
   * @param {number[]} b
   * @returns {number[]} Difference of vectors.
   */
  sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]],
  /** @param {number[]} a
   * @param {number} k
   * @returns {number[]} Scaled vector.
   */
  mul: (a, k) => [a[0] * k, a[1] * k, a[2] * k],
  /** @param {number[]} a
   * @returns {number} Vector length.
   */
  len: (a) => Math.hypot(a[0], a[1], a[2]),
  /** @param {number[]} a
   * @returns {number[]} Normalised vector.
   */
  norm: (a) => {
    const L = V.len(a) || 1;
    return [a[0] / L, a[1] / L, a[2] / L];
  },
  /** @param {number[]} a
   * @param {number[]} b
   * @returns {number} Dot product.
   */
  dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
  /** @param {number[]} a
   * @param {number[]} b
   * @returns {number[]} Cross product.
   */
  cross: (a, b) => [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ]
};

const { dot, cross, len, mul, add, norm } = V;

/**
 * Clamp a direction vector to lie within an arc relative to a forward vector.
 * @param {number[]} fwd Forward unit vector.
 * @param {number[]} dir Desired direction vector.
 * @param {number} arcCos Cosine of half the arc angle.
 * @returns {number[]} Normalised direction within the arc.
 */
function clampDirToArc(fwd, dir, arcCos){
  const aimCos = dot(fwd, dir);
  if(aimCos >= arcCos) return dir;
  const axisRaw = cross(fwd, dir);
  const axLen = len(axisRaw);
  if(axLen < 1e-6) return fwd;
  const axis = mul(axisRaw, 1/axLen);
  const axf = cross(axis, fwd);
  const sinArc = Math.sqrt(Math.max(0,1-arcCos*arcCos));
  return norm(add(mul(fwd, arcCos), mul(axf, sinArc)));
}

const factionIntel = new Map();
// Duration in seconds before a last-known location entry expires.
// Once the timestamp difference exceeds this value, the stale record is removed.
const LNL_TTL = 60;

/**
 * Euclidean distance between two 3D points.
 * @param {number[]} a First point `[x,y,z]`.
 * @param {number[]} b Second point `[x,y,z]`.
 * @returns {number} Distance.
 */
function dist(a, b) {
  return Math.hypot(a[0] - b[0], a[1] - b[1], a[2] - b[2]);
}
const calcDist = dist;
class EventEmitter {
  constructor(){
    this.listeners = new Map();
  }
  on(type, fn){
    if(!this.listeners.has(type)) this.listeners.set(type, new Set());
    this.listeners.get(type).add(fn);
    return () => this.off(type, fn);
  }
  off(type, fn){
    const set = this.listeners.get(type);
    if(set){
      set.delete(fn);
      if(set.size === 0) this.listeners.delete(type);
    }
  }
  emit(type, data){
    const set = this.listeners.get(type);
    if(!set) return;
    for(const fn of [...set]){
      try{ fn(data); }catch(err){ console.error(err); }
    }
  }
}

const events = new EventEmitter();

/* ============================ COMBAT DEBUG LOGGER ============================ */
// Lightweight, always-available combat logger. Writes to console and buffers
// recent entries for inspection via window.COMBAT_LOG.
const COMBAT_LOG = {
  enabled: true,
  max: 500,
  entries: [],
  push(e){
    try{
      e.time = (typeof tickCount==='number'? (tickCount/60) : performance.now()/1000);
      this.entries.push(e);
      if(this.entries.length > this.max) this.entries.shift();
      if(this.enabled && console && console.info) console.info('[COMBAT]', e);
    }catch(_err){}
  }
};
try{ window.COMBAT_LOG = COMBAT_LOG; }catch(_e){}


class GameState {
  constructor(){
    this.world = {};
    this.entities = [];
    this.factions = [];
    this.teams = [];
    this.resources = [];
  }
  addEntity(e){
    this.entities.push(e);
    events.emit('entity-added', e);
    return e;
  }
  removeEntity(e){
    const idx = this.entities.indexOf(e);
    if(idx >= 0){
      this.entities.splice(idx,1);
      events.emit('entity-removed', e);
    }
  }
  addFaction(f){
    this.factions.push(f);
    events.emit('faction-added', f);
    return f;
  }
  removeFaction(f){
    const idx = this.factions.indexOf(f);
    if(idx >= 0){
      this.factions.splice(idx,1);
      events.emit('faction-removed', f);
    }
  }
  addTeam(t){
    this.teams.push(t);
    events.emit('team-added', t);
    return t;
  }
  removeTeam(t){
    const idx = this.teams.indexOf(t);
    if(idx >= 0){
      this.teams.splice(idx,1);
      events.emit('team-removed', t);
    }
  }
  addResource(r){
    this.resources.push(r);
    events.emit('resource-added', r);
    return r;
  }
  removeResource(r){
    const idx = this.resources.indexOf(r);
    if(idx >= 0){
      this.resources.splice(idx,1);
      events.emit('resource-removed', r);
    }
  }
}

GameState = GameState;

const gameState = new GameState();

const { world, entities, factions, teams, resources } = gameState;

/**
 * Ensure intel storage for a faction exists.
 * @param {number} fid Faction id.
 * @returns {{current:Map<number,any>, lastKnown:Map<number,any>}}
 */
function ensureFaction(fid){
  if(!factionIntel.has(fid)){
    factionIntel.set(fid, {current:new Map(), lastKnown:new Map()});
  }
  return factionIntel.get(fid);
}
// Backward-compat alias for consumers expecting _ensureFaction
const _ensureFaction = ensureFaction;

function isVec3(p){
  return Array.isArray(p) && p.length === 3;
}

/**
 * Update visibility information for a single observer.
 * Entities lacking a valid `pos` array (`[x,y,z]`) are skipped and logged.
 * If the observer's position is invalid the update is aborted.
 * @param {Object} observer Entity with faction, id, pos, sight range.
 * @param {Array<Object>} entities All entities in the world.
 * @param {number} now Current timestamp (seconds).
 * @param {Object|null} tm Team info with `sharedRadar` (optional).
 * @param {(msg:Object)=>void|null} send Optional comms broadcast function.
 * @returns {void}
 */
function updateVisibility(observer, entities = gameState.entities, now=0, tm=null, send=null){
  if(typeof observer.id !== 'number'){
    console.warn('updateVisibility: observer has invalid id', observer);
    return;
  }
  if(typeof observer.faction !== 'number'){
    console.warn('updateVisibility: observer has invalid faction', observer);
    return;
  }
  if(!isVec3(observer.pos)){
    console.warn('updateVisibility: observer has invalid pos', observer);
    return;
  }
  if (!Array.isArray(entities)) {
    console.warn('updateVisibility: entities is not an array');
    return;
  }
  const finfo = ensureFaction(observer.faction);
  const radarR = tm && tm.sharedRadar ? tm.sharedRadar : (observer.radarShared||0);
  const range = Math.max(observer.sight || 0, radarR);

  // Drop stale last-known entries
  for(const [id, info] of finfo.lastKnown){
    if(now - info.t > LNL_TTL){
      finfo.lastKnown.delete(id);
    }
  }

  // Promote outdated current entries to lastKnown and broadcast
  for(const [id, info] of [...finfo.current]){
    if(info.t < now){
      finfo.current.delete(id);
      const ent = info.ent;
      if(ent && isVec3(ent.pos)){
        const pos=[...ent.pos];
        finfo.lastKnown.set(id, {pos, t:now});
        if(typeof send === 'function'){
          send({type:'LKL', faction:observer.faction, targetId:id, pos, t:now});
        }
      }else{
        console.warn('updateVisibility: cannot record last known for invalid pos', ent);
      }
    }
  }

  for(const e of entities){
    if(typeof e.id !== 'number'){
      console.warn('updateVisibility: skipping entity with invalid id', e);
      continue;
    }
    if(e.id===observer.id || e.faction===observer.faction) continue;
    if(!isVec3(e.pos)){
      console.warn('updateVisibility: skipping entity with invalid pos', e);
      continue;
    }
    if(calcDist(observer.pos, e.pos) <= range){
      finfo.current.set(e.id, {ent:e, t:now});
      finfo.lastKnown.delete(e.id);
    }
  }
  events.emit('intel-updated', { observer, now });
}

/**
 * Get last known info for an enemy entity.
 * @param {number} faction Faction id requesting intel.
 * @param {number} entityId Target entity id.
 * @returns {{pos:number[], t:number}|null}
 */
function getLastKnown(faction, entityId){
  const finfo = factionIntel.get(faction);
  if(!finfo) return null;
  return finfo.lastKnown.get(entityId) || null;
}

/**
 * Purge intel of destroyed entity across all factions.
 * @param {number} entityId Id to purge.
 * @returns {void}
 */
function purgeEntity(entityId){
  for(const finfo of factionIntel.values()){
    finfo.current.delete(entityId);
    finfo.lastKnown.delete(entityId);
  }
}

const intelApi = {
  updateVisibility,
  getLastKnown,
  purgeEntity,
  LNL_TTL,
  _ensureFaction: ensureFaction,
  _store: factionIntel,
};

/**
 * Build info panel data for a unit.
 * @param {Object} unit Unit instance with radar and weapons.
 * @param {Object} opts Rendering options.
 * @param {number} opts.canvasWidth Width of canvas for 2D scaling.
 * @param {number} opts.zoom Current zoom level.
 * @param {number} opts.worldSize Size of the world in game units.
 * @returns {Object} info panel data.
 */
function formatUnitInfo(unit, opts={}, cfg){
  if (!unit || typeof unit !== 'object'){
    return { radar:0, fuelRange:0, radarShare:false, radarShareCount:0, hasTargetComputer:false, targetComputerCount:0, xpThrottle:0, xpCtrl:0, signature:0, weapons:[] };
  }
  const { canvasWidth=1, zoom=1, worldSize=1 } = opts;
  const radar = unit.radar ? scaleRadius(unit.radar, canvasWidth, zoom, worldSize) : 0;
  const fuelRange = unit.fuelRange ? scaleRadius(unit.fuelRange, canvasWidth, zoom, worldSize) : 0;
  const radarShare = !!unit.radarShare;
  const radarShareCount = typeof unit.radarShareCount === 'number' ? unit.radarShareCount : 0;
  const xpThrottle = typeof unit.xpThrottle === 'number' ? unit.xpThrottle : 0;
  const xpCtrl = typeof unit.xpCtrl === 'number' ? unit.xpCtrl : 0;
  const validWeapons = (unit.weapons || []).filter(w => w && typeof w === 'object');
  const targetComputerCount = validWeapons.reduce((n,w)=>n+(w.targetComputer?1:0),0);
  const hasTargetComputer = targetComputerCount>0;
  const signature = (typeof unit.powerKw === 'number' && cfg)
    ? sigFromPower(cfg, unit.powerKw,{ fuelUse:unit.sigFuelUse||0, weaponFire:unit.sigWeaponFire })
    : 0;
  const weapons = validWeapons.map(w => {
    const cfg = w.cfg || {};
    const ammoSize = cfg.ammo && typeof cfg.ammo.size === 'number' ? cfg.ammo.size : 0;
    const ammo = typeof w.ammo === 'number' ? w.ammo : 0;
    return {
      key: w.key,
      range: scaleRadius(cfg.range || 0, canvasWidth, zoom, worldSize),
      ammo,
      maxAmmo: ammoSize,
      packs: ammoSize > 0 ? 1 + Math.floor((w.reserve || 0) / ammoSize) : 0,
      type: cfg.energy ? 'battery' : 'mag',
      class: cfg.energy ? 'energy' : 'ballistic',
      low: ammoSize > 0 ? ammo < ammoSize * 0.25 : false,
      targeting: !!w.targetComputer
    };
  });
  return { radar, fuelRange, radarShare, radarShareCount, hasTargetComputer, targetComputerCount, xpThrottle, xpCtrl, signature, weapons };
}

/**
 * Determine ammo indicator color.
 * @param {number} ammo Current ammo count.
 * @param {number} max Maximum ammo capacity.
 * @returns {'ok'|'warn'}
 */
function getAmmoColor(ammo, max){
  if (max <= 0){
    return 'ok';
  }
  return ammo < max * 0.25 ? 'warn' : 'ok';
}

const PROJECTILE_COLORS = {
  SMG: 'yellow',
  BeamRifle: 'blue',
  HeavyRail: 'red'
};

const WEAPON_TYPE_HELP = {
  ballistic: 'Uses magazines; fires projectiles',
  energy: 'Uses batteries; fires energy bolts'
};

/**
 * Get display color for a projectile type.
 * @param {string} key Projectile key.
 * @returns {string} CSS color string.
 */
function getProjectileColor(key){
  return PROJECTILE_COLORS[key] || 'white';
}

/**
 * Map of projectile type to color.
 * @returns {Object<string,string>}
 */
function projectileLegend(){
  return { ...PROJECTILE_COLORS };
}

/**
 * Help text for each weapon class.
 * @returns {Object<string,string>}
 */
function weaponTypeHelp(){
  return { ...WEAPON_TYPE_HELP };
}

const uiHelpers = {
  formatUnitInfo,
  getAmmoColor,
  getProjectileColor,
  projectileLegend,
  weaponTypeHelp,
};

const RTS_CFG = loadConfig();

// Supplement shared config with local details used only for tests.
// These fields aren't part of the main game config but are needed here.
if (!RTS_CFG.targetingComputer) {
  RTS_CFG.targetingComputer = { build: { ore: 20 } };
}

// Normalize weapon ammo definitions to use `.size` for capacity.
for (const w of Object.values(RTS_CFG.weapons || {})) {
  if (w.ammo) {
    if (w.ammo.size === undefined) {
      w.ammo.size = w.ammo.mag ?? w.ammo.battery ?? 0;
    }
    if (w.ammo.max === undefined) w.ammo.max = 0;
  } else {
    w.ammo = { size: 0, max: 0 };
  }
  if (w.energy === undefined) w.energy = false;
}

// Add build costs for weapons used in tests when missing.
if (RTS_CFG.weapons.SMG && !RTS_CFG.weapons.SMG.build) {
  RTS_CFG.weapons.SMG.build = { ore: 35 };
}
if (RTS_CFG.weapons.BeamRifle && !RTS_CFG.weapons.BeamRifle.build) {
  RTS_CFG.weapons.BeamRifle.build = { fuel: 60 };
}
if (RTS_CFG.weapons.HeavyRail) {
  if (!RTS_CFG.weapons.HeavyRail.build) {
    RTS_CFG.weapons.HeavyRail.build = { ore: 480 };
  }
  // Ensure HeavyRail range reflects Heavy unit radar dynamically.
  Object.defineProperty(RTS_CFG.weapons.HeavyRail, 'range', {
    configurable: true,
    enumerable: true,
    get() { return RTS_CFG.units.Heavy.radar; }
  });
}

// Slot capacities for generic unit classes used in tests.
const unitClasses = {
  E: { magSlots: 2, batterySlots: 1 },
  L: { magSlots: 4, batterySlots: 2 },
  H: { magSlots: 6, batterySlots: 3 }
};

/**
 * Runtime state for a weapon mounted on a unit.
 * @class
 */
class WeaponState{
  /**
   * @param {Object} cfg Weapon configuration object.
   * @param {Unit} owner Owning unit.
   * @param {string} key Weapon identifier.
   */
  constructor(cfg, owner, key){
    this.cfg = cfg;
    this.owner = owner; // unit
    this.key = key; // weapon id
    this.cd = 0; // cooldown
    const usesAmmo = cfg.ammo && cfg.ammo.max > 0;
    this.ammo = usesAmmo ? cfg.ammo.size : Infinity;
    this.reserve = usesAmmo ? (cfg.ammo.max - 1) * cfg.ammo.size : 0;
    this.reloading = 0; // time remaining for active pack recharge
    this.charging = []; // background recharging packs
    this.idle = 0; // time since last shot
  }
  /**
   * Advance timers and handle automatic reload/recharge logic.
   * @param {number} dt Delta time in seconds.
   * @returns {void}
   */
  tick(dt){
    if(this.cd > 0){
      this.cd = Math.max(0, this.cd - dt);
      this.idle = 0;
    } else {
      this.idle += dt;
    }
    if(this.reloading > 0){
      this.reloading = Math.max(0, this.reloading - dt);
      if(this.reloading === 0){
        // Reload or recharge finished on active pack
        this.ammo = this.cfg.ammo.size;
        if(!this.cfg.energy){
          this.reserve -= this.cfg.ammo.size;
          this.owner.ammoStock[this.key] = (this.owner.ammoStock[this.key]||0) - 1;
          if(this.reserve <= 0){
            if(this.owner && this.owner.owner && this.owner.owner.produceAmmo){
              this.owner.owner.produceAmmo(this.key, this.cfg.ammo.max);
            }
          }
        }
      }
    }
    if(this.charging.length){
      for(let i=this.charging.length-1;i>=0;i--){
        this.charging[i] = Math.max(0, this.charging[i]-dt);
        if(this.charging[i] === 0){
          this.reserve += this.cfg.ammo.size;
          this.charging.splice(i,1);
        }
      }
    }

    // If we're empty but have spare packs and not currently reloading,
    // try to automatically recover once resources become available.
    if(this.ammo === 0 && this.reserve > 0 && this.reloading === 0){
      if(this.cfg.energy){
        if(this.startRecharge()){
          // Swap to a charged pack immediately
          this.ammo = this.cfg.ammo.size;
          this.reserve -= this.cfg.ammo.size;
          this.charging.push(this.cfg.reload.time);
        }
      } else {
        this.startReload();
      }
    }
  }
  /**
   * Whether the weapon can currently fire.
   * @returns {boolean}
   */
  canFire(){
    return this.cd === 0 && this.reloading === 0 && this.ammo > 0;
  }
  /**
   * Attempt to fire the weapon.
   * @returns {boolean} True if a shot was fired.
   */
  fire(){
    if(!this.canFire()) return false;
    this.ammo--;
    this.cd = 1 / this.cfg.rof;
    events.emit('weapon-fired', { weapon: this, owner: this.owner });
    if(this.ammo === 0){
      if(this.cfg.energy){
        const started = this.startRecharge();
        if(this.reserve > 0){
          // swap to charged pack immediately
          this.ammo = this.cfg.ammo.size;
          this.reserve -= this.cfg.ammo.size;
          if(started) this.charging.push(this.cfg.reload.time);
        } else if(started){
          // no spare pack, must wait for recharge
          this.reloading = this.cfg.reload.time;
        }
      } else if(this.reserve > 0){
        this.startReload();
      }
    }
    return true;
  }
  /**
   * Begin recharging an energy weapon.
   * @returns {boolean} True if resources were consumed to start the charge.
   */
  startRecharge(){
    const cost = this.cfg.reload || {};
    if(!this.cfg.energy) return false;
    if(!this.owner || !this.owner.owner || !this.owner.owner.resources){
      console.warn('Weapon cannot recharge: missing owner or resources');
      return false;
    }
    const resources = this.owner.owner.resources; // mothership/outpost resources
    if(cost.ore && resources.ore < cost.ore) return false;
    if(cost.fuel && resources.fuel < cost.fuel) return false;
    if(cost.ore) resources.ore -= cost.ore;
    if(cost.fuel) resources.fuel -= cost.fuel;
    return true;
  }
  /**
   * Begin reloading a magazine-based weapon.
   * @returns {boolean} True if reload started.
   */
  startReload(){
    const cost = this.cfg.reload || {};
    // Manual reload only applies to magazine weapons
    if(this.cfg.energy) return false;
    if(this.reloading > 0 || this.reserve <= 0) return false;
    if(!this.owner || !this.owner.owner || !this.owner.owner.resources){
      console.warn('Weapon cannot reload: missing owner or resources');
      return false;
    }
    const resources = this.owner.owner.resources; // mothership/outpost resources
    if(cost.ore && resources.ore < cost.ore) return false;
    if(cost.fuel && resources.fuel < cost.fuel) return false;
    if(cost.ore) resources.ore -= cost.ore;
    if(cost.fuel) resources.fuel -= cost.fuel;
    this.reloading = cost.time;
    return true;
  }
}

/**
 * Generic component placeholder used when building units.
 * @class
 */
class Component{
  /**
   * @param {string} type Component type.
   * @param {string|null} [key] Optional identifier.
   */
  constructor(type, key = null){
    this.type = type;
    this.key = key;
  }
}

/**
 * Runtime representation of a unit under construction or in battle.
 * @class
 */
class Unit{
  /**
   * @param {Mothership} owner Owning base.
   * @param {string} cls Unit class code.
   * @param {Object} components Component lists by type.
   */
  constructor(owner, cls, components){
    this.owner = owner; // mothership/outpost
    this.cls = cls;
    const cfg = unitClasses[cls] || {magSlots:0, batterySlots:0};
    this.magSlots = cfg.magSlots;
    this.batterySlots = cfg.batterySlots;
    this.magUsed = 0;
    this.batteryUsed = 0;
    this.weapons = [];
    this.ammoStock = {};
    this.components = components || {radar:[], power:[], weapons:[], batteries:[], magazines:[]};
    const req = ['radar','power','weapons','batteries','magazines'];
    for(const r of req){
      if(!this.components[r]) this.components[r] = [];
    }
  }
  /**
   * Check if required components are present.
   * @returns {boolean}
   */
  hasAllComponents(){
    const needsAmmo = this.weapons.some(w => w.cfg.ammo && w.cfg.ammo.max > 0);
    return this.components.radar.length>0 &&
      this.components.power.length>0 &&
      (this.weapons.length === 0 || this.components.weapons.length>0) &&
      (needsAmmo ? (this.components.batteries.length>0 || this.components.magazines.length>0) : true);
  }
  /**
   * Advance all weapon timers.
   * @param {number} dt Delta time in seconds.
   * @returns {void}
   */
  tick(dt){
    for(const w of this.weapons){
      w.tick(dt);
      // AI: swap partially drained battery packs during low-intensity periods
      if(w.cfg.energy && w.reloading===0 && w.cd===0 && w.ammo<w.cfg.ammo.size && w.reserve>=w.cfg.ammo.size && w.idle>2){
        if(w.startRecharge()){
          w.charging.push(w.cfg.reload.time);
          w.reserve -= w.cfg.ammo.size;
          w.ammo = w.cfg.ammo.size;
          w.idle = 0;
        }
      }
    }
  }
  /**
   * Report ammo status of all weapons.
   * @returns {Array<Object>}
   */
  getAmmoStatus(){
    return this.weapons.map(w=>{
      const type = w.cfg.energy ? 'battery' : 'mag';
      const packs = 1 + Math.floor(w.reserve / w.cfg.ammo.size);
      const low = w.ammo < w.cfg.ammo.size * 0.25;
      return {weapon:w.key, type, packs, ammo:w.ammo, low};
    });
  }
}

/**
 * Base that manufactures components and spawns units.
 * @class
 */
class Mothership{
  /**
   * @param {Object} store Initial stockpile information.
   * @param {Object} resources Available resources.
   */
  constructor(store, resources){
    store = store || {};
    this.weaponStock = store.weapons || {};
    this.ammoStock = store.ammo || {};
    this.tcompStock = store.targeting || 0;
    // generic component stockpiles
    this.radarStock = store.radar || (store.components && store.components.radar) || 0;
    this.powerStock = store.power || (store.components && store.components.power) || 0;
    this.batteryStock = store.batteries || (store.components && store.components.batteries) || 0;
    this.magazineStock = store.magazines || (store.components && store.components.magazines) || 0;
    this.weaponStore = {count:0, cap:weaponCap};
    this.ammoStore = {count:0, cap:ammoCap};
    this.weaponStore.count = Object.values(this.weaponStock).reduce((a,b)=>a+b,0);
    this.ammoStore.count = Object.values(this.ammoStock).reduce((a,b)=>a+b,0);
    this.resources = resources || {ore:0, fuel:0};
  }

  /**
   * Produce equipment required by upcoming build queue.
   * @param {Array<Object>} buildQueue Planned builds.
   * @param {boolean} [includeComponents=true] Include non-weapon components.
   * @returns {void}
   */
  produce(buildQueue, includeComponents=true){
    const forecast = forecastNeeds(buildQueue);
    const req = {weapons:{}, ammo:{}, targeting:0};
    if(includeComponents){
      req.radar = 0; req.power = 0; req.batteries = 0; req.magazines = 0;
    }
    for(const key of Object.keys(forecast.weapons)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const need = forecast.weapons[key];
      const have = this.weaponStock[key]||0;
      if(need>have) req.weapons[key]=need-have;
    }
    for(const key of Object.keys(forecast.ammo)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const need = forecast.ammo[key];
      const have = this.ammoStock[key]||0;
      if(need>have) req.ammo[key]=need-have;
    }
    if(forecast.targeting > this.tcompStock) req.targeting = forecast.targeting - this.tcompStock;
    if(includeComponents){
      if(forecast.radar > this.radarStock) req.radar = forecast.radar - this.radarStock;
      if(forecast.power > this.powerStock) req.power = forecast.power - this.powerStock;
      if(forecast.batteries > this.batteryStock) req.batteries = forecast.batteries - this.batteryStock;
      if(forecast.magazines > this.magazineStock) req.magazines = forecast.magazines - this.magazineStock;
    }
    for(const key of Object.keys(req.weapons)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const cost = wCfg.build || {};
      while(req.weapons[key] > 0){
        if((cost.ore||0) > this.resources.ore) break;
        if((cost.fuel||0) > this.resources.fuel) break;
        if(this.weaponStore.count >= this.weaponStore.cap) break;
        this.resources.ore -= cost.ore||0;
        this.resources.fuel -= cost.fuel||0;
        this.weaponStock[key] = (this.weaponStock[key]||0)+1;
        this.weaponStore.count++;
        req.weapons[key]--;
      }
    }
    for(const key of Object.keys(req.ammo)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const cost = wCfg.reload || {};
      const pack = 1; // craft one magazine at a time
      while(req.ammo[key] > 0){
        if((cost.ore||0) > this.resources.ore) break;
        if((cost.fuel||0) > this.resources.fuel) break;
        if(this.ammoStore.count + pack > this.ammoStore.cap) break;
        this.resources.ore -= cost.ore||0;
        this.resources.fuel -= cost.fuel||0;
        this.ammoStock[key] = (this.ammoStock[key]||0) + pack;
        this.ammoStore.count += pack;
        req.ammo[key] -= pack;
      }
    }
    if(req.targeting){
      const cost = (RTS_CFG.targetingComputer && RTS_CFG.targetingComputer.build) || {};
      while(req.targeting > 0){
        if((cost.ore||0) > this.resources.ore) break;
        if((cost.fuel||0) > this.resources.fuel) break;
        this.resources.ore -= cost.ore||0;
        this.resources.fuel -= cost.fuel||0;
        this.tcompStock++;
        req.targeting--;
      }
    }
    if(includeComponents){
      const C = (RTS_CFG.economy && RTS_CFG.economy.componentCosts) || {};
      const rSlot = C.radarSlot || { ore:0, fuel:0 };
      const pSlot = C.powerSlot || { ore:0, fuel:0 };
      const gens = (RTS_CFG.components && RTS_CFG.components.power) || {};
      const rads = (RTS_CFG.components && RTS_CFG.components.radar) || {};
      const trySpend = (cost)=>{
        const ore = (cost&&cost.ore)||0, fuel = (cost&&cost.fuel)||0;
        if(ore > (this.resources.ore||0)) return false;
        if(fuel > (this.resources.fuel||0)) return false;
        this.resources.ore -= ore;
        this.resources.fuel -= fuel;
        return true;
      };
      if(req.radar){
        // No model info at this stage; pay slot cost
        while(req.radar>0){ if(trySpend(rSlot)){ this.radarStock++; req.radar--; } else break; }
      }
      if(req.power){
        while(req.power>0){ if(trySpend(pSlot)){ this.powerStock++; req.power--; } else break; }
      }
      if(req.batteries){
        while(req.batteries>0){ this.batteryStock++; req.batteries--; }
      }
      if(req.magazines){
        while(req.magazines>0){ this.magazineStock++; req.magazines--; }
      }
    }
  }

  /**
   * Produce ammunition for a specific weapon.
   * @param {string} key Weapon key.
   * @param {number} count Number of magazines to produce.
   * @returns {void}
   */
  produceAmmo(key, count){
    const wCfg = RTS_CFG.weapons[key];
    if(!wCfg) return;
    const cost = wCfg.reload || {};
    const pack = 1; // produce individual magazines
    while(count>0){
      if((cost.ore||0) > this.resources.ore) break;
      if((cost.fuel||0) > this.resources.fuel) break;
      if(this.ammoStore.count + pack > this.ammoStore.cap) break;
      this.resources.ore -= cost.ore||0;
      this.resources.fuel -= cost.fuel||0;
      this.ammoStock[key] = (this.ammoStock[key]||0) + pack;
      this.ammoStore.count += pack;
      count -= pack;
    }
  }

  /**
   * Verify stock availability for a desired loadout.
   * @param {Object} loadout Requested weapons/components.
   * @param {boolean} [allowMulti=false] Allow multiple weapon types.
   * @returns {boolean}
   */
  _validateLoadout(loadout, allowMulti=false){
    const weapons = loadout.weapons || loadout;
    let batteriesNeeded = 0;
    let magazinesNeeded = 0;
    let totalWeapons = 0;
    for(const key of Object.keys(weapons)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const needW = weapons[key];
      totalWeapons += needW;
      const slots = wCfg.ammo.max * needW;
      if(wCfg.energy) batteriesNeeded += slots;
      else magazinesNeeded += slots;
      if((this.weaponStock[key]||0) < needW) return false;
      if((this.ammoStock[key]||0) < slots) return false;
    }
    if(!allowMulti && totalWeapons > 1) return false;
    const radarNeed = loadout.radar !== undefined ? loadout.radar : 1;
    const powerNeed = loadout.power !== undefined ? loadout.power : 1;
    if(this.radarStock < radarNeed) return false;
    if(this.powerStock < powerNeed) return false;
    if(this.batteryStock < batteriesNeeded) return false;
    if(this.magazineStock < magazinesNeeded) return false;
    return true;
  }

  /**
   * Choose a feasible loadout given stock limitations.
   * @param {Object} loadout Desired loadout.
   * @param {boolean} [allowMulti=false] Allow multiple weapon types.
   * @returns {Object|null} Alternative loadout or null.
   */
  _chooseLoadout(loadout, allowMulti=false){
    const alt = {};
    for(const key of Object.keys(loadout)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const haveW = this.weaponStock[key]||0;
      const haveA = (this.ammoStock[key]||0) / wCfg.ammo.max | 0;
      const n = Math.min(loadout[key], haveW, haveA);
      if(n>0){
        alt[key]=allowMulti?n:1;
        if(!allowMulti) break;
      }
    }
    return Object.keys(alt).length?alt:null;
  }

  /**
   * Spawn a unit if required parts are available.
   * @param {Object} loadout Weapon/component request.
   * @param {Object} [opts]
   * @param {string} [opts.cls='L'] Unit class.
   * @param {boolean} [opts.allowMulti=false] Allow multiple weapon types.
   * @param {boolean} [opts.allowFallback=false] Try alternate loadout if unavailable.
   * @returns {Unit|null}
   */
  spawn(loadout, opts={}){
    opts = opts||{};
    const cls = opts.cls || 'L';

    let componentsInput;
    if(loadout && (loadout.weapons || loadout.radar!==undefined || loadout.power!==undefined || loadout.batteries || loadout.magazines)){
      componentsInput = loadout;
      loadout = componentsInput.weapons || {};
    }

    const reqStruct = componentsInput || loadout;
    if(reqStruct) this.produce([reqStruct], false);
    if(reqStruct && !this._validateLoadout(reqStruct, opts.allowMulti)){
      if(opts.allowFallback){
        const alt = this._chooseLoadout(loadout, opts.allowMulti);
        if(!alt) return null;
        loadout = alt;
      } else {
        return null;
      }
    }

    const unitComponents = {radar:[], power:[], weapons:[], batteries:[], magazines:[]};
    componentsInput = componentsInput || {};
    const radarNeeded = componentsInput.radar ?? 1;
    const powerNeeded = componentsInput.power ?? 1;
    if(this.radarStock < radarNeeded) return null;
    if(this.powerStock < powerNeeded) return null;
    this.radarStock -= radarNeeded;
    this.powerStock -= powerNeeded;
    for(let i=0;i<radarNeeded;i++) unitComponents.radar.push(new Component('radar'));
    for(let i=0;i<powerNeeded;i++) unitComponents.power.push(new Component('power'));

    const u = new Unit(this, cls, unitComponents);

    if(loadout){
      for(const key of Object.keys(loadout)){
        for(let i=0;i<loadout[key];i++){
          const wCfg = RTS_CFG.weapons[key];
          if(!wCfg) continue;
          const usesBattery = !!wCfg.energy;
          const avail = usesBattery ? (u.batterySlots - u.batteryUsed) : (u.magSlots - u.magUsed);
          if(avail <= 0) continue;
          const slots = Math.min(wCfg.ammo.max, avail);
          if((this.weaponStock[key]||0) <= 0) continue;
          if((this.ammoStock[key]||0) < slots) continue;
          if(usesBattery && this.batteryStock < slots) continue;
          if(!usesBattery && this.magazineStock < slots) continue;
          this.weaponStock[key]--;
          this.weaponStore.count--;
          this.ammoStock[key] -= slots;
          this.ammoStore.count -= slots;
          if(usesBattery) this.batteryStock -= slots; else this.magazineStock -= slots;
          const w = new WeaponState(wCfg,u,key);
          if(wCfg.targetComputer && this.tcompStock>0){
            w.targetComputer = wCfg.targetComputer;
            this.tcompStock--;
          }
          const spare = Math.max(0, slots - 1);
          w.reserve = spare * wCfg.ammo.size;
          if(!usesBattery) u.ammoStock[key] = (u.ammoStock[key]||0) + spare;
          u.weapons.push(w);
          u.components.weapons.push(new Component('weapon', key));
          for(let s=0;s<slots;s++){
            if(usesBattery) u.components.batteries.push(new Component('battery', key));
            else u.components.magazines.push(new Component('magazine', key));
          }
          if(usesBattery) u.batteryUsed += slots; else u.magUsed += slots;
        }
      }
    }
    if(loadout && Object.keys(loadout).length > 0 && u.weapons.length === 0) return null;
    if(!u.hasAllComponents()) return null;
    return u;
  }
}

/** Lightweight Mothership variant used for remote bases. */
class Outpost extends Mothership{}

/**
 * Determine additional items required to satisfy a build queue.
 * @param {Array<Object>} buildQueue Queue of desired units.
 * @param {Object} store Current stock levels.
 * @returns {Object} Required weapons, ammo and components.
 */
function planRequests(buildQueue, store){
  const empty = {weapons:{}, ammo:{}, targeting:0, radar:0, power:0, batteries:0, magazines:0};
  if(!Array.isArray(buildQueue)) return empty;
  if(!store || typeof store !== 'object') return empty;
  if(!store.weapons || typeof store.weapons !== 'object') return empty;
  if(!store.ammo || typeof store.ammo !== 'object') return empty;

  const needed = {weapons:{}, ammo:{}, targeting:0, radar:0, power:0, batteries:0, magazines:0};
  for(const load of buildQueue){
    const weapons = load.weapons || load;
    const radar = load.radar !== undefined ? load.radar : 1;
    const power = load.power !== undefined ? load.power : 1;
    needed.radar += radar;
    needed.power += power;
    for(const key of Object.keys(weapons)){
      const wCfg = RTS_CFG.weapons[key];
      if(!wCfg) continue;
      const count = weapons[key];
      needed.weapons[key] = (needed.weapons[key]||0) + count;
      const max = wCfg.ammo.max;
      const packs = count * max;
      needed.ammo[key] = (needed.ammo[key]||0) + packs;
      if(wCfg.energy) needed.batteries += packs; else needed.magazines += packs;
      if(wCfg.targetComputer) needed.targeting += count;
    }
  }
  const req = {weapons:{}, ammo:{}, targeting:0, radar:0, power:0, batteries:0, magazines:0};
  for(const key of Object.keys(needed.weapons)){
    const wNeed = needed.weapons[key];
    const wHave = (store.weapons[key]||0);
    if(wNeed > wHave) req.weapons[key] = wNeed - wHave;
    const aNeed = needed.ammo[key];
    const aHave = (store.ammo[key]||0);
    if(aNeed > aHave) req.ammo[key] = aNeed - aHave;
  }
  if(needed.radar > (store.radar||0)) req.radar = needed.radar - (store.radar||0);
  if(needed.power > (store.power||0)) req.power = needed.power - (store.power||0);
  if(needed.batteries > (store.batteries||0)) req.batteries = needed.batteries - (store.batteries||0);
  if(needed.magazines > (store.magazines||0)) req.magazines = needed.magazines - (store.magazines||0);
  const tNeed = needed.targeting;
  const tHave = store.targeting || 0;
  if(tNeed > tHave) req.targeting = tNeed - tHave;
  return req;
}

/**
 * Forecast production needs for the build queue.
 * @param {Array<Object>} buildQueue Queue of planned builds.
 * @returns {Object} Required stock estimates.
 */
function forecastNeeds(buildQueue){
  // Simple heuristic: forecast equals current build queue requirements
  return planRequests(buildQueue, {weapons:{}, ammo:{}, targeting:0, radar:0, power:0, batteries:0, magazines:0});
}

// Entity types in threat priority order helper
const T = {
  Heavy: 'Heavy',
  Light: 'Light',
  Platform: 'Platform',
  Outpost: 'Outpost',
  Mother: 'Mother',
  EW: 'EW'
};

// Set of entity types allowed for targeting
const ALLOWED_TYPES = new Set(Object.values(T));

function threatScore(e){
  switch(e.type){
    case T.Heavy: return 5;
    case T.Light:
    case T.EW: return 4;
    case T.Platform: return 3;
    case T.Outpost: return 2;
    case T.Mother: return 1;
    default: return 0;
  }
}

/**
 * Choose the best target for the given entity using intel data.
 * Only entities currently in line-of-sight are considered unless
 * `opts.useLastKnown` is set, which allows targeting using last-known data.
 *
 * @param {Object} shooter The entity selecting a target.
 * @param {Array<Object>} entities All entities in the world.
 * @param {Object} cfg Game configuration.
 * @param {Object} [opts]
 * @param {boolean} [opts.useLastKnown=false] Allow targeting using last-known info.
 * @returns {Object|null} Chosen target entity or null if none.
 */
function chooseTarget(shooter, entities, cfg, opts={}){
  const {useLastKnown=false} = opts;

  // Shooter must be a valid object
  if(!shooter || typeof shooter !== 'object'){
    if(console && console.warn) console.warn('chooseTarget: shooter is not an object');
    return null;
  }

  // Validate shooter weapons and compute max range
  if(!Array.isArray(shooter.weapons) || shooter.weapons.length===0){
    if(console && console.warn) console.warn('chooseTarget: shooter has no weapons');
    return null;
  }
  const usable = shooter.weapons.filter(w => typeof w.range === 'number' && w.range > 0);
  if(usable.length === 0){
    if(console && console.warn) console.warn('chooseTarget: shooter weapons have no usable range');
    return null;
  }
  const R = Math.max(...usable.map(w => w.range));

  // Validate shooter position
  const spos = shooter.pos;
  if(!Array.isArray(spos) || spos.length !== 3 || spos.some(n => typeof n !== 'number')){
    if(console && console.warn) console.warn('chooseTarget: shooter position invalid');
    return null;
  }

  // Entities must be an array
  if(!Array.isArray(entities)){
    if(console && console.warn) console.warn('chooseTarget: entities is not an array');
    return null;
  }

  const finfo = _ensureFaction(shooter.faction);
  let best=null, bestScore=-1, bd=Infinity;
  for(const t of entities){
    if(!t || !Array.isArray(t.pos) || t.pos.length !== 3 || t.pos.some(n=>typeof n!== 'number')){
      if(console && console.warn) console.warn('chooseTarget: entity position invalid');
      continue;
    }
    if(typeof t.id !== 'number'){
      if(console && console.warn) console.warn('chooseTarget: entity missing numeric id');
      continue;
    }
    if(t.faction===shooter.faction || t.hidden) continue;
    if(!ALLOWED_TYPES.has(t.type)) continue;

    const visible = finfo.current.has(t.id);
    let d;
    if(visible){
      d = dist(spos, t.pos);
    } else if(useLastKnown){
      const ln = finfo.lastKnown.get(t.id);
      if(!ln || !Array.isArray(ln.pos) || ln.pos.some(n=>typeof n!== 'number')) continue;
      d = dist(spos, ln.pos);
    } else {
      continue;
    }

    const score = threatScore(t);
    if(d<R && (score>bestScore || (score===bestScore && d<bd))){
      bd=d; best=t; bestScore=score;
    }
  }
  return best;
}

/**
 * Compute target-computer tracking and lead after enemy jamming.
 * @param {Object} shooter Attacking entity.
 * @param {Object} target Target entity.
 * @param {Object} weapon Weapon with optional target computer.
 * @param {Array<Object>} entities All entities in the world.
 * @param {Object} cfg Game configuration.
 * @returns {{tracking:number, lead:number}}
 */
function jammedTracking(shooter, target, weapon, entities, cfg){
  const sig = sigFromPower(cfg, target.powerKw || 0, { fuelUse: target.sigFuelUse || 0, weaponFire: target.sigWeaponFire });
  let jam = 0;
  for(const j of entities){
    if(j.faction !== shooter.faction && !j.hidden && j.type === T.EW && j.jammer){
      const r = j.jammer.radius || 0;
      const d = dist(target.pos, j.pos);
      if(d < r){
        const contrib = (j.jammer.strength||0) * (1 - d/r);
        if(contrib > 0) jam += contrib;
      }
    }
  }
  jam = Math.max(0, jam);
  const eff = Math.max(0, sig - jam);
  const factor = sig>0 ? eff/sig : 0;
  const tc = weapon.targetComputer || {};
  return {
    tracking: (tc.tracking || 0) * factor,
    lead: (tc.lead || 1) * factor,
  };
}

/**
 * Deterministic pseudo-random number generator using LCG.
 * @param {number} seed Seed value.
 * @returns {() => number} Function returning floats in [0,1).
 */
function RNG(seed) {
  let s = seed >>> 0;
  return () => {
    s = (s * 1664525 + 1013904223) >>> 0;
    return (s >>> 0) / 4294967296;
  };
}

window.overlayMath = overlayMath;

(function(){
"use strict";

/* ============================ UI HOOKS ============================ */

  const el=id=>document.getElementById(id);
  const c2d=el('c2d'), g2d=c2d.getContext('2d');
  const c3d=el('c3d'), g3d=c3d.getContext('2d');
  const view2D=el('view2D'), view3D=el('view3D');
  const canvWrap=document.querySelector('.canvwrap');
  let stars=[];
  const skyCam={ yaw:0, pitch:0, zoom:1 };
  const skyTex=document.createElement('canvas'), gSky=skyTex.getContext('2d');
  const getCss=(v,f)=>getComputedStyle(document.documentElement).getPropertyValue(v).trim()||f;
  const SKY_COLORS={
    gradStart:getCss('--sky-grad-start','#061d43'),
    gradMid:'#172551',
    gradEnd:getCss('--sky-grad-end','#240046'),
    starCore:getCss('--star-core-color','#7dd3fc'),
    starEdge:getCss('--star-edge-color','#a78bfa')
  };
  const hexToRgb=h=>{const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:255,g:255,b:255};};
  const STAR_CORE_RGB=hexToRgb(SKY_COLORS.starCore);
  const STAR_EDGE_RGB=hexToRgb(SKY_COLORS.starEdge);

  function generateStars(){
    const w=c3d.width,h=c3d.height,z=skyCam.zoom;
    stars=[];
    for(let i=0;i<200;i++){
      stars.push({
        x:Math.random()*w,
        y:Math.random()*h,
        size:(Math.random()*1.5+0.5)*z,
        brightness:Math.random()*0.5+0.5
      });
    }
  }

  function renderSky(){
    const w=skyTex.width=c3d.width, h=skyTex.height=c3d.height;
    gSky.clearRect(0,0,w,h);
    const bg=gSky.createLinearGradient(0,0,0,h);
    bg.addColorStop(0,SKY_COLORS.gradStart);
    bg.addColorStop(0.5,SKY_COLORS.gradMid);
    bg.addColorStop(1,SKY_COLORS.gradEnd);
    gSky.fillStyle=bg;
    gSky.fillRect(0,0,w,h);
    const parX=skyCam.yaw*30*skyCam.zoom, parY=skyCam.pitch*30*skyCam.zoom;
    for(const s of stars){
      let x=(s.x+parX)%w; if(x<0) x+=w;
      let y=(s.y+parY)%h; if(y<0) y+=h;
      const grad=gSky.createRadialGradient(x,y,0,x,y,s.size);
      grad.addColorStop(0,`rgba(${STAR_CORE_RGB.r},${STAR_CORE_RGB.g},${STAR_CORE_RGB.b},${s.brightness})`);
      grad.addColorStop(1,`rgba(${STAR_EDGE_RGB.r},${STAR_EDGE_RGB.g},${STAR_EDGE_RGB.b},0)`);
      gSky.fillStyle=grad; gSky.beginPath(); gSky.arc(x,y,s.size,0,Math.PI*2); gSky.fill();
    }
  }

  function resizeCanvases(){
    const wrapW = canvWrap.clientWidth - 20; // account for padding
    const show2D = view2D.style.display !== 'none';
    const show3D = view3D.style.display !== 'none';
    const cols = (show2D && show3D) ? 2 : 1;
    const size = Math.min((wrapW - 10*(cols-1))/cols, window.innerHeight - 40);
    c2d.width = c2d.height = size;
    c3d.width = c3d.height = size;
    generateStars();
  }
  window.addEventListener('resize', resizeCanvases);
  resizeCanvases();

  let viewMode = "2D";
  function updateCanvasVisibility(){
    const show2D = viewMode === "2D";
    const show3D = viewMode === "3D";
    view2D.style.display = show2D ? "block" : "none";
    view3D.style.display = show3D ? "block" : "none";
    const single = (show2D?1:0) + (show3D?1:0) === 1;
    canvWrap.classList.toggle('single', single);
    canvWrap.style.display = "grid"; // ensure wrap remains grid
    resizeCanvases();
  }
  updateCanvasVisibility();
  el('viewToggle').onclick = ()=>{
    viewMode = viewMode === "2D" ? "3D" : "2D";
    el('viewToggle').textContent = viewMode === "2D" ? "Switch to 3D" : "Switch to 2D";
    updateCanvasVisibility();
  };

el('cfgText').value = JSON.stringify(RTS_CFG, null, 2);
el('applyCfg').onclick = ()=>{
  try{
    const newCfg = loadConfig(JSON.parse(el('cfgText').value));
    Object.assign(RTS_CFG, newCfg);
    reseedAll();
  } catch(e){
    alert('Bad JSON: '+e.message);
  }
};
el('speed').oninput=()=> el('speedLbl').textContent = (+el('speed').value).toFixed(2)+'Ã—';
el('zoom').oninput=()=>{ camZoom=mapCam.zoom=+el('zoom').value; clampMapCam(); draw2D(); };
el('fitMap').onclick=()=>{ camZoom=mapCam.zoom=1; mapCam.x=0; mapCam.y=0; el('zoom').value=camZoom; camDist=260 + (world.size*Math.sqrt(3)/2)*2.1; clampMapCam(); draw2D(); };
  el('resetSky').onclick=()=>{ skyCam.yaw=0; skyCam.pitch=0; skyCam.zoom=1; generateStars(); };

  /* ============================ BNP BRIDGE ============================ */
  const BNPBridge = (()=>{
    let attached=false;
    let W=0,H=0;
    let lastSyncTick=-1;
    const unsubs=[];
    const CH = ()=> (window.BNP && window.BNP.size && window.BNP.size.CH) || {R:0,G:1,B:2,Q:3,P:4,S:5};
    const SAMP=3; // brush radius in pixels
    function avail(){ return (typeof window!=='undefined' && window.BNP && window.BNP.size && window.BNP.pixel); }
    function worldToGrid(x,z){
      const half = world.half || (RTS_CFG.world.size/2);
      const gx = Math.round( ( (x + half) / (2*half) ) * (W-1) );
      const gy = Math.round( ( (z + half) / (2*half) ) * (H-1) );
      return [ Math.max(0,Math.min(W-1,gx)), Math.max(0,Math.min(H-1,gy)) ];
    }
    function stampCircle(x,y,val,chIndex){
      const r=SAMP;
      for(let dy=-r; dy<=r; dy++){
        for(let dx=-r; dx<=r; dx++){
          if(dx*dx+dy*dy>r*r) continue;
          const xx = x+dx, yy = y+dy;
          if(xx<0||yy<0||xx>=W||yy>=H) continue;
          const i = window.BNP.util.idx(xx,yy);
          window.BNP.pixel.setChannelSafe(i, chIndex, val);
        }
      }
    }
    function clearFrame(){
      const buf = window.BNP.buffers.sheet;
      for(let i=0;i<W*H;i++){
        const b=i*6;
        buf[b+0]*=0.90; buf[b+1]*=0.90; buf[b+2]*=0.90;
        buf[b+3]*=0.92; buf[b+4]*=0.92; buf[b+5]*=0.92;
      }
    }
    function syncOnce(){
      if(!attached || !avail()) return false;
      if(lastSyncTick===tickCount) return true;
      lastSyncTick=tickCount;
      clearFrame();
      // Resources -> S
      for(const r of resources){
        const [x,y]=worldToGrid(r.pos[0], r.pos[2]);
        stampCircle(x,y, r.type===T.ResFuel?0.9:0.65, CH().S);
      }
      // Factions: Red->Q, Blue->P; also tint RGB
      for(const e of entities){
        if(e.hidden) continue;
        const [x,y]=worldToGrid(e.pos[0], e.pos[2]);
        const ch = (e.faction===0) ? CH().Q : CH().P;
        stampCircle(x,y, 0.85, ch);
        const i=window.BNP.util.idx(x,y);
        const col = (e.faction===0)? [0.85,0.15,0.20] : [0.15,0.45,0.85];
        window.BNP.pixel.setChannelSafe(i, CH().R, col[0]);
        window.BNP.pixel.setChannelSafe(i, CH().G, col[1]);
        window.BNP.pixel.setChannelSafe(i, CH().B, col[2]);
      }
      // Rails along team links
      const rails = window.BNP.buffers.rails; rails.fill(0);
      for(const tm of teams){
        const leader = getById(tm.leader); if(!leader) continue;
        for(const id of tm.members){ const u=getById(id); if(!u||u.id===leader.id) continue;
          const [x0,y0]=worldToGrid(leader.pos[0], leader.pos[2]);
          const [x1,y1]=worldToGrid(u.pos[0], u.pos[2]);
          const dx=Math.abs(x1-x0), sx=x0<x1?1:-1; const dy=-Math.abs(y1-y0), sy=y0<y1?1:-1; let err=dx+dy, x=x0, y=y0; const lane=((tm.id%3)+1);
          for(;;){ rails[window.BNP.util.idx(x,y)] = lane; if(x===x1 && y===y1) break; const e2=2*err; if(e2>=dy){ err+=dy; x+=sx; } if(e2<=dx){ err+=dx; y+=sy; } }
        }
      }
      window.BNP.rails.buildRailFieldFull(5);
      if(document.getElementById('bnpAutoDraw')?.checked){ window.BNP.draw.draw2D(); }
      return true;
    }
    function attach(){
      if(!avail()) return false;
      const sz=window.BNP.size; W=sz.W; H=sz.H; attached=true; const s=document.getElementById('bnpStatus'); if(s) s.textContent='attached';
      // Event hooks -> DNA bus (lightweight)
      try{
        unsubs.push(events.on('entity-added', e=>{ window.BNP.dna.dnaEmitClass(window.BNP.dna.Q2_CLASS.Resid,{tick:tickCount}); }));
        unsubs.push(events.on('entity-removed', e=>{ window.BNP.dna.dnaEmitClass(window.BNP.dna.Q2_CLASS.Hs,{tick:tickCount}); }));
        unsubs.push(events.on('resource-added', r=>{ window.BNP.dna.dnaEmitClass(window.BNP.dna.Q2_CLASS.CRCok,{tick:tickCount}); }));
        unsubs.push(events.on('resource-removed', r=>{ window.BNP.dna.dnaEmitClass(window.BNP.dna.Q2_CLASS.CRCbad,{tick:tickCount}); }));
      }catch(_e){}
      return true;
    }
    function detach(){ attached=false; while(unsubs.length){ const off=unsubs.pop(); try{ off&&off(); }catch(_){} } const s=document.getElementById('bnpStatus'); if(s) s.textContent='detached'; }
    return { attach, detach, syncOnce };
  })();

/* ============================ MATH / UTILS ============================ */
function calcFuelRange(u){
  if(!u || !u.tank || u.fuel<=0) return 0;
  const cfg = unitCfgByType(u.type) || RTS_CFG.units.Mother;
  let best=0;
  for(const m of ['coupled','decoupled']){
    const mcfg = RTS_CFG.fuelUse[m] || {};
    const fcfg = (RTS_CFG.flight.modes||{})[m] || {};
    const spd = (cfg.spd||0) * (fcfg.spdMul||1);
    const perSec = (mcfg.basePerSec||0) + (u.upkeep||0) + (RTS_CFG.fuelUse.radarPerSec||0);
    const perUnit = (mcfg.movePerUnit||0);
    const costPerUnit = perUnit + (spd>0 ? perSec/spd : Infinity);
    if(costPerUnit>0){
      const r = u.fuel / costPerUnit;
      if(r>best) best=r;
    }
  }
  return best;
}
function randInUnitDiskPerp(dir){ const d=V.norm(dir), ref=Math.abs(d[1])<0.9?[0,1,0]:[1,0,0]; const e1=V.norm(V.cross(d,ref)), e2=V.cross(d,e1); const t=Math.random()*Math.PI*2, r=Math.random(); return V.add(V.mul(e1,Math.cos(t)*r), V.mul(e2,Math.sin(t)*r)); }

// Separation offset to reduce friendly collisions/clumping
function separationOffset(e, R=10, k=4){
  let off=[0,0,0];
  for(const o of entities){
    if(!o || o.hidden || o.id===e.id || o.faction!==e.faction) continue;
    const d = calcDist(e.pos, o.pos);
    if(d>0 && d<R){
      const dir = V.mul( V.sub(e.pos, o.pos), 1/d );
      const w = k * (1 - d/R);
      off = V.add(off, V.mul(dir, w));
    }
  }
  return off;
}

/* === Subtask helpers (B) === */
function setSubtask(u, label, minHold=0.4){
  u._subtaskUntil = Math.max(u._subtaskUntil || 0, (tickCount/60) + minHold);
  u.subtask = label;
}
function tickSubtask(u){
  if ((tickCount/60) > (u._subtaskUntil ?? 0)) {
    u.subtask = 'Transit';
  }
}

/* ============================ GAME STATE ============================ */

const FRED=0, FBLU=1;
const T = { Mother:1, Constructor:2, EW:3, Light:4, Heavy:5, Outpost:6, Platform:7, ResOre:8, ResFuel:9, Projectile:10 };
const COLORS = { [FRED]:'#ff6b6b', [FBLU]:'#6ecbff', neutral:'#bbb' };
const MISSION = { Patrol:'Patrol', SAD:'Search&Destroy', Defend:'Defend', Escort:'Escort', Harass:'Harass', Siege:'Siege', Refuel:'Refuel' };
const EMISSION = { MineOre:'MineOre', MineFuel:'MineFuel', ReturnDeposit:'ReturnDeposit', DeliverFuel_Load:'DeliverFuel_Load', DeliverFuel_Travel:'DeliverFuel_Deliver', BuildOutpost_Load:'BuildOutpost_Load', BuildPlatform_Load:'BuildPlatform_Load', BuildOutpost:'BuildOutpost', BuildPlatform:'BuildPlatform', Repair:'Repair', Idle:'Idle', Stalled:'Stalled', DockQueue:'DockQueue', Docked:'Docked' };

const gunOffset = 3;
// World-space hit radius used for projectile collision checks
const HIT_RADIUS = 1.2;

let rng, projectiles = [], resources = [];
// Track how many miners are assigned to each resource node
const nodeAssignments = new Map();
let teams=[]; // single declaration
let fx=[]; // particles (thrusters/explosions)
let tickCount=0, running=false, endState=null;

// simple runtime metrics for debugging and validation
const DEBUG_METRICS = { fuelIdle:0, fuelActive:0, deadZoneSkips:0 };

let idAlloc=1; const byId=new Map();
function makeEntity(p){
  const e={ id:idAlloc++, prevVel:[0,0,0], maneuver:0,
            fwd:[1,0,0], right:[0,0,1], up:[0,1,0],
            thr:{
              main:{i:0,ang:0}, fore:{i:0,ang:0},
              left:{i:0,ang:0}, right:{i:0,ang:0},
              up:{i:0,ang:0},   down:{i:0,ang:0}
            },
            ...p };
  entities.push(e); byId.set(e.id,e); return e;
}
const getById=id=>byId.get(id)||null;
function removeEntity(e){
  const idx = entities.indexOf(e);
  if(idx !== -1) entities.splice(idx, 1);
  byId.delete(e.id);
  if(e && e.faction!=null){
    const f=factions[e.faction];
    if(f){
      f.units.delete(e);
      f.structures.delete(e);
    }
  }
}

/* ============================ WORLD GEN ============================ */

function lerp([a,b]){ return a + (b-a)*rng(); }
function spawnResourceCluster(center, n, isFuel){
  for(let i=0;i<n;i++){
    const r=(rng()*1.0+0.2)*12, th=rng()*Math.PI*2, ph=(rng()*0.7-0.35)*Math.PI;
    const x=center[0]+r*Math.cos(th)*Math.cos(ph), y=center[1]+r*Math.sin(th)*Math.cos(ph), z=center[2]+r*Math.sin(ph);
    const cap=isFuel? lerp(RTS_CFG.resources.fuelNode.cap) : lerp(RTS_CFG.resources.oreNode.cap);
    resources.push({ id:idAlloc++, type:isFuel?T.ResFuel:T.ResOre, pos:[x,y,z], cap, capMax:cap, rate:isFuel?RTS_CFG.resources.fuelNode.shareRate:RTS_CFG.resources.oreNode.shareRate });
  }
}

/* ========================== FACTIONS & STATS ========================== */

function makeFaction(fid, origin, color){
  const zeroUnitStats=()=>({alive:0,built:0,lost:0,kills:0,dmgDealt:0,dmgTaken:0,shotsFired:0,shotsHit:0,timeAlive:0});
  const f={
    fid, color, origin, name:fid===FRED?'Red':'Blue',
    ore: 10000, fuel: 10000,
    units:new Set(), structures:new Set(),
    oreHist:[], fuelHist:[],
    fuelReq: new Map(),
    lowFuel:[],
    kpi:{ oreRate:0, fuelRate:0, FP:0, posture:'BuildUp', lastPosture:'BuildUp' },
    buildQ:[], squads:[],
    kills:{ units:0, structures:0 }, losses:{ units:0, structures:0 },
    // NEW: fuel rationing state
    ration:{ active:false, eligible:0, needToTopOff:0 },
    // NEW: Intel store (C)
    intel:new Map(),
    stats:{
      oreMined:0, fuelMined:0, oreSpent:0, fuelSpent:0,
      shotsFired:0, shotsHit:0, dmgDealt:0, dmgTaken:0,
      builtByType:{}, lostByType:{},
      perType: {
        Mother:zeroUnitStats(), Constructor:zeroUnitStats(), EW:zeroUnitStats(),
        Light:zeroUnitStats(), Heavy:zeroUnitStats(), CollectorOutpost:zeroUnitStats(), WeaponPlatform:zeroUnitStats()
      }
    }
  };
  const m = new Mothership({weapons:{}, ammo:{}, radar:0, power:0, batteries:0, magazines:0}, f);
  f.logistics = m;
  f.weaponStock = m.weaponStock;
  f.ammoStock = m.ammoStock;
  f.weaponStore = m.weaponStore;
  f.ammoStore = m.ammoStore;
  Object.defineProperty(f, 'radarStock', {get:()=>m.radarStock, set:v=>{m.radarStock=v;}});
  Object.defineProperty(f, 'powerStock', {get:()=>m.powerStock, set:v=>{m.powerStock=v;}});
  f.radarStore = {cap:componentCap};
  Object.defineProperty(f.radarStore, 'count', {get:()=>m.radarStock, set:v=>{m.radarStock=v;}});
  f.powerStore = {cap:componentCap};
  Object.defineProperty(f.powerStore, 'count', {get:()=>m.powerStock, set:v=>{m.powerStock=v;}});
  return f;
}
function classKey(e){
  if(!e) return 'Unknown';
  if(e.type===T.Mother) return 'Mother';
  if(e.type===T.Constructor) return 'Constructor';
  if(e.type===T.EW) return 'EW';
  if(e.type===T.Light) return 'Light';
  if(e.type===T.Heavy) return 'Heavy';
  if(e.type===T.Outpost) return 'CollectorOutpost';
  if(e.type===T.Platform) return 'WeaponPlatform';
  return 'Unknown';
}
function markBuilt(fid, key){ const s=factions[fid].stats; s.builtByType[key]=(s.builtByType[key]||0)+1; s.perType[key].built++; s.perType[key].alive++; }
function markLost(fid, key, lifeSec){ const s=factions[fid].stats; s.lostByType[key]=(s.lostByType[key]||0)+1; s.perType[key].lost++; s.perType[key].alive=Math.max(0,s.perType[key].alive-1); s.perType[key].timeAlive += lifeSec||0; }

/* ============================ COMMS / INTEL (C) ============================ */

let comms=[];
function sendComms(m){ comms.push({id:idAlloc++, time:tickCount/60, ttl:m.ttl??6, ...m}); }
function stepComms(dt){
  // Deliver intel to faction stores
  for(const m of comms){
    if(m.type==='CONTACT' && factions[m.faction]){
      const fac=factions[m.faction];
      if(!fac.intel) fac.intel=new Map();
      fac.intel.set(m.targetId, {pos:[...m.pos], t:tickCount/60});
    }else if(m.type==='LKL'){
      const ensureFac = typeof _ensureFaction === 'function'
        ? _ensureFaction
        : (globalThis.intel && globalThis.intel._ensureFaction);
      const finfo = ensureFac(m.faction);
      finfo.lastKnown.set(m.targetId, {pos:[...m.pos], t:m.t ?? tickCount/60});
    }
  }
  // decay
  comms = comms.filter(m=> (m.ttl-=dt) > 0);
}
const INTEL_TTL=8;
function intelPoint(fid, around=[0,0,0]){
  const fac=factions[fid]; if(!fac||!fac.intel) return null;
  let best=null, bd=1e9, now=tickCount/60;
  for(const [eid,info] of fac.intel.entries()){
    if(now - info.t > INTEL_TTL) continue;
    const d=calcDist(around, info.pos);
    if(d<bd){ bd=d; best=info.pos; }
  }
  return best;
}

/* ============================ DOCK SYSTEM ============================ */

function initDockCtrl(e){
  const caps = RTS_CFG.docks;
  const hCaps = RTS_CFG.hangars || {};
  let cap=0;
  if(e.type===T.Mother) cap = caps.mother;
  else if(e.type===T.Outpost) cap = caps.outpost;
  else if(e.type===T.Platform) cap = caps.platform;

  if(cap>0){
      e.dockCtrl = {
        cap,
        occ:[],              // docked & being serviced
        queue:makePQ(),      // inbound priority queue
        departQueue:makePQ(),// outbound priority queue [{id,priority,requestTime,nextMission}]
        ops:[],              // service ops (refuel/repair/deposit)
        departOps:[],        // pending undocks
        bays: Array.from({length:cap}, ()=>({unitId:null, phase:'Idle', t:0})),
        holdR: 7.0,          // hold ring radius
        slots: [],           // hold slot assignments
        finalR: 3.0,         // touchdown radius
        landingTime: 1.0,    // seconds to land
        undockTime: 0.8      // seconds to undock
      };
  }

  // Hangar controller for Mother and Outpost types
  let hCap = 0;
  if(e.type===T.Mother) hCap = hCaps.mother || 0;
  else if(e.type===T.Outpost) hCap = hCaps.outpost || 0;
  if(hCap>0){
    e.hangarCtrl = {
      cap: hCap,
      occ: [],             // units currently in hangar
      queue: makePQ(),     // inbound hangar queue
      ops: [],             // hangar service ops
      bays: Array.from({length:hCap}, ()=>({unitId:null, phase:'Idle', t:0}))
    };
  }
}
// Docking helpers and thresholds
const DOCK_THRESH = {
  lowFuel: RTS_CFG.thresholds.lowFuelUnit ?? RTS_CFG.thresholds.veryLowFuelUnit,
  repairHP: RTS_CFG.thresholds.repairHP ?? RTS_CFG.thresholds.retreatHP
};
const DOCK_TIMEOUT_TICKS = 8 * 60;

// Determine whether a unit actually needs to dock given the requested operations.
// Returns true if cargo should be deposited, fuel is critically low, HP needs repair,
// or ore must be loaded.
function needsDock(u, opts){
  const cargoFull = u.cargo && ((u.cargo.ore||0) + (u.cargo.fuel||0) >= u.cargo.cap);
  const needDeposit = opts.deposit || cargoFull;
  const fuelFrac = u.tank ? u.fuel / u.tank : 1;
  const needFuel = opts.refuel || (opts.loadFuel && fuelFrac <= DOCK_THRESH.lowFuel);
  const hpFrac = u.hpMax ? u.hp / u.hpMax : 1;
  const needRepair = opts.repair && hpFrac <= DOCK_THRESH.repairHP;
  const needLoadOre = !!opts.loadOre;
  return needDeposit || needFuel || needRepair || needLoadOre;
}

function dockBusyCount(s){
  if(!s?.dockCtrl) return 0;
  return s.dockCtrl.bays.filter(b=>b.phase==='Landing' || b.phase==='Service').length;
}
  function dockPriority(u){
    if(!u) return 0;
    if(u.type===T.Light || u.type===T.Heavy || u.type===T.EW) return 3;
    const th=RTS_CFG.thresholds;
    const fuelFrac = u.tank? u.fuel/u.tank : 1;
    const hpFrac = u.hpMax? u.hp/u.hpMax : 1;
    if(fuelFrac<=th.veryLowFuelUnit || hpFrac<=th.retreatHP) return 2;
    return 1;
  }
  function makePQ(){ return [[],[],[]]; }
  function pqPush(q, entry){ const p=Math.min(3, Math.max(1, entry.priority)); q[3-p].push(entry); }
  function pqContains(q, id){ return q[0].some(e=>e.id===id) || q[1].some(e=>e.id===id) || q[2].some(e=>e.id===id); }
  function pqShift(q){ for(let i=0;i<3;i++){ if(q[i].length) return q[i].shift(); } return null; }
  function pqLength(q){ return q[0].length+q[1].length+q[2].length; }
  function pqRemoveById(q,id){ for(let i=0;i<3;i++){ q[i]=q[i].filter(e=>e.id!==id); } }
  function enqueueDock(s, unitId){
    const q=s.dockCtrl.queue;
    const u=getById(unitId);
    if(!u) return;
    if(!pqContains(q, unitId)){
      const entry={id:unitId, priority:dockPriority(u), requestTime:tickCount};
      pqPush(q, entry);
    }
    if(u.dockIntent && u.dockIntent.slot==null){
      const slots=s.dockCtrl.slots;
      let idx=slots.findIndex(x=>x==null);
      if(idx===-1){ idx=slots.length; slots.push(unitId); }
      else slots[idx]=unitId;
      u.dockIntent.slot=idx;
    }
  }
  function enqueueHangar(s, unitId){
    const h=s.hangarCtrl; if(!h) return;
    if(pqContains(h.queue, unitId)) return;
    const u=getById(unitId);
    if(!u) return;
    const entry={id:unitId, priority:dockPriority(u), requestTime:tickCount};
    pqPush(h.queue, entry);
  }
  function enqueueDepart(s, unitId, nextMission){
    const q=s.dockCtrl.departQueue; if(!q) return;
    if(pqContains(q, unitId)) return;
    const u=getById(unitId);
    if(!u) return;
    const entry={id:unitId, priority:dockPriority(u), requestTime:tickCount, nextMission:nextMission||null};
    pqPush(q, entry);
  }
// Legacy release keeps occ list in sync
function releaseDock(s, unitId){ const d=s.dockCtrl; if(!d) return; d.occ = d.occ.filter(id=>id!==unitId); }
function releaseDockSlot(s, slot){ const d=s?.dockCtrl; if(!d?.slots) return; if(slot!=null && slot>=0 && slot<d.slots.length) d.slots[slot]=null; }

// Assign a fallback mission when docking is rejected
function resolveDockRejection(u, intent){
  if(intent?.slot!=null){ const s=getById(intent.storeId); if(s) releaseDockSlot(s, intent.slot); }
  if(u.type===T.Constructor){
    let kind;
    if(intent?.refuel || intent?.loadFuel){
      kind = EMISSION.MineFuel;
    }else if(intent?.loadOre){
      kind = EMISSION.MineOre;
    }else if(intent?.deposit){
      kind = chooseNextMineKind(u.faction);
    }else if(intent?.repair){
      kind = chooseNextMineKind(u.faction);
    }else{
      kind = EMISSION.Idle;
    }
    u.mission = {kind, nodeId:null};
  }else{
    u.mission = { type:MISSION.Patrol, point:pickPatrol(u.faction) };
  }
  u.dockIntent=null;
  u.blocker=null;
  u.intent=null;
}

// Ensure dock intent contacts ATC and exposes subtask
function ensureDockIntent(u, s, opts){
  if(!needsDock(u, opts)){
    resolveDockRejection(u, opts);
    sendComms({type:'ATC_REJECT', from:s.id, to:u.id, reason:'Dock unnecessary', ttl:4});
    return;
  }
  const d = calcDist(u.pos, s.pos);
  const callRange = Math.min((s.dockCtrl?.holdR || 7) * RTS_CFG.docks.callRange, s.radar);
  u.dockIntent = {
    storeId:s.id,
    state:'Hold',
    refuel:!!opts.refuel,
    repair:!!opts.repair,
    loadFuel:!!opts.loadFuel,
    loadOre:opts.loadOre||0,
    deposit:!!opts.deposit,
    nextMission:opts.nextMission||null,
    requestTick:tickCount,
    engineOff:false,
    pending:false
  };
  if(d>callRange){
    u.dockIntent.pending=true;
    u.intent = {kind:'DockApproach'};
    setSubtask(u,'ATC Approach',0.9);
    return;
  }
  u.intent = {kind:'DockQ'}; setSubtask(u,'ATC Queue',0.8);
  sendComms({ type:'ATC_REQUEST', from:u.id, to:s.id, faction:u.faction, ttl:4 });
  enqueueDock(s, u.id);
}

// Shared ATC docking behavior for units with a dockIntent
function handleDockIntent(e, dt){
  if(!e.dockIntent) return false;
  const s=getById(e.dockIntent.storeId);
  if(!s){
    const intent = e.dockIntent;
    e.dockIntent = null;
    const minFuel = e.type===T.Constructor? e.tank*0.5 : Math.max(20, e.tank*0.25);
    const replacement = (intent.refuel || intent.loadFuel || intent.repair)
      ? nearestStorageWithFuel(e.faction, e.pos, minFuel)
      : (intent.loadOre
         ? nearestStorage(e.faction, e.pos)
         : nearestStorageWithCapacity(e.faction, e.pos, e.cargo?.ore||0, e.cargo?.fuel||0));
    if(replacement) ensureDockIntent(e, replacement, intent);
    else resolveDockRejection(e, intent);
    return true;
  }
  const d = calcDist(e.pos, s.pos);
  const callRange = Math.min((s.dockCtrl?.holdR || 7) * RTS_CFG.docks.callRange, s.radar);
  if(e.dockIntent.pending){
    if(d>callRange){
      steerTo(e, s.pos, dt, 1.0, 'eco');
      setSubtask(e,'ATC Approach',0.9);
      return true;
    }
    e.dockIntent.pending=false;
    setSubtask(e,'ATC Queue',0.8);
    sendComms({ type:'ATC_REQUEST', from:e.id, to:s.id, faction:e.faction, ttl:4 });
  }
  if(!e.dockedAt){
    e.intent={kind:'DockQ'};
    enqueueDock(s, e.id);
    const phase = e.dockIntent.state || 'Hold';
    if(phase==='Landing'){
      steerTo(e, s.pos, dt, 0.9, 'eco');
      e.blocker=null; setSubtask(e,'ATC Landing',0.4);
    }else{
      const R = s.dockCtrl?.holdR || 6.5;
      const ang = (e.dockIntent.slot||0);
      const around = V.add(s.pos, [Math.cos(ang)*R,0,Math.sin(ang)*R]);
      const busy = dockBusyCount(s);
      if(e.dockIntent.holding && busy < s.dockCtrl.cap){
        e.dockIntent.holding = false;
        e.dockIntent.engineOff = false;
      }
      if(!e.dockIntent.holding && busy>=s.dockCtrl.cap && tickCount - (e.dockIntent.requestTick||0) > DOCK_TIMEOUT_TICKS){
        const minFuel = e.type===T.Constructor? e.tank*0.5 : Math.max(20, e.tank*0.25);
        const replacement = (e.dockIntent.refuel || e.dockIntent.loadFuel || e.dockIntent.repair)
          ? nearestStorageWithFuel(e.faction, e.pos, minFuel)
          : (e.dockIntent.loadOre
             ? nearestStorage(e.faction, e.pos)
             : nearestStorageWithCapacity(e.faction, e.pos, e.cargo?.ore||0, e.cargo?.fuel||0));
          if(replacement && replacement.id!==s.id){
            releaseDockSlot(s, e.dockIntent.slot);
            e.dockIntent.slot=null;
            pqRemoveById(s.dockCtrl.queue, e.id);
            ensureDockIntent(e, replacement, e.dockIntent);
            return true;
          }else{
          e.dockIntent.holding = true;
          e.dockIntent.engineOff = true;
        }
      }
      if(!e.dockIntent.holding){
        steerTo(e, around, dt, 1.0, 'eco');
        setSubtask(e,'ATC Hold',0.6);
      }else if(e.dockIntent.engineOff){
        e.vel=[0,0,0];
        setSubtask(e,'Holding (eng off)',0.6);
      }else{
        setSubtask(e,'ATC Hold',0.6);
      }
      e.blocker = (busy>=s.dockCtrl.cap) ? 'Dock busy' : null;
    }
  }
  return true;
}

/* ============================ SPAWNING ============================ */

function genWorld(){
  rng = RNG((RTS_CFG.world.startSeed||1337) + ((Math.random()*1e9)|0));
  Object.assign(world, { size:RTS_CFG.world.size, half:RTS_CFG.world.size/2 });
  const C=(lerp(RTS_CFG.resources.clusters)|0);
  for(let i=0;i<C;i++){
    const x=(rng()*2-1)*world.half*0.7, y=(rng()*2-1)*world.half*0.7, z=(rng()*2-1)*world.half*0.7;
    const n=(lerp(RTS_CFG.resources.perCluster)|0);
    const nf=(n*0.45 + rng()*4)|0;
    spawnResourceCluster([x,y,z], n-nf, false);
    spawnResourceCluster([x+3,y-2,z+1], nf, true);
  }
  clampMapCam();
}

function makeWeapon(key){
  const w = RTS_CFG.weapons[key];
  const usesAmmo = w.ammo && w.ammo.max > 0;
  const ammoSize = usesAmmo ? (w.ammo.mag || w.ammo.battery || w.ammo.size || 0) : Infinity;
  if(usesAmmo && w.ammo.size === undefined) w.ammo.size = ammoSize;
  return {
    key,
    cfg: w,
    cd: 0,
    range: w.range,
    rof: w.rof,
    dmg: w.dmg,
    type: w.type,
    projSpeed: w.projSpeed || 0,
    windup: w.windup || 0,
    // Default to 0 fuel per shot if unspecified so weapons can fire
    fuelPerShot: (w.fuelPerShot==null ? 0 : w.fuelPerShot),
    targetComputer: w.targetComputer,
    ammo: ammoSize,
    reserve: usesAmmo && w.ammo && w.ammo.max ? (w.ammo.max - 1) * ammoSize : 0,
    reloading: 0,
    charging: []
  };
}

function startRecharge(fac, w){
  const cost = w.cfg.reload || {};
  if(!w.cfg.energy) return false;
  if((cost.ore||0) > fac.ore) return false;
  if((cost.fuel||0) > fac.fuel) return false;
  fac.ore -= cost.ore || 0;
  fac.fuel -= cost.fuel || 0;
  return true;
}
function startReload(fac, w){
  const cost = w.cfg.reload || {};
  if(w.cfg.energy) return false;
  if(w.reloading > 0 || w.reserve <= 0) return false;
  if((cost.ore||0) > fac.ore) return false;
  if((cost.fuel||0) > fac.fuel) return false;
  fac.ore -= cost.ore || 0;
  fac.fuel -= cost.fuel || 0;
  w.reloading = cost.time || 0;
  return true;
}
function unitCfgByType(t){ const U=RTS_CFG.units; return t===T.Constructor?U.Constructor:t===T.EW?U.EW:t===T.Light?U.Light:t===T.Heavy?U.Heavy:null; }
function cfgForEntity(e){
  if(e.role==='Structure'){
    const B=RTS_CFG.buildings;
    return e.type===T.Outpost?B.CollectorOutpost:B.WeaponPlatform;
  }
  return unitCfgByType(e.type) || RTS_CFG.units.Mother;
}
function typeName(t){ return t===T.Constructor?'Constructor':t===T.EW?'EW':t===T.Light?'Light':t===T.Heavy?'Heavy':t===T.Outpost?'CollectorOutpost':t===T.Platform?'WeaponPlatform':t===T.Mother?'Mother':'Unknown'; }
function randAround(p,r){ return [p[0]+(rng()*2-1)*r, p[1]+(rng()*2-1)*r, p[2]+(rng()*2-1)*r]; }

function weaponCounts(arr){ const o={}; for(const k of arr){ o[k]=(o[k]||0)+1; } return o; }

function spawnFaction(fid){
  const side=fid===FRED? -1:1; const p=[side*world.half*0.6,0,0];
  const f=factions[fid]=makeFaction(fid,p,COLORS[fid]);
  const M=RTS_CFG.units.Mother;
  const mother=makeEntity({
    type:T.Mother,faction:fid,pos:[...p],vel:[0,0,0],
    hp:M.hp,hpMax:M.hp,arm:M.arm,fuel:M.tank,tank:M.tank,upkeep:M.upkeep,radar:M.radar,powerKw:M.powerKw,
    storage:{ore:M.storage.ore,fuel:M.storage.fuel,oreNow:0,fuelNow:0},
    weaponStore:f.weaponStore,
    ammoStore:f.ammoStore,
    weapons:M.weapons.map(makeWeapon), xp:0, xpCtrl:0, xpThrottle:0, team:-1, role:'Mother', goal:null, birth:tickCount,
    radarShareCount:0,
    station:null, hidden:false, flightMode:'Coupled',
    _anchor:null, _anchorT:0
  });
  mother.radarShare = true;
  mother.hasTargetComp = mother.weapons.some(w=>w.targetComputer);
  mother.fuelRange = calcFuelRange(mother);
  mother.radarShared = mother.radar;
  initDockCtrl(mother);
  markBuilt(fid,'Mother');
  f.structures.add(mother);
  for(let i=0;i<4;i++) spawnUnit(fid,T.Constructor);
  // Ensure all starting combat units spawn with SMGs
  for(let i=0;i<2;i++) spawnUnit(fid,T.Light,["SMG"]);
  spawnUnit(fid,T.EW,["SMG"]);
}

function spawnUnit(fid,t,desired){
  const cfg=unitCfgByType(t); if(!cfg) return null;
  const fac=factions[fid];
  const mother = getMother(fid);
  let weaponList = desired || cfg.weapons || [];
  if(!desired && (t===T.Light || t===T.EW) && cfg.weaponOptions){
    const idx = (Math.random() * cfg.weaponOptions.length) | 0;
    weaponList = [cfg.weaponOptions[idx]];
  }
  const weapons=weaponCounts(weaponList);
  const loadout={weapons, radar:cfg.radar?1:0, power:cfg.powerKw?1:0};
  fac.logistics.produce([loadout]);
  const clsMap={ [T.EW]:'E', [T.Light]:'L', [T.Heavy]:'H', [T.Constructor]:'L' };
  const u=fac.logistics.spawn(loadout,{cls:clsMap[t]||'L', allowFallback:true});
  const needsWeapon = (t!==T.Constructor);
  if(!u || (needsWeapon && (!u.weapons || u.weapons.length===0))){
    if(t===T.Constructor){
      // Fallback: Constructors are utility units; spawn without weapons.
      const cargoCap = cfg.tank*cfg.fuelCargoFactor;
      const e=makeEntity({
        type:t,faction:fid,pos:[...mother.pos],vel:[0,0,0],hp:cfg.hp,hpMax:cfg.hp,arm:cfg.arm,
        fuel:cfg.tank*0.85,tank:cfg.tank,upkeep:cfg.upkeep,radar:cfg.radar||0,powerKw:cfg.powerKw||0,
        weapons:[], xp:0, xpCtrl:0, xpThrottle:0, team:-1, role:'Constructor', goal:null, birth:tickCount,
        radarShareCount:0,
        cargo:{ ore:0, fuel:0, cap:cargoCap },
        mine: cfg.mine ? { ...cfg.mine } : { oreRate:0, fuelRate:0 },
        hidden:false, flightMode:'Coupled'
      });
      e.fuelRange = calcFuelRange(e);
      e.radarShared = e.radar;
      markBuilt(fid, 'Constructor');
      factions[fid].units.add(e);
      return e;
    } else {
      console.warn('spawnUnit: insufficient equipment for', typeName(t));
      // ensure production request remains queued
      fac.logistics.produce([loadout]);
      return null;
    }
  }
  const cargoCap = t===T.Constructor? cfg.tank*cfg.fuelCargoFactor:0;
  const e=makeEntity({
    type:t,faction:fid,pos:[...mother.pos],vel:[0,0,0],hp:cfg.hp,hpMax:cfg.hp,arm:cfg.arm,
    fuel:cfg.tank*0.85,tank:cfg.tank,upkeep:cfg.upkeep,radar:cfg.radar,powerKw:cfg.powerKw,
    weapons:u.weapons.map(w=>{
      const wEnt=makeWeapon(w.key);
      wEnt.ammo=w.ammo;
      wEnt.reserve=w.reserve;
      wEnt.reloading=w.reloading;
      wEnt.charging=[...w.charging];
      if(w.targetComputer) wEnt.targetComputer=w.targetComputer;
      return wEnt;
    }),
    xp:0, xpCtrl:0, xpThrottle:0, team:-1, role:t===T.Constructor?'Constructor':'Combat',
    radarShareCount:0,
    cargo:{ ore:0,fuel:0,cap:cargoCap },
    mine:cfg.mine||null, jammer:cfg.jammer||null, order:null, lastHitT:0, birth:tickCount,
    mission: (t===T.Constructor? {kind:EMISSION.MineFuel, nodeId:null} : null),
    blocker:null, intent:null, hidden:true, dockIntent:null, dockedAt:mother.id, buildTimer:0,
    flightMode:'Coupled'
  });
  e.components = u.components;
  e.hasTargetComp = e.weapons.some(w=>w.targetComputer);
  e.radarShare = cfg.radarShare !== undefined ? cfg.radarShare : true;
  e.radarShared = e.radar;
  e.radarShareCount = 0;
  markBuilt(fid, typeName(t));
  factions[fid].units.add(e);
  e.fuelRange = calcFuelRange(e);

  // Register as docked and queue for hangar service/launch
  const d = mother.dockCtrl;
  if(d && !d.occ.includes(e.id)) d.occ.push(e.id);
  enqueueHangar(mother, e.id);

  return e;
}

function buildStructure(fid,kind,atPos){
  const B=RTS_CFG.buildings, cfg=(kind===T.Outpost)?B.CollectorOutpost:B.WeaponPlatform;
  const fac=factions[fid];
  const weapons=weaponCounts(cfg.weapons||[]);
  const loadout={weapons, radar:1, power:1};
  fac.logistics.produce([loadout]);
  const u=fac.logistics.spawn(loadout,{cls:'H', allowFallback:true, allowMulti:true});
  const wlist=u?u.weapons.map(w=>{
    const wEnt=makeWeapon(w.key);
    wEnt.ammo=w.ammo; wEnt.reserve=w.reserve; wEnt.reloading=w.reloading; wEnt.charging=[...w.charging];
    if(w.targetComputer) wEnt.targetComputer=w.targetComputer;
    return wEnt;
  }):[];
  const comps=u?u.components:{radar:[], power:[], weapons:[], batteries:[], magazines:[]};
  const s=makeEntity({
    type:kind,faction:fid,pos:[...atPos],vel:[0,0,0],
    hp:cfg.hp,hpMax:cfg.hp,arm:cfg.arm, fuel:(cfg.storage.fuel*0.3), tank:cfg.storage.fuel, upkeep:0.0125, radar:28,powerKw:cfg.powerKw,
    weapons:wlist,
    components:comps,
    storage:{ ore:cfg.storage.ore, fuel:cfg.storage.fuel, oreNow:0, fuelNow:cfg.storage.fuel*0.3 },
    weaponStore:{count:0, cap:weaponCap},
    ammoStore:{count:0, cap:ammoCap},
    xp:0,xpCtrl:0,xpThrottle:0,team:-1,role:'Structure',goal:null,birth:tickCount, hidden:false,
    radarShareCount:0
  });
  s.radarShare = true;
  s.hasTargetComp = s.weapons.some(w=>w.targetComputer);
  s.fuelRange = calcFuelRange(s);
  s.radarShared = s.radar;
  initDockCtrl(s);
  if(kind===T.Outpost && s.storage){ getFaction(fid).fuel += s.storage.fuelNow||0; }
  markBuilt(fid, kind===T.Outpost?'CollectorOutpost':'WeaponPlatform');
  spawnExplosion(atPos, 1.4);
  factions[fid].structures.add(s);
  return s;
}

/* ============================ TEAMING, STORAGE HELPERS ============================ */

// D) Stable regrouping (reuse surviving teams to prevent rubber-banding)
function regroupTeams(){
  const prev = new Map(teams.map(t=>[t.id,t]));
  teams.length=0;

  for(const fid of [FRED,FBLU]){
    const fac=factions[fid];
    const combat=[...fac.units].filter(e=>(e.type===T.EW||e.type===T.Light||e.type===T.Heavy) && !e.hidden);
    combat.forEach(u=>u.team=-1);

    // Reuse old teams that still have >=2 living members
    const assigned=new Set();
    for(const old of prev.values()){
      if(old.faction!==fid) continue;
      const mem = old.members.map(getById).filter(u=>u && !u.hidden);
      if(mem.length>=2){
        const tid=teams.push({ ...old, id:teams.length, members:mem.map(u=>u.id) })-1;
        mem.forEach(u=>{u.team=tid; assigned.add(u.id);});
      }
    }

    // Create new teams from leftovers
    const remain = combat.filter(u=>!assigned.has(u.id))
                         .sort((a,b)=>calcDist(a.pos,factions[fid].origin)-calcDist(b.pos,factions[fid].origin));
    for(let i=0;i<remain.length;i+=3){
      const group=remain.slice(i,i+3); if(group.length<2) break;
      const tid=teams.push({
        id:teams.length,faction:fid,members:group.map(u=>u.id),leader:group[0].id,
        mission:{ type:MISSION.Patrol, point:pickPatrol(fid) }, lastPlan:0, formation:true, currentTarget:null,
        avgRange:0, sharedRadar:0, radarShareCount:0, hasTargetComp:false,
        targetCompCount:0, avgTargetComp:0,
        avgXP:0, avgXpCtrl:0, avgXpThrottle:0, avgSignature:0
      })-1;
      group.forEach(u=>u.team=tid);
    }
  }
}

function getFaction(fid){ return factions[fid]; }
function getMother(fid){
  const f=factions[fid]; if(!f) return null;
  for(const s of f.structures){ if(s.type===T.Mother) return s; }
  return null;
}
function storagesOf(fid){
  const f=factions[fid]; if(!f) return [];
  return [...f.structures].filter(e=> (e.type===T.Mother||e.type===T.Outpost||e.type===T.Platform));
}
function nearestStorage(fid,pos){ const ss=storagesOf(fid); let best=null,bd=1e9; for(const s of ss){ const d=calcDist(s.pos,pos); if(d<bd){bd=d;best=s;} } return best; }
function storageAvailableFuel(s){
  const f=getFaction(s.faction);
  if(s.storage) return Math.min(f.fuel, s.storage.fuelNow||0);
  return f.fuel;
}
function storageFreeOre(s){ if(s.type===T.Mother) return Infinity; return s.storage ? Math.max(0, s.storage.ore - (s.storage.oreNow||0)) : 0; }
function storageFreeFuel(s){ if(!s.storage) return Infinity; return Math.max(0, s.storage.fuel - (s.storage.fuelNow||0)); }
function storageTakeOre(s, amount){
  if(amount<=0) return 0;
  if(s.type===T.Mother){
    const f=getFaction(s.faction);
    const avail = f.ore;
    const q = Math.min(amount, avail);
    if(amount > avail) console.warn('storageTakeOre: requested', amount, 'but only', avail, 'available for faction', s.faction);
    f.ore = Math.max(0, avail - q);
    return q;
  }
  else if(s.storage){
    const avail = s.storage.oreNow||0;
    const q = Math.min(amount, avail);
    if(amount > avail) console.warn('storageTakeOre: requested', amount, 'but only', avail, 'available in storage', s.id);
    s.storage.oreNow = Math.max(0, avail - q);
    return q;
  }
  return 0;
}
function storageTakeFuel(s, amount){
  if(amount<=0) return 0;
  if(s.type===T.Mother){
    const f=getFaction(s.faction);
    const avail = f.fuel;
    const q = Math.min(amount, avail);
    if(amount > avail) console.warn('storageTakeFuel: requested', amount, 'but only', avail, 'available for faction', s.faction);
    f.fuel = Math.max(0, avail - q);
    return q;
  }
  else if(s.storage){
    const f=getFaction(s.faction);
    const avail = s.storage.fuelNow||0;
    const q = Math.min(amount, avail);
    if(amount > avail) console.warn('storageTakeFuel: requested', amount, 'but only', avail, 'available in storage', s.id);
    s.storage.fuelNow = Math.max(0, avail - q);
    f.fuel = Math.max(0, f.fuel - q);
    return q;
  }
  return 0;
}
function storageGiveFuel(s, amount){
  if(amount<=0) return 0;
  if(s.type===T.Mother){ const f=getFaction(s.faction); f.fuel += amount; return amount; }
  else if(s.storage){
    const f=getFaction(s.faction);
    const space = s.storage.fuel - (s.storage.fuelNow||0);
    const q = Math.min(space, amount);
    if(amount > space) console.warn('storageGiveFuel overflow', {id:s.id, amount, space});
    s.storage.fuelNow = (s.storage.fuelNow||0) + q;
    f.fuel += q;
    return q;
  }
  return 0;
}
function storageGiveOre(s, amount){
  if(amount<=0) return 0;
  if(s.type===T.Mother){ const f=getFaction(s.faction); f.ore += amount; return amount; }
  if(s.storage){ const space = s.storage.ore - (s.storage.oreNow||0); const q=Math.min(space,amount); if(amount > space) console.warn('storageGiveOre overflow', {id:s.id, amount, space}); s.storage.oreNow=(s.storage.oreNow||0)+q; return q; }
  return 0;
}
function nearestStorageWithFuel(fid,pos, minNeed=10){
  const ss=storagesOf(fid);
  let best=null,bd=1e9;
  for(const s of ss){
    const avail = storageAvailableFuel(s);
    if(avail <= RTS_CFG.economy.logistics.minStorageReserve && s.type!==T.Mother) continue;
    const d=calcDist(s.pos,pos); if(d<bd){bd=d;best=s;}
  }
  if(!best){ const m=getMother(fid); if(getFaction(fid).fuel>0) best=m; }
  return best;
}
function nearestStorageWithCapacity(fid,pos, oreNeed, fuelNeed){
  const fieldStorages = storagesOf(fid).filter(s=>s.type!==T.Mother);
  let best=null,bd=1e9;
  for(const s of fieldStorages){
    const freeOre=storageFreeOre(s), freeFuel=storageFreeFuel(s);
    if(oreNeed>0 && freeOre<=0) continue;
    if(fuelNeed>0 && freeFuel<=0) continue;
    const d=calcDist(s.pos,pos); if(d<bd){bd=d;best=s;}
  }
  if(best) return best;
  const m=getMother(fid);
  if(!m) return null;
  const mFreeOre=storageFreeOre(m), mFreeFuel=storageFreeFuel(m);
  if(oreNeed>0 && mFreeOre<=0) return null;
  if(fuelNeed>0 && mFreeFuel<=0) return null;
  return m;
}

/* ===== Fuel Rationing Helpers ===== */
function totalFuelAcrossStorages(fid){
  return getFaction(fid).fuel;
}
function eligibleUnitsForRefuel(fid){
  const f=factions[fid]; if(!f) return [];
  return [...f.units].filter(e=>!e.hidden && e.hp>0 && (e.tank||0)>0 && e.fuel < e.tank-1);
}
function updateFuelRationing(){
  for(const fid of [FRED,FBLU]){
    const elig = eligibleUnitsForRefuel(fid);
    const need = elig.reduce((a,u)=>a + Math.max(0, u.tank - u.fuel), 0);
    const avail = totalFuelAcrossStorages(fid);
    const avg = avail / Math.max(1, elig.length);
    const f = factions[fid];
    f.ration.eligible = elig.length;
    f.ration.needToTopOff = need;
    f.ration.active = (avail < need && avg < RTS_CFG.thresholds.lowFuelTeamAvg && need > 0);
  }
}

/* ============================ CLUSTERS / CAMERA ============================ */

function clusterCenterNear(pos){
  let best=null, bd=1e9;
  for(const r of resources){ if(r.cap<=50) continue; const d=calcDist(pos,r.pos); if(d<bd){bd=d;best=r;} }
  if(!best) return null;
  const R=18; let cx=0,cy=0,cz=0,c=0;
  for(const r of resources){ if(calcDist(best.pos,r.pos)<=R && r.cap>30){ cx+=r.pos[0]; cy+=r.pos[1]; cz+=r.pos[2]; c++; } }
  if(!c) return best.pos;
  return [cx/c, cy/c, cz/c];
}

/* ============================ MISSIONS (COMBAT) ============================ */

function decideMission(tm){
  const fid=tm.faction;
  const comp=teamComp(tm);
  const intelReady = tm.radarShareCount>0 || (tm.avgTargetComp||0) > 0;
  const experienced = (tm.avgXpThrottle||0) > 5;
  const stealthy = (tm.avgSignature||0) < 25;

  const defend = nearestThreatened(fid);
  if(defend){ return { type:MISSION.Defend, defendId:defend.id }; }

  const escort = pickEscort(fid);
  if(escort){ return { type:MISSION.Escort, escortId:escort }; }

  const buildGate = ([...factions[fid].units].filter(x=>!x.hidden).length < RTS_CFG.economy.buildUp.minCombat);
  if(buildGate){ return { type:MISSION.Patrol, point:pickPatrol(fid) }; }

  const canSiege = comp.heavy>=RTS_CFG.ai.siegeMinHeavies && intelReady && experienced;
  if(canSiege){
    const siegeT = pickSiegeTarget(fid);
    if(siegeT) return { type:MISSION.Siege, targetId:siegeT };
  }

  const econBehind = (factions[fid].kpi.oreRate + factions[fid].kpi.fuelRate) < (factions[1-fid].kpi.oreRate + factions[1-fid].kpi.fuelRate);
  if(econBehind && (comp.ew>0 || !RTS_CFG.ai.harassNeedEW) && intelReady && stealthy){
    const h = pickHarassTarget(fid);
    if(h) return { type:MISSION.Harass, area:h.pos };
  }

  const contacts = intelReady ? visibleContacts(fid) : [];
  if(contacts.length && experienced && (comp.light>=RTS_CFG.ai.sadMinLights || comp.heavy>0 || comp.ew>0)){
    const best = contacts[ (contacts.length*0.5)|0 ] || contacts[0];
    return { type:MISSION.SAD, point:best.pos };
  }
  return { type:MISSION.Patrol, point:pickPatrol(fid) };
}

function teamComp(tm){ const c={ew:0,light:0,heavy:0}; for(const id of tm.members){ const u=getById(id); if(!u) continue; if(u.type===T.EW) c.ew++; if(u.type===T.Light) c.light++; if(u.type===T.Heavy) c.heavy++; } return c; }
function nearestThreatened(fid){
  const assets = [getMother(fid), ...[...factions[fid].structures].filter(e=>e.type===T.Outpost||e.type===T.Platform)];
  let best=null, bd=1e9;
  const enemy=[...factions[1-fid].units, ...factions[1-fid].structures];
  for(const a of assets){
    for(const t of enemy){
      if(t.hidden) continue;
      if(!(t.type===T.EW||t.type===T.Light||t.type===T.Heavy)) continue;
      const d=calcDist(a.pos,t.pos);
      if(d<RTS_CFG.ai.defendRadius && d<bd){ bd=d; best=a; }
    }
  }
  return best;
}
function visibleContacts(fid){
  const f=factions[fid], enemyF=factions[1-fid];
  const me=[...f.units, ...f.structures].filter(e=>!e.hidden);
  const enemies=[...enemyF.units, ...enemyF.structures].filter(e=>!e.hidden && (e.type===T.EW||e.type===T.Light||e.type===T.Heavy||e.type===T.Platform||e.type===T.Outpost||e.type===T.Mother));
  const out=[]; for(const m of me){ for(const t of enemies){ if(visible(m,t)) out.push(t); } }
  const uniq=new Map(); for(const t of out){ uniq.set(t.id,t); } return [...uniq.values()];
}
function teamLeader(tm){ return getById(tm.leader) || getById(tm.members[0]); }
function teamCentroid(tm){ let x=0,y=0,z=0,c=0; for(const id of tm.members){ const u=getById(id); if(!u||u.hidden) continue; x+=u.pos[0]; y+=u.pos[1]; z+=u.pos[2]; c++; } return c?[x/c,y/c,z/c]:[0,0,0]; }
function pickPatrol(fid){
  const me=getMother(fid), them=getMother(1-fid);
  const dir=V.norm(V.sub(them.pos,me.pos));
  const base=V.add(me.pos, V.mul(dir, 26 + Math.random()*10));
  return randAround(base, 8);
}
function frontlinePoint(fid){
  const me=getMother(fid), them=getMother(1-fid);
  const mid=[ (me.pos[0]+them.pos[0])/2, 0, 0 ];
  return randAround(mid, 10);
}
function enemyHalf(fid){ const s= (1-fid)===FRED? -1:1; return [s*world.half*0.35, 0, 0]; }
function pickEscort(fid){
  const cons=[...factions[fid].units].filter(e=>e.type===T.Constructor && !e.hidden && e.mission && (e.mission.kind===EMISSION.DeliverFuel_Load || e.mission.kind===EMISSION.DeliverFuel_Travel || e.mission.kind===EMISSION.ReturnDeposit));
  if(cons.length){ cons.sort((a,b)=>calcDist(a.pos, getMother(fid).pos)-calcDist(b.pos, getMother(fid).pos)); return cons[0].id; }
  return null;
}
function pickSiegeTarget(fid){
  const enemy=[...factions[1-fid].structures].filter(e=>!e.hidden && (e.type===T.Outpost||e.type===T.Platform));
  if(!enemy.length) return getMother(1-fid).id;
  const mid=frontlinePoint(fid);
  enemy.sort((a,b)=>calcDist(a.pos,mid)-calcDist(b.pos,mid));
  return enemy[0].id;
}
function pickHarassTarget(fid){
  let pool=[...factions[1-fid].units, ...factions[1-fid].structures].filter(e=>!e.hidden && (e.type===T.Constructor || e.type===T.Outpost));
  if(!pool.length) pool=[...factions[1-fid].structures].filter(e=>!e.hidden && (e.type===T.Platform));
  if(!pool.length) return null;
  pool.sort((a,b)=> (a.type===T.Constructor?-1:1) - (b.type===T.Constructor?-1:1));
  return pool[0];
}

/* ============================ KPI / BUILD ============================ */

function smoothRate(hist,val){ hist.push(val); if(hist.length>120) hist.shift(); let s=0; for(const v of hist) s+=v; return s/hist.length; }
function computeFP(fid){
  const us=[...factions[fid].units].filter(e=> (e.type===T.EW||e.type===T.Light||e.type===T.Heavy) && !e.hidden);
  let fp=0; for(const u of us){ let dps=0; for(const w of (u.weapons||[])) dps+=w.dmg*w.rof; const ammoOK=(u.fuel>u.tank*0.2)?1.0:0.6; const ehp=u.hp/(1-Math.min(0.9,u.arm)); fp += Math.sqrt(ehp)*(0.5+0.5*Math.sqrt(dps))*ammoOK; }
  return fp;
}
function computeAM(att,def){ const FP_us=att.kpi.FP||1, FP_them=computeFP(def.fid)||1; const distM=calcDist(getMother(att.fid).pos, getMother(def.fid).pos); const distFactor=1/(1+distM/60); return (FP_us/FP_them)*distFactor; }
function pickPosture(fid){
  const f=factions[fid], e=factions[1-fid];
  f.kpi.FP=computeFP(fid);
  const oreSm=smoothRate(f.oreHist,f.ore), fuelSm=smoothRate(f.fuelHist,f.fuel);
  f.kpi.oreRate=f.ore-oreSm; f.kpi.fuelRate=f.fuel-fuelSm;
  const AM=computeAM(f,e), th=RTS_CFG.ai.posture;
  let p = ([...factions[fid].units].filter(x=>!x.hidden).length >= RTS_CFG.economy.buildUp.minCombat &&
           f.ore>=RTS_CFG.economy.buildUp.minOre && f.fuel>=RTS_CFG.economy.buildUp.minFuel) ? 'Expand' : 'BuildUp';
  if(p==='Expand'){
    if(AM<th.thetaAM_low) p='Harass';
    if(AM>=th.thetaAM_low && f.kpi.FP < e.kpi.FP*th.thetaFP_equalize) p='Equalize';
    if(AM>=th.thetaAM_exec && f.kpi.FP >= e.kpi.FP*th.thetaFP_execute) p='Execute';
  }
  f.kpi.lastPosture=f.kpi.posture; f.kpi.posture=p;
}

function canAfford(fid,t){ const c=RTS_CFG.economy.costs[typeName(t)]; const f=getFaction(fid); return c && f.ore>=c.ore && f.fuel>=c.fuel; }
function spend(fid,t){
  const c=RTS_CFG.economy.costs[typeName(t)];
  const f=getFaction(fid);
  if(c.ore > f.ore) console.warn('spend: ore deficit', { fid, cost:c.ore, available:f.ore });
  if(c.fuel > f.fuel) console.warn('spend: fuel deficit', { fid, cost:c.fuel, available:f.fuel });
  f.ore = Math.max(0, f.ore - c.ore);
  f.fuel = Math.max(0, f.fuel - c.fuel);
  f.stats.oreSpent += c.ore;
  f.stats.fuelSpent += c.fuel;
}
function enqueueBuild(fid,t,where){
  const c=RTS_CFG.economy.costs[typeName(t)]; if(!c) return;
  const isStruct=(t===T.Outpost||t===T.Platform);
  const job={ id:idAlloc++, t, time:c.buildTime, pos:where?[...where]:null, stage:isStruct?'awaitConstructor':'countdown', assigned:null };
  getFaction(fid).buildQ.push(job);
  if(isStruct){
    const f=getFaction(fid);
    if(c.fuel > f.fuel) console.warn('spend: fuel deficit', { fid, cost:c.fuel, available:f.fuel });
    f.fuel = Math.max(0, f.fuel - c.fuel);
    f.stats.fuelSpent += c.fuel;
  }else{
    spend(fid,t);
  }
}

/* === Aggressive eco & unit building === */
function macroBuild(fid){
  const f=getFaction(fid), p=f.kpi.posture, afford=t=>canAfford(fid,t);
  const consCnt = [...f.units].filter(e=>e.type===T.Constructor && !e.hidden).length;
  const combatCnt = [...f.units].filter(e=> (e.type===T.EW||e.type===T.Light||e.type===T.Heavy) && !e.hidden).length;

  // Maintain more Constructors aggressively
  const consTarget = Math.max(RTS_CFG.economy.buildUp.minConstructors+2, Math.ceil(combatCnt/3));
  while(consCnt + (f.buildQ.filter(j=>j.t===T.Constructor).length) < consTarget && afford(T.Constructor)){
    enqueueBuild(fid,T.Constructor);
  }

  // Early Outposts near clusters
  const m = getMother(fid), cc = clusterCenterNear(m.pos);
  if(cc && f.ore>180 && f.fuel>180){
    const existNear = [...f.structures].some(e=> (e.type===T.Outpost||e.type===T.Platform) && calcDist(e.pos,cc)<16);
    if(!existNear && afford(T.Outpost)) enqueueBuild(fid, T.Outpost, cc);
  }

  // Platforms on frontline
  if((p==='Equalize'||p==='Execute') && f.ore>260 && f.fuel>260 && afford(T.Platform)) enqueueBuild(fid,T.Platform, frontlinePoint(fid));

  // Combat spam
  const spamLight = ()=>{ if(afford(T.Light)) enqueueBuild(fid,T.Light); };
  const spamEW    = ()=>{ if(afford(T.EW)) enqueueBuild(fid,T.EW); };
  const spamHeavy = ()=>{ if(afford(T.Heavy)) enqueueBuild(fid,T.Heavy); };

  if(p==='BuildUp'||p==='Expand'){ spamLight(); spamEW(); spamLight(); }
  if(p==='Harass'){ spamEW(); spamLight(); }
  if(p==='Equalize'||p==='Execute'){ spamHeavy(); spamLight(); }
}

function stepWeaponProduction(dt){
  for(const f of factions){
    if(!f) continue;
    const queue=[];
    for(const job of f.buildQ){
      const cfg=unitCfgByType(job.t);
      if(!cfg) continue;
      const weapons=weaponCounts(cfg.weapons||[]);
      const radar=cfg.radar?1:0;
      const power=cfg.powerKw?1:0;
      queue.push({weapons, radar, power});
    }
    if(queue.length) f.logistics.produce(queue);
  }
}

function processBuildQueues(dt){
  for(const f of factions){ if(!f) continue;
    if(!f.buildQ.length){ macroBuild(f.fid); continue; }
    const job=f.buildQ[0];

    if(job.stage==='countdown'){
      const ms = getMother(f.fid);
      if(ms && ms.hangarCtrl){
        const h = ms.hangarCtrl;
        if(h.occ.length + pqLength(h.queue) >= h.cap) continue;
      }
      job.time-=dt;
      if(job.time<=0){
        if(job.t===T.Platform||job.t===T.Outpost){
          buildStructure(f.fid, job.t, job.pos||randAround(getMother(f.fid).pos, 18));
          f.buildQ.shift();
        } else {
          const u = spawnUnit(f.fid, job.t);
          if(u){
            f.buildQ.shift();
          } else {
            // retry after a short delay to allow production to catch up
            job.time = 1;
          }
        }
      }
      continue;
    }

    if(job.stage==='awaitConstructor'){
      let best=null,bd=1e9;
      for(const e of entities){
        if(e.faction!==f.fid || e.type!==T.Constructor || e.hidden) continue;
        if(e.mission && (e.mission.kind===EMISSION.BuildOutpost||e.mission.kind===EMISSION.BuildPlatform||e.mission.kind===EMISSION.BuildOutpost_Load||e.mission.kind===EMISSION.BuildPlatform_Load)) continue;
        const d=calcDist(e.pos, job.pos||getMother(f.fid).pos);
        if(d<bd){bd=d;best=e;}
      }
      if(best){
        const cst = RTS_CFG.economy.costs[typeName(job.t)];
        const loadKind = (job.t===T.Outpost)?EMISSION.BuildOutpost_Load:EMISSION.BuildPlatform_Load;
        const s = nearestStorage(f.fid, best.pos);
        best.mission = { kind:loadKind, pos:[...(job.pos||randAround(getMother(f.fid).pos, 16))], buildTime:cst.buildTime, jobId:job.id, oreCost:cst.ore, storeId:s?s.id:null };
        job.assigned = best.id;
        job.stage='underConstruction';
      }
      continue;
    }

    if(job.stage==='underConstruction'){
      const worker = getById(job.assigned);
      if(!worker){ f.buildQ.shift(); continue; }
    }
  }
}

/* ============================ LOGISTICS / FUEL TICKETS ============================ */

function updateLowFuelStatus(u){
  if(!u || !u.tank) return;
  const f = getFaction(u.faction);
  const th = RTS_CFG.thresholds.lowFuelUnit;
  const isLow = u.fuel > 0 && u.fuel < u.tank*th;
  const idx = f.lowFuel.findIndex(x=>x.id===u.id);
  const tracked = idx>=0;
  if(isLow && !tracked && !f.fuelReq.has(u.id)){
    f.lowFuel.push({ratio:u.fuel/u.tank, id:u.id});
    f.lowFuel.sort((a,b)=> (a.ratio-b.ratio) || (a.id-b.id));
    ensureFuelDeliveries(u.faction);
  }else if(!isLow && tracked){
    f.lowFuel.splice(idx,1);
    ensureFuelDeliveries(u.faction);
  }else if(isLow && tracked){
    f.lowFuel[idx].ratio = u.fuel/u.tank;
    f.lowFuel.sort((a,b)=> (a.ratio-b.ratio) || (a.id-b.id));
  }
  // keep cached fuel range in sync with fuel levels
  u.fuelRange = calcFuelRange(u);
}

function ensureFuelDeliveries(fid=null){
  const fids = fid!=null ? [fid] : [FRED,FBLU];
  for(const fID of fids){
    const f = getFaction(fID);
    if(!f.lowFuel.length) continue;
    f.lowFuel.sort((a,b)=> (a.ratio-b.ratio) || (a.id-b.id));
    const cons = [...f.units].filter(e=>e.type===T.Constructor && !e.hidden);
    const used=new Set();
    for(let i=0;i<f.lowFuel.length;){
      const entry=f.lowFuel[i];
      const u=getById(entry.id);
      if(!u || u.hidden || u.fuel>=u.tank*RTS_CFG.thresholds.lowFuelUnit || f.fuelReq.has(u.id)){
        f.lowFuel.splice(i,1); continue;
      }
      const needed=Math.max(2.5,(u.tank-u.fuel)*0.25);
      const s=nearestStorageWithFuel(fID,u.pos,needed);
      if(!s){ i++; continue; }
      const cand=[];
      for(const c of cons){
        if(used.has(c.id)) continue;
        if(c.mission && (c.mission.kind===EMISSION.DeliverFuel_Load || c.mission.kind===EMISSION.DeliverFuel_Travel || c.mission.kind===EMISSION.BuildOutpost || c.mission.kind===EMISSION.BuildPlatform || c.mission.kind===EMISSION.BuildOutpost_Load || c.mission.kind===EMISSION.BuildPlatform_Load)) continue;
        const carried=(c.cargo?.ore||0)+(c.cargo?.fuel||0);
        if(carried>1){
          if(!c.mission || c.mission.kind!==EMISSION.ReturnDeposit){ c.mission={kind:EMISSION.ReturnDeposit}; }
          continue;
        }
        const free=c.cargo?(c.cargo.cap-carried):0;
        if(free<needed) continue;
        cand.push(c);
      }
      if(!cand.length){ i++; continue; }
      cand.sort((a,b)=> (calcDist(a.pos,u.pos)-calcDist(b.pos,u.pos)) || (a.id-b.id));
      const best=cand[0];
      best.mission={kind:EMISSION.DeliverFuel_Load, target:u.id, storeId:s.id};
      best.blocker=null;
      f.fuelReq.set(u.id,best.id);
      used.add(best.id);
      f.lowFuel.splice(i,1);
    }
  }
}

function clearFuelTicket(fid, unitId, consId){
  const f=getFaction(fid);
  if(f.fuelReq.get(unitId)===consId) f.fuelReq.delete(unitId);
  ensureFuelDeliveries(fid);
}

/* ============================ FLIGHT MODES ============================ */

function chooseFlightMode(e, context){
  const inCombat = (context==='combat');
  const xpNorm = clamp((e.xp||0)/(RTS_CFG.dodge.xpMax||100),0,1);
  const lowFuelPenalty = (e.fuel<e.tank*RTS_CFG.thresholds.lowFuelUnit)?0.1:0.0;
  const score = xpNorm + (inCombat?0.25:0.0) - lowFuelPenalty;
  const prev = e.flightMode || 'Coupled';
  const wasDec = (prev === 'Decoupled');
  const thOn  = wasDec ? 0.50 : 0.62;
  e.flightMode = (score > thOn) ? 'Decoupled' : 'Coupled';
  return e.flightMode;
}


/* ============================ FX (THRUSTERS & EXPLOSIONS) ============================ */

function addThruster(pos, dir, intensity, sizeMul=1, mode='burn'){
  if(intensity<=0) return; // emit only when firing
  let n, lifeBase, lifeVar, max;
  if(mode==='burn'){
    n = Math.ceil(2 + intensity*4);
    // Shorter tails, faster burn
    lifeBase = 0.35; lifeVar = 0.18; max = 0.6;
  }else{ // burst
    n = Math.ceil(1 + intensity*0.5);
    lifeBase = 0.075; lifeVar = 0.035; max = 0.35;
  }
  for(let i=0;i<n;i++){
    const jitter = V.add(dir, V.mul(randInUnitDiskPerp(dir), 0.22));
    // Emit particles along nozzle direction (behind the unit)
    const vel = V.mul(jitter, (24 + 50*Math.random()) * (0.45+0.9*intensity));
    fx.push({ type:'thr', pos:[pos[0],pos[1],pos[2]], vel,
              life:lifeBase+Math.random()*lifeVar, max,
              size:(0.5 + 0.4*intensity) * sizeMul });
  }
}
function spawnExplosion(atPos, scale=1){
  const count = Math.ceil(24*scale);
  for(let i=0;i<count;i++){
    const dir = randInUnitDiskPerp([0,1,0]);
    const vel = V.mul(dir, (60+120*Math.random())*scale);
    fx.push({ type:'exp', pos:[atPos[0],atPos[1],atPos[2]], vel, life:0.35+Math.random()*0.6, max:0.9, size:2.5*scale });
  }
}
function stepFx(dt){
  for(const p of fx){
    p.life -= dt;
    p.pos = V.add(p.pos, V.mul(p.vel, dt));
    if(p.type==='thr'){ p.vel = V.mul(p.vel, 0.88); }
    if(p.type==='exp'){ p.vel = V.mul(p.vel, 0.88); }
  }
  fx = fx.filter(p=>p.life>0);
}

/* ============================ ORIENTATION & THRUSTERS ============================ */

const TURN_RATE = 2.6; // rad/s limit for nose tracking
const FIRE_ARC_COS = Math.cos(Math.PI/4); // firing allowed within 90Â° arc
function updateBasis(e, dt){
  const v=e.vel, sp=V.len(v);
  if(sp<0.05) return;
  const targetF = V.norm(v);
  const dot = clamp(V.dot(e.fwd,targetF),-1,1);
  const ang = Math.acos(dot);
  if(ang<1e-4) return;
  const step = Math.min(TURN_RATE*dt, ang);
  const axis = V.norm(V.cross(e.fwd,targetF));
  const axf = V.cross(axis, e.fwd);
  const newF = V.norm( V.add( V.mul(e.fwd, Math.cos(step)), V.mul(axf, Math.sin(step)) ) );
  let right = V.cross(newF, [0,1,0]); if(V.len(right)<1e-4) right=[1,0,0];
  right = V.norm(right);
  let up = V.cross(right, newF); up = V.norm(up);
  e.fwd=newF; e.right=right; e.up=up;
}
function thrusterScaleFor(e){
  if(e.type===T.Mother) return 1.1;
  if(e.type===T.Heavy) return 0.9;
  if(e.type===T.Light) return 0.75;
  if(e.type===T.EW) return 0.7;
  if(e.type===T.Constructor) return 0.65;
  return 0.7;
}

// Rotate vector v around axis (unit) by ang radians
function rotateAround(v, axis, ang){
  const cos=Math.cos(ang), sin=Math.sin(ang);
  const cross=V.cross(axis,v);
  const dot=V.dot(axis,v);
  const term1=V.mul(v,cos);
  const term2=V.mul(cross,sin);
  const term3=V.mul(axis,dot*(1-cos));
  return V.add(V.add(term1,term2),term3);
}

const MAX_PIVOT_ARC=Math.PI/6; // ~30deg
const PIVOT_RATE=6;            // rad/s
function gimbalTowards(th, baseDir, desiredDir, dt){
  // Determine rotation axis/angle between base and desired
  const axisRaw=V.cross(baseDir, desiredDir);
  const axLen=V.len(axisRaw);
  if(axLen<1e-6){
    // No preferred direction; ease back to neutral
    const step=clamp(-th.ang, -PIVOT_RATE*dt, PIVOT_RATE*dt);
    th.ang+=step;
    return baseDir;
  }
  const axis=V.mul(axisRaw,1/axLen);
  const targetAng=Math.min(Math.acos(clamp(V.dot(baseDir,desiredDir),-1,1)), MAX_PIVOT_ARC);
  const diff=targetAng - th.ang;
  const step=clamp(diff, -PIVOT_RATE*dt, PIVOT_RATE*dt);
  th.ang+=step;
  return rotateAround(baseDir, axis, th.ang);
}
function allocateThrustersAndFX(e, aVec, mode, dt){
  e.thr.main.i=e.thr.fore.i=e.thr.left.i=e.thr.right.i=e.thr.up.i=e.thr.down.i=0;
  const sp = V.len(e.vel), aMag = V.len(aVec);
  if(aMag<0.06 && sp<0.06){
    // allow motors to re-center when idle
    gimbalTowards(e.thr.main, V.mul(e.fwd,-1), V.mul(e.fwd,-1), dt);
    gimbalTowards(e.thr.fore, e.fwd, e.fwd, dt);
    gimbalTowards(e.thr.left, V.mul(e.right,-1), V.mul(e.right,-1), dt);
    gimbalTowards(e.thr.right, e.right, e.right, dt);
    gimbalTowards(e.thr.up, e.up, e.up, dt);
    gimbalTowards(e.thr.down, V.mul(e.up,-1), V.mul(e.up,-1), dt);
    return;
  }

  const cfg = unitCfgByType(e.type) || RTS_CFG.units.Mother;
  const xpNorm = clamp((e.xp||0)/(RTS_CFG.dodge.xpMax||100),0,1);
  const fcfg = (mode==='Coupled') ? RTS_CFG.flight.modes.coupled : RTS_CFG.flight.modes.decoupled;
  const accLimit = (cfg.acc||8) * (mode==='Coupled' ? fcfg.turnScale : (fcfg.turnScaleMin + (1-fcfg.turnScaleMin)*xpNorm));

  const MANEUVER_FRAC = 0.6;
  const maneuverCap = accLimit * MANEUVER_FRAC;

  const af = V.dot(aVec, e.fwd);
  const ar = V.dot(aVec, e.right);
  const au = V.dot(aVec, e.up);

  const mainI = Math.max(0, af) / Math.max(0.001, accLimit);
  const foreI = Math.max(0, -af) / Math.max(0.001, maneuverCap);
  const rightI = Math.max(0, -ar) / Math.max(0.001, maneuverCap);
  const leftI  = Math.max(0,  ar) / Math.max(0.001, maneuverCap);
  const upI    = Math.max(0, -au) / Math.max(0.001, maneuverCap);
  const downI  = Math.max(0,  au) / Math.max(0.001, maneuverCap);

  let budget = mainI + foreI + leftI + rightI + upI + downI;
  const bScale = budget>1 ? 1/budget : 1;

  e.thr.main.i  = clamp(mainI*bScale,0,1);
  e.thr.fore.i  = clamp(foreI*bScale,0,1);
  e.thr.left.i  = clamp(leftI*bScale,0,1);
  e.thr.right.i = clamp(rightI*bScale,0,1);
  e.thr.up.i    = clamp(upI*bScale,0,1);
  e.thr.down.i  = clamp(downI*bScale,0,1);

  const offMain = 1.6, offSide = 1.2;
  const scale = thrusterScaleFor(e);

  const targetDir = V.norm(V.mul(aVec,-1));

  const baseMain = V.mul(e.fwd,-1);
  const dirMain = gimbalTowards(e.thr.main, baseMain, targetDir, dt);
  if(e.thr.main.i>0){
    const nozzle = V.add(e.pos, V.mul(e.fwd, -(offMain)));
    addThruster(nozzle, dirMain, e.thr.main.i, scale*1.2, 'burn');
  }

  const baseFore = e.fwd;
  const dirFore = gimbalTowards(e.thr.fore, baseFore, targetDir, dt);
  if(e.thr.fore.i>0.05){
    const nozzle = V.add(e.pos, V.mul(e.fwd, (offMain*0.9)));
    addThruster(nozzle, dirFore, e.thr.fore.i, scale*0.5, 'burst');
  }

  const baseLeft = V.mul(e.right,-1);
  const dirLeft = gimbalTowards(e.thr.left, baseLeft, targetDir, dt);
  if(e.thr.left.i>0.05){
    const nozzle = V.add(e.pos, V.mul(e.right, -(offSide)));
    addThruster(nozzle, dirLeft, e.thr.left.i, scale*0.4, 'burst');
  }

  const baseRight = e.right;
  const dirRight = gimbalTowards(e.thr.right, baseRight, targetDir, dt);
  if(e.thr.right.i>0.05){
    const nozzle = V.add(e.pos, V.mul(e.right, (offSide)));
    addThruster(nozzle, dirRight, e.thr.right.i, scale*0.4, 'burst');
  }

  const baseDown = V.mul(e.up,-1);
  const dirDown = gimbalTowards(e.thr.down, baseDown, targetDir, dt);
  if(e.thr.down.i>0.05){
    const nozzle = V.add(e.pos, V.mul(e.up, -(offSide)));
    addThruster(nozzle, dirDown, e.thr.down.i, scale*0.4, 'burst');
  }

  const baseUp = e.up;
  const dirUp = gimbalTowards(e.thr.up, baseUp, targetDir, dt);
  if(e.thr.up.i>0.05){
    const nozzle = V.add(e.pos, V.mul(e.up, (offSide)));
    addThruster(nozzle, dirUp, e.thr.up.i, scale*0.4, 'burst');
  }
}

/* ============================ MOVEMENT / STEERING ============================ */

function steerTo(e, target, dt, speedMul=1, context='eco'){
  const cfg = unitCfgByType(e.type) || RTS_CFG.units.Mother;
  const mode = chooseFlightMode(e, context);
  const xpNorm = clamp((e.xp||0)/(RTS_CFG.dodge.xpMax||100),0,1);
  const mcfg = (mode==='Coupled') ? RTS_CFG.fuelUse.coupled : RTS_CFG.fuelUse.decoupled;
  const fcfg = RTS_CFG.flight.modes[ mode==='Coupled'?'coupled':'decoupled' ];

  const to = V.sub(target, e.pos); const d = V.len(to);
  const desiredDir = d>1e-3 ? V.norm(to) : [0,0,0];
  const vmax = cfg.spd * speedMul * fcfg.spdMul;

  const arriveR = RTS_CFG.flight.arriveRadius;
  const desiredSpeed = vmax * clamp(d/arriveR, 0.2, 1.0);
  const desiredVel = V.mul(desiredDir, desiredSpeed);
  const toDesired = V.sub(desiredVel, e.vel);
  const dzCfg = RTS_CFG.flight.deadZone || {dist:0,vel:0};
  if(d < dzCfg.dist && V.len(toDesired) < dzCfg.vel){
    e.vel = V.mul(e.vel, RTS_CFG.flight.damping);
    e.maneuver = 0;
    e.pos = V.add(e.pos, V.mul(e.vel, dt));
    updateBasis(e, dt);
    allocateThrustersAndFX(e, [0,0,0], mode, dt);
    const spd = V.len(e.vel);
    const fuelBase = (fcfg.baseFuelPerSec || mcfg.basePerSec || 0) * dt + RTS_CFG.fuelUse.radarPerSec*dt;
    const fuelMove = (mcfg.movePerUnit || 0) * spd * dt;
    e.fuel = Math.max(0, e.fuel - fuelBase - fuelMove);
    DEBUG_METRICS.fuelIdle += fuelBase + fuelMove;
    DEBUG_METRICS.deadZoneSkips++;
    e.fuelRange = calcFuelRange(e);
    clampInBounds(e.pos);
    return;
  }
  const accBase = cfg.acc;
  const accScale = (mode==='Coupled') ? fcfg.turnScale : (fcfg.turnScaleMin + (1-fcfg.turnScaleMin)*xpNorm);
  const accLimit = accBase * accScale;

  let accel = [0,0,0];
  if(V.len(toDesired)>1e-5){
    const steer = V.norm(toDesired);
    accel = V.mul(steer, Math.min(V.len(toDesired), accLimit));
  }
  if(mode==='Coupled' && V.len(e.vel)>1e-5 && V.len(desiredDir)>1e-5){
    const vpar = V.mul(desiredDir, V.dot(e.vel, desiredDir));
    const vorth = V.sub(e.vel, vpar);
    if(V.len(vorth)>1e-4){
      const kill = Math.min(V.len(vorth), accLimit) * fcfg.lateralKill;
      accel = V.add(accel, V.mul( V.norm(vorth), -kill ));
    }
  }

  const MANEUVER_FRAC = 0.6;
  const mainComp = Math.max(0, V.dot(accel, e.fwd));
  const nonMain = V.sub(accel, V.mul(e.fwd, mainComp));
  accel = V.add(
    V.mul(e.fwd, mainComp),
    V.mul(nonMain, MANEUVER_FRAC)
  );

  const prevV = e.vel;
  e.vel = V.add(e.vel, V.mul(accel, dt));
  e.vel = V.mul(e.vel, RTS_CFG.flight.damping);
  const aMag = V.len( V.sub(e.vel, prevV) ) / Math.max(1e-5,dt);
  e.maneuver = clamp(aMag / (cfg.acc||1), 0, 1);

  const spd = V.len(e.vel);
  e.pos = V.add(e.pos, V.mul(e.vel, dt));

  updateBasis(e, dt);

  const devCfg = RTS_CFG.flight.dev || {};
  const velErr = V.len( V.sub(desiredVel, e.vel) );
  const rotErr = (V.len(desiredDir)>1e-5) ? Math.acos(clamp(V.dot(e.fwd, desiredDir),-1,1)) : 0;
  const over = devCfg.over || 2;
  const overshoot = spd > desiredSpeed * over;
  const thrErr = Math.abs(spd - desiredSpeed);
  if(mode==='Coupled'){
    if(velErr <= (devCfg.vel||0) && rotErr <= (devCfg.rot||0)){
      const gain = (devCfg.xp||0) * dt;
      e.xp = (e.xp||0) + gain;
      e.xpCtrl = (e.xpCtrl||0) + gain;
    }else if(overshoot || velErr > (devCfg.vel||0)*over || rotErr > (devCfg.rot||0)*over){
      const loss = (devCfg.xp||0) * dt;
      e.xp = Math.max(0, (e.xp||0) - loss);
      e.xpCtrl = Math.max(0, (e.xpCtrl||0) - loss);
    }
  }else{
    if(velErr <= (devCfg.vel||0) && rotErr <= (devCfg.rot||0)){
      const gain = (devCfg.xp||0) * dt;
      e.xp = (e.xp||0) + gain;
      e.xpPivot = (e.xpPivot||0) + gain;
    }else if(overshoot || velErr > (devCfg.vel||0)*over || rotErr > (devCfg.rot||0)*over){
      const loss = (devCfg.xp||0) * dt;
      e.xp = Math.max(0, (e.xp||0) - loss);
      e.xpPivot = Math.max(0, (e.xpPivot||0) - loss);
    }
  }
  if(thrErr <= (devCfg.vel||0)){
    const gain = (devCfg.xp||0) * dt;
    e.xp = (e.xp||0) + gain;
    e.xpThrottle = (e.xpThrottle||0) + gain;
  }else if(thrErr > (devCfg.vel||0)*over){
    const loss = (devCfg.xp||0) * dt;
    e.xp = Math.max(0, (e.xp||0) - loss);
    e.xpThrottle = Math.max(0, (e.xpThrottle||0) - loss);
  }
  if(mode==='Coupled'){
    if(spd <= (devCfg.vel||0) && rotErr <= (devCfg.rot||0)){
      const gain = (devCfg.xp||0) * dt;
      e.xp = (e.xp||0) + gain;
      e.xpCtrl = (e.xpCtrl||0) + gain;
    }
  }else if(mode==='Decoupled' && spd > (devCfg.vel||0)*over){
    const loss = (devCfg.xp||0) * dt;
    e.xp = Math.max(0, (e.xp||0) - loss);
    e.xpCtrl = Math.max(0, (e.xpCtrl||0) - loss);
  }

  const aVec = V.mul( V.sub(e.vel, prevV), 1/Math.max(1e-5,dt) );
  allocateThrustersAndFX(e, aVec, mode, dt);

  const fuelBase = (fcfg.baseFuelPerSec || mcfg.basePerSec || 0) * dt + RTS_CFG.fuelUse.radarPerSec*dt;
  const fuelMove = (mcfg.movePerUnit || 0) * spd * dt;
  const fuelThrust = (mcfg.accelCost || 0) * aMag * dt;
  const fuelDraw = fuelBase + fuelMove + fuelThrust;
  e.fuel = Math.max(0, e.fuel - fuelDraw);
  DEBUG_METRICS.fuelActive += fuelDraw;
  e.sigFuelUse = (e.sigFuelUse || 0) + fuelDraw;

  e.fuelRange = calcFuelRange(e);
  clampInBounds(e.pos);
}

/* ============================ VISIBILITY & DODGE ============================ */

function jammerStrength(observer, target){
  const valid = p => Array.isArray(p) && p.length === 3 && p.every(n => typeof n === 'number' && Number.isFinite(n));
  if(!valid(observer && observer.pos) || !valid(target && target.pos)){
    console.warn('jammerStrength: invalid positions', observer && observer.pos, target && target.pos);
    return 0;
  }
  let jam = 0;
  for(const j of entities){
    if(j.faction!==observer.faction && !j.hidden && j.type===T.EW && j.jammer){
      const r = j.jammer.radius || 0;
      const d = calcDist(target.pos, j.pos);
      if(d < r){
        const contrib = (j.jammer.strength||0) * (1 - d/r);
        if(contrib > 0) jam += contrib;
      }
    }
  }
  return Math.max(0, jam);
}

function visible(observer, target){
  if(!el('fog').checked) return true;
  if(observer.hidden || target.hidden) return false;
  const valid = p => Array.isArray(p) && p.length === 3 && p.every(n => typeof n === 'number' && Number.isFinite(n));
  if(!valid(observer && observer.pos) || !valid(target && target.pos)){
    console.warn('visible: invalid positions', observer && observer.pos, target && target.pos);
    return false;
  }
  const base = observer.radar || 30;
  const d = calcDist(observer.pos, target.pos);
  if(d < RTS_CFG.world.hardReveal) return true;

  const sig = sigFromPower(RTS_CFG, target.powerKw || 0, { fuelUse: target.sigFuelUse || 0, weaponFire: target.sigWeaponFire });

  const jam = jammerStrength(observer, target);
  const eff = sig - jam;
  if(eff <= 0) return false;
  return d <= base * eff;
}

function dodgeChance(u){
  const cfg=unitCfgByType(u.type)||RTS_CFG.units.Mother;
  const D=RTS_CFG.dodge;
  const xpNorm = clamp((u.xp||0)/(D.xpMax||100),0,1);
  const v=V.len(u.vel), vNorm=clamp(v/(cfg.spd||1),0,1);
  const aNorm=u.maneuver||0;
  const P = clamp(D.base + D.kXP*xpNorm + D.kSpeed*vNorm + D.kAccel*aNorm, 0, D.pMax);
  return P;
}
function tryDodge(u, incomingDir){
  if(u.type===T.Mother) return false;
  if(u.fuel<=0) return false;
  const P = dodgeChance(u);
  if(Math.random() < P){
    const j = randInUnitDiskPerp(incomingDir);
    const J = RTS_CFG.dodge.jinkAccel;
    u.vel = V.add(u.vel, V.mul(j, J));
    u.fuel = Math.max(0, u.fuel - RTS_CFG.dodge.fuelPulse);
    setSubtask(u,'Dodging',0.6);
    COMBAT_LOG.push({ type:'dodge', unit:u.id, p:+P.toFixed(3) });
    return true;
  }
  return false;
}

/* ============================ COMBAT / PROJECTILES ============================ */

function threatScore(e){
  switch(e.type){
    case T.Heavy: return 5;
    case T.Light:
    case T.EW: return 4;
    case T.Platform: return 3;
    case T.Outpost: return 2;
    case T.Mother: return 1;
    default: return 0;
  }
}
function applyDamage(target, dmg, attackerFaction, attackerId){
  const eff = dmg * (1 - (target.arm||0));
  // Clamp HP to never drop below 0 for cleaner state/logs
  target.hp = Math.max(0, target.hp - eff);
  COMBAT_LOG.push({ type:'damage', target:target.id, attacker:attackerId, faction:attackerFaction, raw:dmg, eff, hp:target.hp });
  const attF = factions[attackerFaction];
  const defF = factions[target.faction];
  attF.stats.dmgDealt += eff; defF.stats.dmgTaken += eff;
  const atkE = getById(attackerId);
  if(atkE){ attF.stats.perType[classKey(atkE)].dmgDealt += eff; }
  defF.stats.perType[classKey(target)].dmgTaken += eff;

  spawnExplosion(target.pos, 0.25);

  if(target.hp<=0){
    if(target.dockedAt){ const s=getById(target.dockedAt); if(s) releaseDock(s, target.id); }
    const lifeSec = (tickCount - target.birth)/60;
    markLost(target.faction, classKey(target), lifeSec);
    if(getById(attackerId)){ attF.stats.perType[classKey(getById(attackerId))].kills++; }
    if(target.role==='Structure') defF.losses.structures++; else defF.losses.units++;
    spawnExplosion(target.pos, target.type===T.Mother? 3.0 : (target.role==='Structure'?1.8:1.2));
    if(target.type===T.Mother){ endState={ winner: attackerFaction }; }
    removeEntity(target);
  }
}
function stepProjectiles(dt){
  for(const p of projectiles){
    p.ttl-=dt; if(p.ttl<=0) p.dead=true;
    p.pos=V.add(p.pos, V.mul(p.vel, dt));
    if(p.fx){
      // FX-only streaks: skip collision/damage
      continue;
    }
    let hit=null, bd=HIT_RADIUS;
    for(const e of entities){ if(e.faction===p.faction || e.hidden) continue; const d=calcDist(e.pos,p.pos); if(d<bd){bd=d; hit=e;} }
    if(hit){
      const dir = V.norm(p.vel);
      if(!tryDodge(hit, dir)){
        applyDamage(hit,p.dmg,p.faction,p.src);
        const atk=factions[p.faction]; atk.stats.shotsHit++; const src=getById(p.src); if(src) atk.stats.perType[classKey(src)].shotsHit++;
        COMBAT_LOG.push({ type:'projectile-hit', proj:p.id, shooter:p.src, target:hit.id, dmg:p.dmg });
      }
      else{ COMBAT_LOG.push({ type:'projectile-dodged', proj:p.id, shooter:p.src, target:hit.id }); }
      p.dead=true;
    }
  }
  projectiles=projectiles.filter(p=>!p.dead);
}

/* Projectile visual spec per weapon key */
function projSpecFor(wkey){
  switch(wkey){
    case 'SMG':       return {len:3,  thick:1.2, ttl:1.2, color:'#ffff00'}; // much smaller streaks
    case 'BeamRifle': return {len:20, thick:2.0, ttl:2.0, color:'#0000ff'};
    case 'HeavyRail': return {len:16, thick:3.5, ttl:2.5, color:'#ff0000'};
    default:          return {len:12, thick:1.8, ttl:2.0};
  }
}

/* ============================ MOTHER / TEAM / CONSTRUCTORS ============================ */

function stepMother(m,dt){
  const cfg=RTS_CFG.motherAI;
  // Avoid enemies if close
  let nearestE=null, bd=1e9;
  for(const e of entities){
    if(e.faction===m.faction||e.hidden) continue;
    if(!(e.type===T.Light||e.type===T.Heavy||e.type===T.EW)) continue;
    const d=calcDist(m.pos,e.pos); if(d<bd){bd=d; nearestE=e;}
  }
  if(nearestE && bd<cfg.avoidEnemyDist){
    const away = V.add(m.pos, V.mul( V.norm( V.sub(m.pos, nearestE.pos) ), 12));
    steerTo(m, away, dt, cfg.fleeSpeedMul, 'combat');
    setSubtask(m,'Fleeing',0.6);
    return;
  }

  // Anchor to a nearby cluster, re-evaluate occasionally
  m._anchorT = (m._anchorT||0) + dt;
  if(!m._anchor || m._anchorT>=cfg.reanchorEvery){
    const cc = clusterCenterNear(m.pos);
    if(cc) { m._anchor = cc; m._anchorT = 0; }
  }
  if(m._anchor){
    const d = calcDist(m.pos, m._anchor);
    if(d>cfg.holdRadius){
      steerTo(m, m._anchor, dt, cfg.cruiseSpeedMul, 'eco'); // slow cruise
      setSubtask(m,'Repositioning',0.5);
    }else{
      // gentle station-keeping; no active thrust
      m.vel = V.mul(m.vel, 0.985);
      m.maneuver = 0;
      setSubtask(m,'Station Keeping',0.5);
    }
  }else{
    setSubtask(m,'Idle',0.5);
  }
}

function computeFormationOffsets(tm, leader, upMul){
  const offsets=new Map();
  const counts={E:0,L:0,H:0};
  for(const id of tm.members){
    const u=getById(id); if(!u || u.id===leader.id) continue;
    if(u.type===T.EW){
      const i=counts.E++;
      const s=(i%2?1:-1)*0.5;
      const back=1+Math.floor(i/2);
      offsets.set(u.id,{side:s,fwd:-back,up:0});
    }else if(u.type===T.Heavy){
      const i=counts.H++;
      const dir=i%2===0?1:-1;
      const mult=2+Math.floor(i/2);
      offsets.set(u.id,{side:dir*mult,fwd:0,up:upMul});
    }else{
      const i=counts.L++;
      const dir=i%2===0?1:-1;
      const mult=1+Math.floor(i/2);
      offsets.set(u.id,{side:dir*mult,fwd:0,up:upMul});
    }
  }
  return offsets;
}

function stepTeam(tm,dt){
  const now = tickCount/60;

  let tot=0,cnt=0,shared=0,radarSharers=0,tcTot=0;
  let xpTot=0,xpCtrlTot=0,xpThrTot=0,sigTot=0,xpCnt=0;
  for(const id of tm.members){
    const u=getById(id);
    if(u && !u.hidden){
      if(u.tank>0){ const fr = u.fuelRange!=null?u.fuelRange:calcFuelRange(u); tot+=fr; cnt++; }
      if(u.radar && u.radarShare){ shared=Math.max(shared,u.radar); radarSharers++; }
      const tcCount = (u.weapons||[]).reduce((n,w)=>n+(w.targetComputer?1:0),0);
      tcTot += tcCount;
      xpTot += (u.xp||0);
      xpCtrlTot += (u.xpCtrl||0);
      xpThrTot += (u.xpThrottle||0);
      sigTot += sigFromPower(RTS_CFG, u.powerKw||0,{ fuelUse:u.sigFuelUse||0, weaponFire:u.sigWeaponFire });
      xpCnt++;
    }
  }
  tm.avgRange = cnt? tot/cnt : 0;
  tm.sharedRadar = shared;
  tm.radarShareCount = radarSharers;
  tm.targetCompCount = tcTot;
  tm.avgTargetComp = xpCnt? tcTot/xpCnt : 0;
  tm.hasTargetComp = tcTot>0;
  tm.avgXP = xpCnt? xpTot/xpCnt : 0;
  tm.avgXpCtrl = xpCnt? xpCtrlTot/xpCnt : 0;
  tm.avgXpThrottle = xpCnt? xpThrTot/xpCnt : 0;
  tm.avgSignature = xpCnt? sigTot/xpCnt : 0;

  // Propagate shared radar range to all members
  for(const id of tm.members){
    const e=getById(id);
    if(e){
      e.radarShared = Math.max(e.radar||0, tm.sharedRadar||0);
      e.radarShareCount = tm.radarShareCount;
    }
  }

  // target lock: keep attacking the same thing a little longer even if it blinks
  if(tm.currentTarget){
    const tgt=getById(tm.currentTarget);
    if(tgt && !tgt.hidden){ tm._targetLockUntil = Math.max(tm._targetLockUntil||0, now+3.0); }
  }

  // Ensure mission-specific assets still exist; otherwise force a re-plan
  if(tm.mission){
    let exists = true;
    if(tm.mission.type===MISSION.Defend){
      exists = !!getById(tm.mission.defendId);
    } else if(tm.mission.type===MISSION.Escort){
      exists = !!getById(tm.mission.escortId);
    } else if(tm.mission.type===MISSION.Siege){
      exists = !!getById(tm.mission.targetId);
    }
    if(!exists){
      tm._lockUntil = 0;
      tm.lastPlan = 0;
    }
  }

  // Mission lock: do not re-plan too often unless DEFEND overrides
  const mustDefend = !!nearestThreatened(tm.faction);
  if((now - (tm.lastPlan||0) > RTS_CFG.flight.planCooldown) && (!tm._lockUntil || now>tm._lockUntil || mustDefend)){
    let newM = decideMission(tm);
    // avoid assigning missions beyond average fuel range
    let dest=null;
    if(newM.type===MISSION.Defend){ const a=getById(newM.defendId); dest=a? a.pos:null; }
    else if(newM.type===MISSION.Escort){ const u=getById(newM.escortId); dest=u? u.pos:null; }
    else if(newM.type===MISSION.Siege){ const t=getById(newM.targetId); dest=t? t.pos:null; }
    else if(newM.type===MISSION.Harass){ dest=newM.area; }
    else if(newM.type===MISSION.SAD || newM.type===MISSION.Patrol){ dest=newM.point; }
    if(dest){ const c=teamCentroid(tm); if(calcDist(c,dest) > tm.avgRange){ newM={ type:MISSION.Defend, defendId:getMother(tm.faction).id }; } }
    tm.mission = newM; tm.lastPlan = now;
    tm._formationMission = null; // force formation recalc
    // commit longer to aggressive missions
    if(newM.type===MISSION.Siege || newM.type===MISSION.Harass || newM.type===MISSION.SAD){
      tm._lockUntil = now + 8.0;
    }else{
      tm._lockUntil = now + 4.0;
    }
  }

  let leader = teamLeader(tm);
  if(!leader) return;

  /* Fuel crisis: stand down near Mother */
  if(factions[tm.faction].ration.active){
    const m = getMother(tm.faction);
    if(tm._formationMission!=='StandDown'){
      tm._hold = randAround(m.pos, 8);
      tm._formationGap = RTS_CFG.flight.formationGap*0.8;
      tm._formation = computeFormationOffsets(tm, leader, 0.4);
      tm._formationMission = 'StandDown';
    }
    steerTo(leader, tm._hold, dt, 0.65, 'eco');
    leader.intent = {kind:'StandDown'};
    const forward = V.len(leader.prevVel)>0.01 ? V.norm(leader.prevVel) : leader.fwd;
    const side = V.norm( V.cross(forward, [0,1,0]) );
    const up   = V.cross(side, forward);
    for(let i=0;i<tm.members.length;i++){
      const u=getById(tm.members[i]); if(!u || u.id===leader.id) continue;
      const coeff = tm._formation.get(u.id) || {side:0,fwd:0,up:0};
      const offset = V.add(
        V.mul(side, coeff.side*tm._formationGap),
        V.add( V.mul(forward, coeff.fwd*tm._formationGap), V.mul(up, coeff.up*tm._formationGap) )
      );
      const target = V.add(leader.pos, offset);
      steerTo(u, target, dt, 0.7, 'eco');
      u.intent = {kind:'StandDown'};
    }
    tm.currentTarget = null;
    tm.mission = { type:MISSION.Defend, defendId:getMother(tm.faction).id };
    return;
  }

  let leaderDest = leader.pos;

  if(tm.mission.type===MISSION.Defend){
    const a=getById(tm.mission.defendId); if(a) leaderDest=a.pos;
  } else if(tm.mission.type===MISSION.Escort){
    const u=getById(tm.mission.escortId); leaderDest = u? u.pos : teamCentroid(tm);
  } else if(tm.mission.type===MISSION.Siege){
    const t=getById(tm.mission.targetId); leaderDest = t? t.pos : frontlinePoint(tm.faction);
    tm.currentTarget = t? t.id : null;
  } else if(tm.mission.type===MISSION.Harass){
    leaderDest = tm.mission.area || enemyHalf(tm.faction);
  } else if(tm.mission.type===MISSION.SAD){
    leaderDest = tm.mission.point || frontlinePoint(tm.faction);
  } else {
    leaderDest = tm.mission.point || pickPatrol(tm.faction);
  }

  const dLead = calcDist(leader.pos, leaderDest);
  if(dLead > tm.avgRange){
    tm.currentTarget = null;
    tm.mission = { type:MISSION.Defend, defendId:getMother(tm.faction).id };
    return;
  }

  steerTo(leader, leaderDest, dt, 0.9, 'combat');
  leader.intent={kind:tm.mission.type};

  if(tm._formationMission!==tm.mission.type){
    tm._formationGap = RTS_CFG.flight.formationGap;
    tm._formation = computeFormationOffsets(tm, leader, 0.6);
    tm._formationMission = tm.mission.type;
  }
  const forward = V.len(leader.prevVel)>0.01 ? V.norm(leader.prevVel) : leader.fwd;
  const side = V.norm( V.cross(forward, [0,1,0]) );
  const up   = V.cross(side, forward);
  for(let i=0;i<tm.members.length;i++){
    const u=getById(tm.members[i]); if(!u || u.id===leader.id) continue;
    const coeff = tm._formation.get(u.id) || {side:0,fwd:0,up:0};
    const offset = V.add(
      V.mul(side, coeff.side*tm._formationGap),
      V.add( V.mul(forward, coeff.fwd*tm._formationGap), V.mul(up, coeff.up*tm._formationGap) )
    );
    const target = V.add( leader.pos, offset );
    steerTo(u, target, dt, 0.95, 'combat');
    u.intent={kind:tm.mission.type};
  }

  // Sticky target selection
  let best=null,bScore=-1,bd=1e9;
  for(const e of entities){
    if(e.faction===tm.faction || e.hidden) continue;
    if(!(e.type===T.EW||e.type===T.Light||e.type===T.Heavy||e.type===T.Platform||e.type===T.Outpost||e.type===T.Mother)) continue;
    const vis = visible(leader,e) || (tm._targetLockUntil && now<tm._targetLockUntil && e.id===tm.currentTarget);
    if(!vis) continue;
    const d=calcDist(leader.pos,e.pos);
    const score=threatScore(e);
    if(score>bScore || (score===bScore && d<bd)){bd=d;best=e;bScore=score;}
  }
  tm.currentTarget = best? best.id : (now<(tm._targetLockUntil||0) ? tm.currentTarget : null);
}

function pickResourceNode(kind, fromPos){
  let best=null, bd=1e9;
  for(const r of resources){
    if(r.type!==kind || r.cap<=0) continue;
    const maxSlots = r.rate; // use node share rate as capacity
    const assigned = nodeAssignments.get(r.id) || 0;
    if(assigned >= maxSlots) continue;
    const d=calcDist(fromPos,r.pos);
    if(d<bd || (Math.abs(d-bd)<1e-6 && (!best || r.id<best.id))){
      bd=d; best=r;
    }
  }
  return best;
}

function stepConstructor(e,dt){
  if(e.fuel<=0){
    const s = nearestStorageWithFuel(e.faction, e.pos, e.tank*0.5);
    if(s){ ensureDockIntent(e,s,{refuel:true}); e.mission={kind:EMISSION.Stalled}; e.blocker='Out of fuel'; setSubtask(e,'ATC Queue',0.8); }
    return;
  }

  // ATC docking behavior for constructors too
  if(handleDockIntent(e, dt)) return;

  // LOAD ORE FOR BUILDING
  if(e.mission && (e.mission.kind===EMISSION.BuildOutpost_Load || e.mission.kind===EMISSION.BuildPlatform_Load)){
    const s=getById(e.mission.storeId)||nearestStorage(e.faction,e.pos);
    if(!s){ e.mission={kind:EMISSION.Idle}; return; }
    const nextKind = e.mission.kind===EMISSION.BuildOutpost_Load?EMISSION.BuildOutpost:EMISSION.BuildPlatform;
    ensureDockIntent(e, s, { loadOre:e.mission.oreCost, nextMission:{kind:nextKind, pos:e.mission.pos, buildTime:e.mission.buildTime, jobId:e.mission.jobId, oreCost:e.mission.oreCost} });
    setSubtask(e,'ATC Queue',0.8);
    return;
  }

  // BUILDING
  if(e.mission && (e.mission.kind===EMISSION.BuildOutpost || e.mission.kind===EMISSION.BuildPlatform)){
    const dest = e.mission.pos;
    const need = e.mission.oreCost||0;
    if((e.cargo?.ore||0) < need){
      const s=nearestStorage(e.faction,e.pos);
      e.mission = { kind:e.mission.kind===EMISSION.BuildOutpost?EMISSION.BuildOutpost_Load:EMISSION.BuildPlatform_Load, pos:e.mission.pos, buildTime:e.mission.buildTime, jobId:e.mission.jobId, oreCost:need, storeId:s?s.id:null };
      return;
    }
    steerTo(e, dest, dt, 0.9, 'eco');
    const d=calcDist(e.pos,dest);
    if(d<3){
      if(!e.buildTimer) e.buildTimer = e.mission.buildTime||6;
      e.buildTimer -= dt;
      e.blocker = `Building: ${e.mission.kind===EMISSION.BuildOutpost?'Outpost':'Platform'} ${(Math.max(0,e.buildTimer)).toFixed(1)}s`;
      setSubtask(e,'Building',0.5);
      if(e.buildTimer<=0){
        const jobId = e.mission.jobId;
        const cost = need;
        buildStructure(e.faction, e.mission.kind===EMISSION.BuildOutpost?T.Outpost:T.Platform, dest);
        if(e.cargo){
          const before = e.cargo.ore||0;
          if(cost > before) console.warn('build exceeds cargo', {id:e.id, cost, before});
          e.cargo.ore = Math.max(0, before - cost);
        }
        e.buildTimer=0; e.mission={kind:EMISSION.ReturnDeposit}; e.blocker=null;
        e.xp += 6; // build XP
        const f=getFaction(e.faction); f.buildQ = f.buildQ.filter(j=>j.id!==jobId);
      }
    }
    return;
  }

  // FUEL DELIVERY
  if(e.mission && e.mission.kind===EMISSION.DeliverFuel_Load){
    const s=getById(e.mission.storeId)||nearestStorageWithFuel(e.faction,e.pos, e.cargo.cap);
    if(!s){ e.mission={kind:EMISSION.Idle}; return; }
    ensureDockIntent(e, s, { loadFuel:true, nextMission:{kind:EMISSION.DeliverFuel_Travel, target:e.mission.target} });
    setSubtask(e,'ATC Queue',0.8);
    return;
  }
  if(e.mission && e.mission.kind===EMISSION.DeliverFuel_Travel){
    const t=getById(e.mission.target);
    if(!t || t.hp<=0){ e.mission={kind:EMISSION.Idle}; return; }
    steerTo(e, t.pos, dt, 1.0, 'eco');
    const d=calcDist(e.pos,t.pos);
    if(d<5){
      const rate = RTS_CFG.economy.logistics.refuelRatePerSec;
      const need = Math.max(0, t.tank - t.fuel);
      const give = Math.min(e.cargo.fuel, rate*dt, need);
      setSubtask(e,'Refuel Delivery',0.6);
      if(give>0){
        const before = e.cargo.fuel||0;
        if(give > before) console.warn('Refuel delivery exceeds cargo', {id:e.id, give, before});
        e.cargo.fuel = Math.max(0, before - give);
        t.fuel += give;
        updateLowFuelStatus(t);
      }
      if(give<=1e-3 || e.cargo.fuel<=1){ clearFuelTicket(e.faction, t.id, e.id); e.mission={kind:EMISSION.ReturnDeposit}; }
    }
    return;
  }

  // RETURN/DEPOSIT
  if(e.mission && e.mission.kind===EMISSION.ReturnDeposit){
    const oreNeed = e.cargo.ore, fuelNeed = e.cargo.fuel;
    e._storageRetry = (e._storageRetry||0) - dt;
    if(e._storageRetry <= 0){
      const s = nearestStorageWithCapacity(e.faction, e.pos, oreNeed, fuelNeed); // prefer field storages
      if(s){
        e._overflowDur = 0;
        ensureDockIntent(e, s, { deposit:true, nextMission:{kind:(chooseNextMineKind(e.faction))} });
        setSubtask(e,'ATC Queue',0.8);
        return;
      }
      e._storageRetry = 3;
      e._overflowDur = (e._overflowDur||0) + 3;
      const f=getFaction(e.faction);
      if(e._overflowDur>15 && !f._storageBuildQueued){ enqueueBuild(e.faction,T.Outpost); f._storageBuildQueued=true; }
    }
    e.blocker='No storage capacity';
    steerTo(e, getMother(e.faction).pos, dt, 0.8, 'eco');
    setSubtask(e,'Await Storage',0.8);
    return;
  }

  // MINING
  if(e.mission && (e.mission.kind===EMISSION.MineOre || e.mission.kind===EMISSION.MineFuel)){
    const kind = (e.mission.kind===EMISSION.MineOre)?T.ResOre:T.ResFuel;
    let node = e.mission.nodeId? resources.find(r=>r.id===e.mission.nodeId): null;
    if(!node || node.cap<=0){
      if(e.mission.nodeId!=null){
        const cnt=nodeAssignments.get(e.mission.nodeId)||0;
        if(cnt<=1) nodeAssignments.delete(e.mission.nodeId); else nodeAssignments.set(e.mission.nodeId,cnt-1);
      }
      node = pickResourceNode(kind, e.pos);
      e.mission.nodeId = node? node.id : null;
      if(node) nodeAssignments.set(node.id,(nodeAssignments.get(node.id)||0)+1);
    }
    if(!node){ e.mission={kind:EMISSION.Idle}; return; }
    steerTo(e, node.pos, dt, 0.9, 'eco');
    const d=calcDist(e.pos,node.pos);
    if(d<3){
      const rate = (kind===T.ResOre)? e.mine.oreRate : e.mine.fuelRate;
      const space = e.cargo.cap - (e.cargo.ore + e.cargo.fuel);
      const take = Math.max(0, Math.min(rate*dt, node.cap, space));
      setSubtask(e, (kind===T.ResOre)?'Mining Ore':'Mining Fuel', 0.6);
      if(take>0){
        if(kind===T.ResOre) e.cargo.ore+=take; else e.cargo.fuel+=take;
        if(take > node.cap) console.warn('mining exceeds node capacity', {nodeId:node.id, take, cap:node.cap});
        node.cap = Math.max(0, node.cap - take);
      }
      const leave = space - take < 1 || node.cap<=1;
      if(leave){
        const cnt=nodeAssignments.get(node.id)||0;
        if(cnt<=1 || node.cap<=1) nodeAssignments.delete(node.id); else nodeAssignments.set(node.id,cnt-1);
        e.mission={kind:EMISSION.ReturnDeposit};
      }
    }
    return;
  }

  e.mission = {kind: chooseNextMineKind(e.faction), nodeId:null};
}

function chooseNextMineKind(fid){
  const f=getFaction(fid), ratio=RTS_CFG.economy.ratios;
  const needFuel = (f.fuel < ratio.fuelReserve) || (f.fuel < ratio.fuelToOreTarget * Math.max(1,f.ore));
  return needFuel ? EMISSION.MineFuel : EMISSION.MineOre;
}

/* ============================ DOCK PROCESSOR â€” ATC (bays/phases) ============================ */

function processDocking(dt){
  for(const s of entities){
    if(!s.dockCtrl) continue;
    const d = s.dockCtrl;
    const h = s.hangarCtrl;

    // === Fill empty bays with ready units (departures first, then arrivals) ===
    for(let bi=0; bi<d.bays.length; bi++){
      const bay = d.bays[bi];

      // If bay idle, handle departures first
        if(!bay.unitId){
          if(pqLength(d.departQueue)){
            const dep = pqShift(d.departQueue);
            const u = getById(dep.id);
            if(!u || u.hp<=0){ continue; }
            bay.unitId = dep.id;
            bay.phase = 'Depart';
            d.departOps.push({ unitId: dep.id, t:d.undockTime, bayIndex:bi, nextMission:dep.nextMission });
            continue;
          }

          // Pick the highest-priority queued unit that is nearby
          let picked=null;
          for(let pi=0; pi<3 && !picked; pi++){
            const arr=d.queue[pi];
            for(let qi=0; qi<arr.length; qi++){
              const qe=arr[qi];
              const u=getById(qe.id);
              if(!u || u.hp<=0 || !u.dockIntent){ arr.splice(qi,1); qi--; continue; }
              if(u.dockedAt || u.hidden){ arr.splice(qi,1); qi--; continue; }
              if(u.dockIntent.storeId!==s.id) continue;
              if(calcDist(u.pos,s.pos) <= d.holdR + 2.5){
                arr.splice(qi,1); picked=u; break;
              }
            }
          }
          if(picked){
            bay.unitId = picked.id;
            bay.phase = 'Landing';
            bay.t = d.landingTime;
            if(picked.dockIntent) picked.dockIntent.state='Landing';
          }
        }

      // Landing countdown; when close enough + timer, we "touch down" and start service
      if(bay.unitId && bay.phase==='Landing'){
        const u=getById(bay.unitId);
        if(!u || u.hp<=0){ bay.unitId=null; bay.phase='Idle'; bay.t=0; continue; }
        bay.t -= dt;

        if(bay.t<=0 && calcDist(u.pos,s.pos) <= d.finalR){
          // Touchdown: hide & enqueue for hangar service
          if(u.dockIntent?.slot!=null) releaseDockSlot(s, u.dockIntent.slot);
          u.hidden=true; u.vel=[0,0,0]; u.dockedAt=s.id;
          if(!d.occ.includes(u.id)) d.occ.push(u.id);
          enqueueHangar(s, u.id);
          if(u.dockIntent){ u.dockIntent.state='HangarQueue'; u.dockIntent.slot=null; }
          bay.unitId=null; bay.phase='Idle'; bay.t=0;
        }
      }
    }

    // === Hangar processing ===
    if(h){
        if(!d.requeueCounts) d.requeueCounts = {};
        for(const uid of d.occ){
          const u = getById(uid);
          if(!u || !u.hidden || u.dockedAt!==s.id) continue;
          if(!pqContains(h.queue, uid) && !h.occ.includes(uid)){
            enqueueHangar(s, uid);
            const cnt = (d.requeueCounts[uid] = (d.requeueCounts[uid] || 0) + 1);
            console.debug('Hangar requeued unit', {station:s.id, unit:uid, count:cnt});
            if(cnt > 3){
              console.warn('Hangar requeue timeout', {station:s.id, unit:uid, count:cnt});
              if(!u.challenge) u.challenge = 'HangarRequeue';
            }
          }
        }
        for(let hi=0; hi<h.bays.length; hi++){
          const hbay = h.bays[hi];
          if(!hbay.unitId){
            let picked=null;
            for(let pi=0; pi<3 && !picked; pi++){
              const arr=h.queue[pi];
              while(arr.length){
                const qe=arr[0];
                arr.shift();
                const u=getById(qe.id);
                // Skip if unit no longer valid for service
                if(!u || u.hp<=0 || !u.hidden || u.dockedAt!==s.id || h.occ.includes(u.id)){
                  continue;
                }
                picked=u; break;
              }
            }
            if(picked){
              if(!h.occ.includes(picked.id)) h.occ.push(picked.id);
              hbay.unitId=picked.id;
              hbay.phase='Service';
              const intent = picked.dockIntent || {};
              const L = RTS_CFG.economy.logistics;
              const R = RTS_CFG.economy.repair[classKey(picked)] || RTS_CFG.economy.repair.Light;
              const refuelRate=1, repairRate=1, depositRate=1;
              const ops = { refuel:0, repair:0, depositOre:0, depositFuel:0, loadFuel:0, loadOre:0 };
              let t=0;
              ops.refuel = Math.max(0, picked.tank - picked.fuel);
              t += refuelRate * (ops.refuel / L.refuelRatePerSec);
              if(intent.repair){
                ops.repair = Math.max(0, picked.hpMax - picked.hp);
                t += repairRate * (ops.repair / R.hpPerSec);
              }
              if(intent.deposit){
                ops.depositOre = picked.cargo?.ore || 0;
                ops.depositFuel = picked.cargo?.fuel || 0;
                t += depositRate * (ops.depositOre / L.depositOrePerSec + ops.depositFuel / L.depositFuelPerSec);
              }
              if(intent.loadFuel){
                ops.loadFuel = picked.cargo ? Math.max(0, picked.cargo.cap - ((picked.cargo.ore||0) + (picked.cargo.fuel||0))) : 0;
                t += depositRate * (ops.loadFuel / L.depositFuelPerSec);
              }
              if(intent.loadOre){
                const cap = picked.cargo ? Math.max(0, picked.cargo.cap - ((picked.cargo.ore||0) + (picked.cargo.fuel||0))) : 0;
                ops.loadOre = Math.min(intent.loadOre, cap);
                t += depositRate * (ops.loadOre / L.depositOrePerSec);
              }
              hbay.t = t;
              hbay.ops = ops;
              hbay.nextMission = intent.nextMission || null;
            }
          }else if(hbay.phase==='Service'){
            const u=getById(hbay.unitId);
            if(!u){ hbay.unitId=null; hbay.phase='Idle'; hbay.t=0; hbay.nextMission=null; hbay.ops=null; continue; }
            const fac=factions[u.faction];
            const L = RTS_CFG.economy.logistics;
            const R = RTS_CFG.economy.repair;
            const Rcfg = R[classKey(u)] || R.Light;

            if(hbay.ops.depositOre>0){
              const q=Math.min(hbay.ops.depositOre, L.depositOrePerSec*dt);
              const qO=storageGiveOre(s, q);
              if(u.cargo){
                const before = u.cargo.ore||0;
                if(qO > before) console.warn('depositOre exceeds cargo', {id:u.id, qO, before});
                u.cargo.ore = Math.max(0, before - qO);
              }
              fac.stats.oreMined += qO; u.xp += (qO>0?0.02*qO:0);
              hbay.ops.depositOre = Math.max(0, hbay.ops.depositOre - qO);
              }
              if(hbay.ops.depositFuel>0){
                const q=Math.min(hbay.ops.depositFuel, L.depositFuelPerSec*dt);
                const qF=storageGiveFuel(s, q);
                if(u.cargo){
                  const before = u.cargo.fuel||0;
                  if(qF > before) console.warn('depositFuel exceeds cargo', {id:u.id, qF, before});
                  u.cargo.fuel = Math.max(0, before - qF);
                }
                fac.stats.fuelMined += qF; u.xp += (qF>0?0.015*qF:0);
                hbay.ops.depositFuel = Math.max(0, hbay.ops.depositFuel - qF);
              }
              if(hbay.ops.loadOre>0 && (!hbay.nextMission || hbay.nextMission.kind!==EMISSION.ReturnDeposit)){
                const q=Math.min(hbay.ops.loadOre, L.depositOrePerSec*dt);
                const qL=storageTakeOre(s, q);
                if(u.cargo) u.cargo.ore = (u.cargo.ore||0) + qL;
                fac.stats.oreSpent += qL; u.xp += (qL>0?0.02*qL:0);
                hbay.ops.loadOre = Math.max(0, hbay.ops.loadOre - qL);
              }
              if(hbay.ops.loadFuel>0 && (!hbay.nextMission || hbay.nextMission.kind!==EMISSION.ReturnDeposit)){
                const q=Math.min(hbay.ops.loadFuel, L.depositFuelPerSec*dt);
                const qL=storageTakeFuel(s, q);
                if(u.cargo) u.cargo.fuel = (u.cargo.fuel||0) + qL;
                fac.stats.fuelSpent += qL; u.xp += (qL>0?0.015*qL:0);
                hbay.ops.loadFuel = Math.max(0, hbay.ops.loadFuel - qL);
              }
              if(hbay.ops.refuel>0){
                const q=Math.min(hbay.ops.refuel, L.refuelRatePerSec*dt);
                const qF=storageTakeFuel(s, q);
                u.fuel = Math.min(u.tank, u.fuel + qF);
                updateLowFuelStatus(u);
                hbay.ops.refuel = Math.max(0, hbay.ops.refuel - qF);
              }
            if(hbay.ops.repair>0){
              const qHp=Math.min(hbay.ops.repair, Rcfg.hpPerSec*dt);
              const qOre=storageTakeOre(s, qHp * Rcfg.orePerHp);
              const qRepaired=qOre / Rcfg.orePerHp;
              u.hp = Math.min(u.hpMax, u.hp + qRepaired);
              fac.stats.oreSpent += qOre;
              hbay.ops.repair = Math.max(0, hbay.ops.repair - qRepaired);
            }

            const refuelRate=1, repairRate=1, depositRate=1;
            let t=0;
            if(hbay.ops.refuel>0) t += refuelRate * (hbay.ops.refuel / L.refuelRatePerSec);
            if(hbay.ops.repair>0) t += repairRate * (hbay.ops.repair / Rcfg.hpPerSec);
            if(hbay.ops.depositOre>0) t += depositRate * (hbay.ops.depositOre / L.depositOrePerSec);
            if(hbay.ops.depositFuel>0) t += depositRate * (hbay.ops.depositFuel / L.depositFuelPerSec);
            if(hbay.ops.loadFuel>0) t += depositRate * (hbay.ops.loadFuel / L.depositFuelPerSec);
            if(hbay.ops.loadOre>0) t += depositRate * (hbay.ops.loadOre / L.depositOrePerSec);
            hbay.t = t;

            if(t<=0){
              // Rearm: top off weapon ammo and reserves from faction stock
              try{
                const log = fac.logistics;
                if(u.weapons && log && log.ammoStock){
                  for(const w of u.weapons){
                    const cfg = w.cfg || {};
                    const usesAmmo = cfg.ammo && cfg.ammo.max > 0;
                    const packSize = usesAmmo ? (cfg.ammo.size || cfg.ammo.mag || cfg.ammo.battery || 0) : 0;
                    const maxPacks = usesAmmo ? (cfg.ammo.max || 0) : 0;
                    if(!usesAmmo || packSize<=0 || maxPacks<=0) continue;
                    const key = w.key;
                    let stock = log.ammoStock[key] || 0;
                    if(stock<=0) continue;
                    // Fill the loaded magazine if not full
                    if(w.ammo < packSize && stock>0){
                      w.ammo = packSize;
                      stock -= 1;
                      log.ammoStock[key] = stock;
                      fac.ammoStore.count = Math.max(0, fac.ammoStore.count - 1);
                      // Cancel any ongoing reload/charge since we restocked directly
                      w.reloading = 0;
                      if(w.charging) w.charging.length = 0;
                    }
                    // Fill reserve packs up to (max - 1)
                    const spareSlots = Math.max(0, maxPacks - 1);
                    const haveSpare = Math.floor((w.reserve||0) / packSize);
                    let needSpare = Math.max(0, spareSlots - haveSpare);
                    if(needSpare>0 && stock>0){
                      const give = Math.min(needSpare, stock);
                      w.reserve = (w.reserve||0) + give * packSize;
                      stock -= give;
                      log.ammoStock[key] = stock;
                      fac.ammoStore.count = Math.max(0, fac.ammoStore.count - give);
                    }
                  }
                }
              } catch(_e) { /* no-op: rearm is best-effort */ }
              if(u.dockIntent?.deposit){
                if(u.cargo && ((u.cargo.ore||0)>0 || (u.cargo.fuel||0)>0)){
                  hbay.nextMission = {kind:EMISSION.ReturnDeposit};
                }
              }
              if(u.pendingComponents){
                const need = u.pendingComponents;
                fac.logistics.produce([need]);
                if(fac.logistics.radarStock >= (need.radar||0) && fac.logistics.powerStock >= (need.power||0)){
                  for(let i=0;i<(need.radar||0);i++) u.components.radar.push(new Component('radar'));
                  for(let i=0;i<(need.power||0);i++) u.components.power.push(new Component('power'));
                  fac.logistics.radarStock -= (need.radar||0);
                  fac.logistics.powerStock -= (need.power||0);
                  u.pendingComponents = null;
                } else {
                  hbay.t = 1;
                  continue;
                }
              }
              enqueueDepart(s, u.id, hbay.nextMission);
              if(u.dockIntent) u.dockIntent.state='DepartQueue';
              h.occ = h.occ.filter(id=>id!==u.id);
              hbay.unitId=null; hbay.phase='Idle'; hbay.t=0; hbay.nextMission=null; hbay.ops=null;
            }
          }
        }
      }

    // === Step departures ===
      for(const dep of d.departOps) dep.t -= dt;
      const readyOut = d.departOps.filter(x=>x.t<=0);
      if(readyOut.length){
        for(const dep of readyOut){
          const u=getById(dep.unitId);
        if(!u){
          // Remove any lingering references to a missing unit
            releaseDock(s, dep.unitId);
            if(h) h.occ = h.occ.filter(id=>id!==dep.unitId);
            d.departOps = d.departOps.filter(x=>x!==dep);
            pqRemoveById(d.queue, dep.unitId);
            if(h) pqRemoveById(h.queue, dep.unitId);
            const bay = d.bays[dep.bayIndex];
          if(bay && bay.unitId===dep.unitId){ bay.unitId=null; bay.phase='Idle'; bay.t=0; }
          continue;
        }

        // Free bay + release from dock
        releaseDock(s, u.id);

        // Unhide just outside the hold ring, kick outward
        if(u.dockIntent?.slot!=null) releaseDockSlot(s, u.dockIntent.slot);
        u.hidden=false; u.dockedAt=null; u.blocker=null; u.dockIntent=null;
        const R = (d.holdR||7) + 1.5;
        const ang=((tickCount*0.7)%360)/57.3 + (u.id%11);
          const off=[Math.cos(ang)*R,0,Math.sin(ang)*R];
          u.pos = V.add(s.pos, off);
          u.vel = V.mul(V.norm(off), 6);
          u.intent = {kind:'Idle'};
          if(!dep.nextMission) u.mission = {kind:EMISSION.Idle};
          setSubtask(u,'Undocked',0.6);
          u.undockCooldown = 3;
          u.undockMission = u.mission;

        // Clear bay state
        const bay = d.bays[dep.bayIndex];
        if(bay && bay.unitId===u.id){ bay.unitId=null; bay.phase='Idle'; bay.t=0; }

        // Next mission if provided (e.g., ReturnDeposit or Mine*)
        if(dep.nextMission) u.mission = dep.nextMission;

        // Done with this departure
        d.departOps = d.departOps.filter(x=>x!==dep);
      }
    }
    }
}

/* ============================ COMBATANTS ============================ */

function stepCombatant(e, dt){
  if(e.undockCooldown!=null){
    if(e.mission !== e.undockMission){
      delete e.undockCooldown;
      delete e.undockMission;
    } else {
      e.undockCooldown = Math.max(0, e.undockCooldown - dt);
      if(e.undockCooldown>0){
        // Still cooling down from undocking; skip movement/targeting/firing
        return;
      }
      delete e.undockCooldown;
      delete e.undockMission;
    }
  }

  if(e.fuel<=0){ e.intent={kind:'Stalled'}; return; }

  // Respect any dock intent first (ATC phases)
  if(handleDockIntent(e, dt)) return;

  // Global fuel crisis stand-down (no weapon fire, hold near Mother)
  if(factions[e.faction].ration.active){
    const m = getMother(e.faction);
    steerTo(e, V.add(m.pos,[2*(e.id%3)-2,0,2*((e.id>>2)%3)-2]), dt, 0.6, 'eco');
    e.intent = {kind:'StandDown'};
    if(e.type===T.EW && e.jammer){ e.fuel = Math.max(0, e.fuel - e.jammer.fuelPerSec*dt); }
    return;
  }

  const range = calcFuelRange(e);
  e.fuelRange = range;
  e.hasTargetComp = (e.weapons||[]).some(w=>w.targetComputer);
  const tm = e.team>=0 ? teams.find(t=>t.id===e.team) : null;
  e.radarShared = tm ? Math.max(tm.sharedRadar||0, e.radar||0) : (e.radar||0);

  // Update faction intel visibility for this observer before targeting
  try{ updateVisibility(e, entities, tickCount/60, tm, sendComms); }catch(_e){}

  if(e.fuel < e.tank*RTS_CFG.thresholds.veryLowFuelUnit || (e.intent && e.intent.kind==='Refuel')){
    const s = nearestStorageWithFuel(e.faction, e.pos, Math.max(20, e.tank*0.25));
    if(s){
      if(calcDist(e.pos,s.pos) > range){ e.intent={kind:'Stalled'}; e.blocker='Storage out of range'; return; }
      e.intent = {kind:'Refuel', storageId:s.id};
      if(!e.undockCooldown) ensureDockIntent(e, s, { refuel:true, repair:(e.hp<e.hpMax*0.85) });
      return;
    }
  }

  const hpRatio = e.hp / e.hpMax;
  if(hpRatio < RTS_CFG.thresholds.retreatHP){
    const s = nearestStorage(e.faction, e.pos);
    if(s){
      if(calcDist(e.pos,s.pos) > range){ e.intent={kind:'Stalled'}; e.blocker='Storage out of range'; return; }
      steerTo(e, s.pos, dt, 0.9, 'eco');
      if(!e.undockCooldown) ensureDockIntent(e, s, { repair:true });
      e.intent = {kind:'Retreat', storageId:s.id};
      return;
    }
  }

  let target = chooseTarget(e, entities, RTS_CFG);

  // LOS/radar fallback: if intel-based targeting yields nothing,
  // acquire nearest enemy within radar or 20km proximity.
  if(!target){
    const proxR = 20 * KM_TO_WORLD; // 20km proximity LOS
    const detectR = Math.max(e.radarShared || 0, proxR);
    let best=null, bd=Infinity;
    for(const t of entities){
      if(!t || t.hidden || t.faction===e.faction) continue;
      const d = calcDist(e.pos, t.pos);
      if(d <= detectR && d < bd){ best=t; bd=d; }
    }
    if(best) target = best;
  }

  if(e.team<0){
    const intel = intelPoint(e.faction, e.pos);
    let dest=null;
    if(target){
      const hasGuns = e.weapons && e.weapons.length>0;
      const maxR = hasGuns ? Math.max(...e.weapons.map(w=>w.range||0)) : 0;
      const to = V.sub(e.pos, target.pos);
      const d = V.len(to);
      const dir = d>1e-5 ? V.mul(to,1/d) : [1,0,0];
      // Prefer to maintain standoff distance based on weapon range
      let prefer = hasGuns ? (e.type===T.Heavy ? maxR : Math.max(6, 0.75*maxR)) : 0;
      dest = prefer>0 ? V.add(target.pos, V.mul(dir, prefer)) : target.pos;
      // Add light separation from friendlies to reduce clumping
      const sep = separationOffset(e, 10, 3);
      if(V.len(sep)>0) dest = V.add(dest, sep);
      e._hold = [...target.pos];
      e._holdSrc = 'target';
    }else{
      if(intel){
        if(e._holdSrc!=='intel') { e._hold=[...intel]; e._holdSrc='intel'; }
      }else{
        if(e._holdSrc!=='rand') { e._hold = randAround(getMother(e.faction).pos, 14); e._holdSrc='rand'; }
      }
      dest = e._hold;
    }
    if(dest){
      if(calcDist(e.pos,dest) > range){ e.intent={kind:'Stalled'}; e.blocker='Target out of range'; return; }
      steerTo(e, dest, dt, 0.85, 'combat');
    }
    if(target){ setSubtask(e,'Closing',0.5); } else { setSubtask(e, intel?'Scanning':'Transit',0.5); }
  }

  if(target){
    const to = V.sub(target.pos, e.pos);
    const d = V.len(to);
    if(d>1e-5){
      const dir = V.mul(to, 1/d);
      const aimCos = V.dot(e.fwd, dir);
      if(aimCos < FIRE_ARC_COS){
        const ang = Math.acos(clamp(aimCos, -1, 1));
        const step = Math.min(TURN_RATE*dt, ang);
        const axisRaw = V.cross(e.fwd, dir);
        const axLen = V.len(axisRaw);
        if(axLen > 1e-6){
          const axis = V.mul(axisRaw, 1/axLen);
          const axf = V.cross(axis, e.fwd);
          const newF = V.norm( V.add( V.mul(e.fwd, Math.cos(step)), V.mul(axf, Math.sin(step)) ) );
          let right = V.cross(newF, [0,1,0]); if(V.len(right)<1e-4) right=[1,0,0];
          right = V.norm(right);
          let up = V.cross(right, newF); up = V.norm(up);
          e.fwd=newF; e.right=right; e.up=up;
        }
      }
    }
  }

  if(e.type===T.EW && e.jammer){ e.fuel = Math.max(0, e.fuel - e.jammer.fuelPerSec*dt); }

  const fac = getFaction(e.faction);
  for(const w of (e.weapons||[])){
    w.cd = Math.max(0, w.cd - dt);
    if(w.reloading > 0){
      w.reloading = Math.max(0, w.reloading - dt);
      if(w.reloading === 0){
        w.ammo = w.cfg.ammo.size;
        if(!w.cfg.energy){
          w.reserve = Math.max(0, w.reserve - (w.cfg.ammo.size || 0));
        }
      }
    }
    if(w.charging && w.charging.length){
      for(let i=w.charging.length-1;i>=0;i--){
        w.charging[i] = Math.max(0, w.charging[i]-dt);
        if(w.charging[i] === 0){
          w.reserve += w.cfg.ammo.size;
          w.charging.splice(i,1);
        }
      }
    }
    if(w.ammo === 0 && w.reserve > 0 && w.reloading === 0){
      if(w.cfg.energy){
        const started = startRecharge(fac, w);
        w.ammo = w.cfg.ammo.size;
        w.reserve -= w.cfg.ammo.size;
        if(started) w.charging.push(w.cfg.reload.time);
      } else {
        startReload(fac, w);
      }
    }
    const t = target;
    if(!t) continue;

    if(t && (!e._lastContactMsgT || (tickCount/60 - e._lastContactMsgT) > 2.0)){
      sendComms({ type:'CONTACT', from:e.id, faction:e.faction, targetId:t.id, pos:[...t.pos], ttl:6 });
      e._lastContactMsgT = tickCount/60;
    }

    let dir = e.fwd;
    let d = w.range;
    let jamFactor = 1;
    if(t){
      const to = V.sub(t.pos, e.pos);
      d = V.len(to);
      dir = d>1e-5 ? V.mul(to, 1/d) : [0,0,0];

      if(w.targetComputer){
        const sig = sigFromPower(RTS_CFG, t.powerKw || 0, { fuelUse: t.sigFuelUse || 0, weaponFire: t.sigWeaponFire });
        const jam = jammerStrength(e, t);
        const eff = Math.max(0, sig - jam);
        jamFactor = sig>0 ? eff/sig : 0;
      }

      if(w.targetComputer && w.type==='projectile'){
        const rel = V.sub(t.pos, e.pos);
        const tv = t.vel || [0,0,0];
        const a = V.dot(tv,tv) - w.projSpeed*w.projSpeed;
        const b = 2*V.dot(rel, tv);
        const c = V.dot(rel, rel);
        let tau = 0;
        const disc = b*b - 4*a*c;
        if(Math.abs(a) < 1e-6){
          if(b !== 0) tau = -c/b;
        } else if(disc >= 0){
          const t1 = (-b - Math.sqrt(disc))/(2*a);
          const t2 = (-b + Math.sqrt(disc))/(2*a);
          const tt = Math.min(t1,t2) > 0 ? Math.min(t1,t2) : Math.max(t1,t2);
          if(tt>0) tau = tt;
        }
        if(tau>0){
          const leadPoint = V.add(t.pos, V.mul(tv, tau*(w.targetComputer.lead||1)*jamFactor));
          dir = V.norm(V.sub(leadPoint, e.pos));
        }
      }
    }

    let spreadRad = (w.spread||0) * Math.PI/180;
    const acc = clamp((e.xp||0)/100,0,1);
    const tcTrack = w.targetComputer ? ((w.targetComputer.tracking||0)/100) * jamFactor : 0;
    if(t && w.targetComputer){
      spreadRad += (1-acc) * 0.1 * (1 - tcTrack);
    } else {
      let blind = 0.5 - acc * 0.4;
      blind *= (1 - tcTrack);
      spreadRad += blind;
    }
    if(spreadRad>0){
      dir = V.norm(V.add(dir, V.mul(randInUnitDiskPerp(dir), spreadRad)));
    }

    const aimCos = V.dot(e.fwd, dir);
    const steerDir = clampDirToArc(e.fwd, dir, FIRE_ARC_COS);
    steerTo(e, V.add(e.pos, V.mul(steerDir, d)), dt, 0.9, 'combat');
    if(aimCos < FIRE_ARC_COS){
      continue;
    }

    if(e.type===T.EW){
      let friendNear=false;
      for(const o of entities){
        if(o.faction===e.faction && o.id!==e.id && !o.hidden && (o.type===T.Light||o.type===T.Heavy)){
          if(calcDist(o.pos,e.pos)<w.range) { friendNear=true; break; }
        }
      }
      if(friendNear) continue;
    }

    const inRange = (d<=w.range);
    const usesAmmo = w.cfg.ammo && w.cfg.ammo.max > 0;
    if(inRange && w.cd<=0 && w.reloading<=0 && (!usesAmmo || w.ammo>0) && e.fuel>=w.fuelPerShot){
      fac.stats.shotsFired++; fac.stats.perType[classKey(e)].shotsFired++;
      const beforeFuel = e.fuel;
      COMBAT_LOG.push({ type:'fire', shooter:e.id, faction:e.faction, weapon:w.key, wtype:w.type, target:t? t.id:null, range:w.range, inRange, fuelBefore:beforeFuel, ammo:w.ammo, reserve:w.reserve });
      if(w.fuelPerShot > beforeFuel) console.warn('weapon fired with insufficient fuel', {id:e.id, need:w.fuelPerShot, have:beforeFuel});
      e.fuel = Math.max(0, beforeFuel - w.fuelPerShot);
      e.sigFuelUse = (e.sigFuelUse || 0) + w.fuelPerShot;
      e.sigWeaponFire = true;
      w.cd = 1/Math.max(0.01,w.rof);
      if(usesAmmo){
        w.ammo--;
        if(w.ammo === 0){
          if(w.cfg.energy){
            const started = startRecharge(fac, w);
            if(w.reserve > 0){
              w.ammo = w.cfg.ammo.size;
              w.reserve -= w.cfg.ammo.size;
              if(started) w.charging.push(w.cfg.reload.time);
            } else if(started){
              w.reloading = w.cfg.reload.time;
            }
          } else if(w.reserve > 0){
            startReload(fac, w);
          }
        }
      }
      setSubtask(e,'Attacking',0.5);
      if(w.type==='projectile'){
        const spec = projSpecFor(w.key);
        const spawnPos = V.add(e.pos, V.mul(dir, gunOffset));
        const proj={
          id:idAlloc++, faction:e.faction, src:e.id,
          pos:spawnPos, vel:V.mul(dir, w.projSpeed),
          dmg:w.dmg, ttl:spec.ttl, len:spec.len, thick:spec.thick, color:spec.color
        };
        projectiles.push(proj);
        COMBAT_LOG.push({ type:'projectile-spawn', id:proj.id, src:proj.src, faction:proj.faction, dmg:proj.dmg, ttl:proj.ttl, speed:w.projSpeed, color:proj.color });
      } else if(t){
        if(!tryDodge(t, dir)){
          applyDamage(t, w.dmg, e.faction, e.id);
          fac.stats.shotsHit++; fac.stats.perType[classKey(e)].shotsHit++;
          COMBAT_LOG.push({ type:'hit', shooter:e.id, target:t.id, weapon:w.key, dmg:w.dmg, mode:(w.type==='projectile'?'direct':'beam') });
          // Visual beam streak FX so beam weapons are visible
          if(w.type==='beam'){
            const spec = projSpecFor(w.key);
            const spawnPos = V.add(e.pos, V.mul(dir, gunOffset));
            const projFX={
              id:idAlloc++, faction:e.faction, src:e.id,
              pos:spawnPos, vel:V.mul(dir, 300),
              dmg:0, ttl:Math.min(0.2, spec.ttl*0.3), len:spec.len, thick:spec.thick, color:spec.color,
              fx:true
            };
            projectiles.push(projFX);
          }
        }
      }
      e.fireAssist = (t ? (w.targetComputer ? 'Target Computer' : 'Manual') : 'Blind Fire');
    }
  }
}

/* ============================ VICTORY PANEL / RENDERING / UI ============================ */

function mapToLines(m){ const keys=Object.keys(m); if(!keys.length) return '  (none)'; return keys.sort().map(k=>`  ${k.padEnd(18,'.')} ${m[k]}`).join('\n'); }
function perTypeLines(per){
  const keys=['Mother','Constructor','EW','Light','Heavy','CollectorOutpost','WeaponPlatform'];
  const lines=['  Type                 Alive  Built  Lost   Kills  Shots  Hit%   Dmg+   Dmg-   AvgLife'];
  for(const k of keys){
    const s=per[k], hitPct=(100*s.shotsHit/Math.max(1,s.shotsFired)).toFixed(1), life=(s.lost? (s.timeAlive/s.lost).toFixed(1):'-');
    lines.push(`  ${k.padEnd(20)} ${String(s.alive).padStart(5)} ${String(s.built).padStart(6)} ${String(s.lost).padStart(6)} ${String(s.kills).padStart(7)} ${String(s.shotsFired).padStart(6)} ${String(hitPct).padStart(5)}% ${String(s.dmgDealt.toFixed(0)).padStart(6)} ${String(s.dmgTaken.toFixed(0)).padStart(6)} ${String(life).padStart(7)}`);
  }
  return lines.join('\n');
}
function renderVictory(){
  const tsec=(tickCount/60).toFixed(1);
  const rpt=f=>{
    const hitPct=(100*f.stats.shotsHit/Math.max(1,f.stats.shotsFired)).toFixed(1);
    const built=mapToLines(f.stats.builtByType), lost=mapToLines(f.stats.lostByType);
    const per=perTypeLines(f.stats.perType);
    return `
<h3>${f.name} Faction</h3>
<pre>
Time: ${tsec}s

ECON
  Mined:  ORE ${f.stats.oreMined.toFixed(0)}   FUEL ${f.stats.fuelMined.toFixed(0)}
  Spent:  ORE ${f.stats.oreSpent.toFixed(0)}   FUEL ${f.stats.fuelSpent.toFixed(0)}
  Banked: ORE ${f.ore.toFixed(0)}              FUEL ${f.fuel.toFixed(0)}

COMBAT (overall)
  Shots:  ${f.stats.shotsFired}   Hits: ${f.stats.shotsHit}  Hit%: ${hitPct}%
  Damage: dealt ${f.stats.dmgDealt.toFixed(0)}   taken ${f.stats.dmgTaken.toFixed(0)}
  Kills:  Units ${f.kills.units}   Structures ${f.kills.structures}
  Losses: Units ${f.losses.units}  Structures ${f.losses.structures}

BUILT BY TYPE
${built}

LOST BY TYPE
${lost}

PER-UNIT TYPE STATS
${per}
</pre>`;
  };
  const html = `<div class="victory">
    <div><strong>Victory:</strong> ${(endState.winner===FRED?'Red':'Blue')} â€¢ Time ${(tickCount/60).toFixed(1)}s</div>
    ${rpt(factions[FRED])}
    ${rpt(factions[FBLU])}
  </div>`;
  el('victory').innerHTML=html;
}

/* === helpers for dock UI === */
function typeAbbr(t){
  return t===T.Constructor?'Con':t===T.Light?'L':t===T.Heavy?'H':t===T.EW?'EW':t===T.Mother?'M':'?';
}
function dockSummary(e){
  if(!e.dockCtrl) return '';
  const busy = dockBusyCount(e);
  const occ = e.dockCtrl.occ.map(getById).filter(Boolean).map(u=>typeAbbr(u.type));
  const q = pqLength(e.dockCtrl.queue);
  let out = `Dock ${busy}/${e.dockCtrl.cap} [${occ.join(', ')}] Q:${q}`;
  if(e.hangarCtrl){
    const h = e.hangarCtrl;
    const hOcc = [];
    for(const id of h.occ){
      const u = getById(id);
      if(!u) continue;
      const bay = h.bays.find(b=>b.unitId===id);
      const ops = bay?.ops || u.dockIntent || {};
      const opsLetters = [];
      if(ops.refuel>0 || ops.refuel===true) opsLetters.push('F');
      if(ops.repair>0 || ops.repair===true) opsLetters.push('R');
      if(ops.depositOre>0 || ops.depositFuel>0 || ops.deposit===true) opsLetters.push('D');
      if(ops.loadFuel>0 || ops.loadFuel===true) opsLetters.push('L');
      hOcc.push(`${typeAbbr(u.type)}${opsLetters.length?`(${opsLetters.join(',')})`:''}`);
    }
    const hq = pqLength(h.queue);
    out += ` | Hangar ${h.occ.length}/${h.cap} [${hOcc.join(', ')}] HQ:${hq}`;
  }
  return out;
}

/* === camera === */
let rotX=-0.5, rotY=0.9, camDist=260 + (RTS_CFG.world.size*Math.sqrt(3)/2)*2.1,
    camZoom=1, mapCam={x:0,y:0,zoom:1}, selectedId=null, followId=null, camTarget=[0,0,0];
// Toggle for orthographic projection in 3D (no perspective foreshortening)
let camOrtho = true;
function proj3D(x,y,z,w,h,rx,ry,dist){
  const fov=Math.min(w,h),cx=w/2,cy=h/2; const cosX=Math.cos(rx),sinX=Math.sin(rx),cosY=Math.cos(ry),sinY=Math.sin(ry);
  let zx=x*cosY+z*sinY, zz=-x*sinY+z*cosY; let yx=y*cosX-zz*sinX, yz=y*sinX+zz*cosX;
  const d = camOrtho ? (2.0 + dist*0.002) : (2.0 + yz + dist*0.002);
  return [cx+(zx*fov)/d, cy-(yx*fov)/d, d];
}
function autoFrame(){ let cx=0,cy=0,cz=0,c=0; for(const e of entities){ if(e.hidden) continue; cx+=e.pos[0];cy+=e.pos[1];cz+=e.pos[2];c++; }
  if(!c) return; cx/=c;cy/=c;cz/=c; if(followId){ cx=camTarget[0]; cy=camTarget[1]; cz=camTarget[2]; } let R=10; for(const e of entities){ if(e.hidden) continue; const d=calcDist(e.pos,[cx,cy,cz]); if(d>R) R=d; }
  const mapR = world.size*Math.sqrt(3)/2;
  const desired = 260 + Math.max(R, mapR)*2.1;
  camDist = camDist*0.9 + desired*camZoom*0.1; }
function clampMapCam(){
  mapCam.zoom = clamp(mapCam.zoom, 0.05, 200);
  const max = world.half - world.half / mapCam.zoom;
  mapCam.x = clamp(mapCam.x, -max, max);
  mapCam.y = clamp(mapCam.y, -max, max);
}
function drawFX3D(w,h){
  // Draw FX with additive blending for a stronger glow
  g3d.save();
  const prevComp = g3d.globalCompositeOperation;
  g3d.globalCompositeOperation = 'lighter';
  for(const p of fx){
    const pos = V.sub(p.pos, camTarget);
    const [x,y]=proj3D(pos[0],pos[1],pos[2],w,h,rotX,rotY,camDist);
    const a = clamp(p.life/p.max,0,1);
    if(p.type==='thr'){
      const s = p.size*(0.9+0.5*(1-a));
      const g = g3d.createRadialGradient(x,y,0, x,y,s);
      g.addColorStop(0.0, `rgba(255,255,230,${Math.min(1,0.9*a+0.3)})`);
      g.addColorStop(0.4, `rgba(255,220,120,${Math.min(1,0.7*a+0.25)})`);
      g.addColorStop(1.0, `rgba(255,170,60,0)`);
      g3d.fillStyle=g; g3d.beginPath(); g3d.arc(x,y,s,0,Math.PI*2); g3d.fill();
    }else{
      const s = p.size*(1.2+0.8*(1-a));
      const g = g3d.createRadialGradient(x,y,0, x,y,s);
      g.addColorStop(0.0, `rgba(255,245,200,${Math.min(1,0.95*a+0.3)})`);
      g.addColorStop(0.5, `rgba(255,180,80,${Math.min(1,0.65*a+0.25)})`);
      g.addColorStop(1.0, `rgba(120,60,20,0)`);
      g3d.fillStyle=g; g3d.beginPath(); g3d.arc(x,y,s,0,Math.PI*2); g3d.fill();
    }
  }
  g3d.globalCompositeOperation = prevComp;
  g3d.restore();
}

// Draw a simple mech silhouette for combat units using line segments in 3D
function drawMech3D(e, color){
  // Helper: 3D point builder from local mech coordinates (right, up, forward)
  const P = (rx, uy, fz) => V.add(e.pos, V.add(V.mul(e.right, rx), V.add(V.mul(e.up, uy), V.mul(e.fwd, fz))));
  // Helper: draw a 3D segment
  function seg(a, b, stroke, lw){
    // Project relative to camera target to match other render elements
    const ac = V.sub(a, camTarget);
    const bc = V.sub(b, camTarget);
    const [x1,y1] = proj3D(ac[0],ac[1],ac[2], c3d.width, c3d.height, rotX, rotY, camDist);
    const [x2,y2] = proj3D(bc[0],bc[1],bc[2], c3d.width, c3d.height, rotX, rotY, camDist);
    const prev = g3d.lineWidth; const prevS = g3d.strokeStyle;
    g3d.strokeStyle = stroke; g3d.lineWidth = lw||2; g3d.beginPath(); g3d.moveTo(x1,y1); g3d.lineTo(x2,y2); g3d.stroke();
    g3d.lineWidth = prev; g3d.strokeStyle = prevS;
  }
  const type = e.type;
  const isLight = (type===T.Light);
  const isHeavy = (type===T.Heavy);
  const isEW = (type===T.EW);
  // Scale mech so its furthest part fits within the hit radius, with a small margin
  const extentPerS = 1.8; // approx max radial extent per unit of s from this mech layout
  const smidge = 0.93;    // render slightly smaller than hitbox
  const s = (HIT_RADIUS * smidge) / extentPerS;
  const lw = isHeavy?3:2;

  // Torso and head
  const torsoH = 1.2*s, torsoF = 0.15*s, torsoW = 0.9*s;
  const pelvis = P(0, 0.2*s, 0);
  const chest  = P(0, torsoH, torsoF);
  seg(pelvis, chest, color, lw);
  // Head
  const headBase = P(0, torsoH + 0.15*s, torsoF+0.05*s);
  const headTop  = P(0, torsoH + 0.15*s + 0.4*s, torsoF+0.05*s);
  seg(headBase, headTop, color, lw);

  // Arms
  const shoulderW = torsoW*0.6;
  const elbowDrop = 0.4*s, foreF = 0.55*s;
  const shL = P( shoulderW, torsoH, torsoF*0.8);
  const shR = P(-shoulderW, torsoH, torsoF*0.8);
  const elbL = P( shoulderW*0.9, torsoH - elbowDrop, torsoF + foreF*0.4);
  const elbR = P(-shoulderW*0.9, torsoH - elbowDrop, torsoF + foreF*0.4);
  const handL= P( shoulderW*0.7, torsoH - elbowDrop*1.0, torsoF + foreF);
  const handR= P(-shoulderW*0.7, torsoH - elbowDrop*1.0, torsoF + foreF);
  seg(shL, elbL, color, lw); seg(elbL, handL, color, lw);
  seg(shR, elbR, color, lw); seg(elbR, handR, color, lw);

  // Weapon barrels (forearm guns)
  if(e.weapons && e.weapons.length){
    const barrel = 0.45*s;
    const tipL = P( shoulderW*0.7, torsoH - elbowDrop*1.0, torsoF + foreF + barrel);
    const tipR = P(-shoulderW*0.7, torsoH - elbowDrop*1.0, torsoF + foreF + barrel);
    seg(handL, tipL, color, lw);
    seg(handR, tipR, color, lw);
  }

  // Legs
  const hipW = 0.6*s, kneeDrop = 0.9*s, footDrop = 1.9*s, footF = 0.35*s;
  const hipL = P( hipW, 0.2*s, 0);
  const hipR = P(-hipW, 0.2*s, 0);
  const kneeL= P( hipW*0.9, 0.2*s - kneeDrop, 0.15*s);
  const kneeR= P(-hipW*0.9, 0.2*s - kneeDrop, 0.15*s);
  const footL= P( hipW*0.8, 0.2*s - footDrop, footF);
  const footR= P(-hipW*0.8, 0.2*s - footDrop, footF);
  seg(hipL, kneeL, color, lw); seg(kneeL, footL, color, lw);
  seg(hipR, kneeR, color, lw); seg(kneeR, footR, color, lw);

  // Flight backpack
  const packH = isEW? 0.9*s : 0.7*s;
  const packBack = isHeavy? 0.6*s : 0.5*s;
  const packTopL = P( 0.35*s, torsoH*0.9, -packBack);
  const packTopR = P(-0.35*s, torsoH*0.9, -packBack);
  const packBotL = P( 0.25*s, torsoH*0.5, -packBack*1.1);
  const packBotR = P(-0.25*s, torsoH*0.5, -packBack*1.1);
  seg(packTopL, packBotL, color, lw); seg(packTopR, packBotR, color, lw);
}
function draw3D(){
    if(followId){
      const fe=getById(followId);
      if(fe && !fe.hidden){
        camTarget=fe.pos.slice();
      } else {
        followId=null; camTarget=[0,0,0];
      }
    }
    autoFrame(); const w=c3d.width,h=c3d.height; g3d.clearRect(0,0,w,h); renderSky(); g3d.drawImage(skyTex,0,0);
    for(const r of resources){ const col=r.type===T.ResFuel?'rgba(110,231,255,0.2)':'rgba(255,214,102,0.2)'; const rp=V.sub(r.pos,camTarget); const [x,y]=proj3D(rp[0],rp[1],rp[2],w,h,rotX,rotY,camDist); g3d.fillStyle=col; g3d.beginPath(); g3d.arc(x,y,4,0,Math.PI*2); g3d.fill(); }
    const fov = Math.min(w,h);
    for(const e of entities){
      if(e.hidden) continue;
      const ep = V.sub(e.pos, camTarget);
      const [x,y,d]=proj3D(ep[0],ep[1],ep[2],w,h,rotX,rotY,camDist);
      if(el('showRadar').checked && e.radar){
        const rr = overlayMath.scaleDepth(e.radar, fov, d);
        g3d.strokeStyle = e.faction===FRED?'rgba(255,107,107,0.12)':'rgba(110,203,255,0.12)';
        g3d.beginPath(); g3d.arc(x,y,rr,0,Math.PI*2); g3d.stroke();
      }
      if(el('showRanges').checked && e.weapons){
        for(const wpn of e.weapons){
          const spec = projSpecFor(wpn.key);
          const rr = overlayMath.scaleDepth(wpn.range, fov, d);
          if(spec.color){
            g3d.save(); g3d.globalAlpha=0.25; g3d.strokeStyle=spec.color;
            g3d.beginPath(); g3d.arc(x,y,rr,0,Math.PI*2); g3d.stroke();
            g3d.restore();
          } else {
            g3d.strokeStyle='rgba(255,255,255,0.08)';
            g3d.beginPath(); g3d.arc(x,y,rr,0,Math.PI*2); g3d.stroke();
          }
        }
      }
      let rad;
    if(e.type===T.Mother){
      rad = 10;
    }else if(e.role==='Structure'){
      rad = 8;
    }else if(e.type===T.EW){
      rad = 4;
    }else if(e.type===T.Light){
      rad = 6;
    }else if(e.type===T.Heavy || e.type===T.Constructor){
      rad = 7;
    }else{
      rad = 3;
    }
    let col=e.faction===FRED?COLORS[FRED]:COLORS[FBLU]; if(e.role==='Structure') col='rgba(190,190,255,0.85)';
    // Draw mech silhouette for combat units; otherwise draw simple orb
    if(e.role!=='Structure' && e.type!==T.Mother && e.type!==T.Constructor){
      drawMech3D(e, col);
    } else {
      g3d.fillStyle=col; g3d.beginPath(); g3d.arc(x,y,rad,0,Math.PI*2); g3d.fill();
    }
    g3d.strokeStyle='rgba(255,255,255,0.15)'; g3d.beginPath(); g3d.arc(x,y,rad+2,-Math.PI/2,-Math.PI/2+2*Math.PI*(e.hp/e.hpMax)); g3d.stroke();
    if(selectedId===e.id){
      g3d.strokeStyle='rgba(255,214,102,0.9)';
      g3d.beginPath(); g3d.arc(x,y,rad+4,0,Math.PI*2); g3d.stroke();
      const cfg = cfgForEntity(e);
      if(el('showRanges').checked){
        const fr = calcFuelRange({ ...e, tank: cfg.tank, upkeep: cfg.upkeep });
        const rr = overlayMath.scaleDepth(fr, fov, d);
        g3d.strokeStyle='rgba(255,214,102,0.25)';
        g3d.beginPath(); g3d.arc(x,y,rr,0,Math.PI*2); g3d.stroke();
      }
      if(el('showRadar').checked){
        const baseRadar = cfg.radar || 0;
        const shared = Math.max(e.radarShared||0, baseRadar);
        if(shared>baseRadar){
          const sr = overlayMath.scaleDepth(shared, fov, d);
          g3d.strokeStyle='rgba(110,203,255,0.25)';
          g3d.beginPath(); g3d.arc(x,y,sr,0,Math.PI*2); g3d.stroke();
        }
      }
    }

    // 3D overlay: dock info for storages (esp. mother)
    if(e.dockCtrl){
      g3d.fillStyle='rgba(182,193,204,0.85)';
      g3d.fillText(dockSummary(e), x+8, y-6);
    }
  }
  // Projectiles: draw as long streaks
  for(const p of projectiles){
    const dir = V.norm(p.vel);
    const pos = V.sub(p.pos, camTarget);
    const tail = V.sub(pos, V.mul(dir, p.len||10));
    const [x1,y1] = proj3D(pos[0],pos[1],pos[2],w,h,rotX,rotY,camDist);
    const [x2,y2] = proj3D(tail[0],tail[1],tail[2],w,h,rotX,rotY,camDist);
    g3d.strokeStyle = p.color || (p.faction===FRED?COLORS[FRED]:COLORS[FBLU]);
    const prevLW = g3d.lineWidth;
    g3d.lineWidth = p.thick||1.5;
    g3d.beginPath(); g3d.moveTo(x1,y1); g3d.lineTo(x2,y2); g3d.stroke();
    g3d.lineWidth = prevLW;
  }
  drawFX3D(w,h);
  g3d.strokeStyle='#1c2530'; g3d.strokeRect(0,0,w,h);
}

function scale2D(v,w,h){
  return [
    ((v[0]-mapCam.x)*mapCam.zoom/world.size)*w + w/2,
    ((v[2]-mapCam.y)*mapCam.zoom/world.size)*h + h/2
  ];
}

function draw2D(){
  const w=c2d.width,h=c2d.height; g2d.clearRect(0,0,w,h); renderSky(); g2d.drawImage(skyTex,0,0,w,h);
  if(followId){
    const fe=getById(followId);
    if(fe && !fe.hidden){
      mapCam.x=fe.pos[0];
      mapCam.y=fe.pos[2];
    } else {
      followId=null; camTarget=[0,0,0];
    }
  }
  clampMapCam();
  const scale=v=>scale2D(v,w,h);


  if(el('showEco').checked){ g2d.strokeStyle='rgba(110,231,255,0.12)'; g2d.lineWidth=1;
    for(const r of resources){ const [x,y]=scale(r.pos); const s=nearestStorage(FRED,r.pos)||nearestStorage(FBLU,r.pos); if(s){ const [sx,sy]=scale(s.pos); g2d.beginPath(); g2d.moveTo(x,y); g2d.lineTo(sx,sy); g2d.stroke(); } } }

  for(const r of resources){ const [x,y]=scale(r.pos); const cap=r.cap/r.capMax; g2d.fillStyle=r.type===T.ResFuel?`rgba(110,231,255,${0.25+0.5*cap})`:`rgba(255,214,102,${0.25+0.5*cap})`; g2d.beginPath(); g2d.arc(x,y,5,0,Math.PI*2); g2d.fill(); }

    if(el('showEW').checked){
      for(const e of entities){ if(e.hidden) continue; if(e.type===T.EW && e.jammer){ const [x,y]=scale(e.pos); const r=e.jammer.radius/world.size*w*mapCam.zoom;
        g2d.strokeStyle=e.faction===FRED?'rgba(255,107,107,0.2)':'rgba(110,203,255,0.2)'; g2d.beginPath(); g2d.arc(x,y,r,0,Math.PI*2); g2d.stroke();
        g2d.fillStyle='rgba(200,200,200,0.6)'; g2d.fillText(`${e.jammer.strength}`, x+4, y-4); }}
    }
    if(el('showRadar').checked){
      for(const e of entities){ if(e.hidden || !e.radar) continue; const [x,y]=scale(e.pos); const r=overlayMath.scaleRadius(e.radar, w, mapCam.zoom, world.size);
        g2d.strokeStyle=e.faction===FRED?'rgba(255,107,107,0.12)':'rgba(110,203,255,0.12)'; g2d.beginPath(); g2d.arc(x,y,r,0,Math.PI*2); g2d.stroke(); }
    }
    if(el('showRanges').checked){
      for(const e of entities){ if(e.hidden || !e.weapons) continue; const [x,y]=scale(e.pos); for(const wpn of e.weapons){ const spec=projSpecFor(wpn.key); const r=overlayMath.scaleRadius(wpn.range, w, mapCam.zoom, world.size);
          if(spec.color){ g2d.save(); g2d.globalAlpha=0.25; g2d.strokeStyle=spec.color; g2d.beginPath(); g2d.arc(x,y,r,0,Math.PI*2); g2d.stroke(); g2d.restore(); }
          else { g2d.strokeStyle='rgba(255,255,255,0.08)'; g2d.beginPath(); g2d.arc(x,y,r,0,Math.PI*2); g2d.stroke(); } }
      }
    }
  if(el('showTeams').checked){
    g2d.strokeStyle='rgba(126,252,138,0.25)';
    for(const tm of teams){ const mem=tm.members.map(getById).filter(u=>u && !u.hidden); if(mem.length<2) continue; g2d.beginPath(); const [x0,y0]=scale(mem[0].pos); g2d.moveTo(x0,y0); for(let i=1;i<mem.length;i++){ const [xi,yi]=scale(mem[i].pos); g2d.lineTo(xi,yi);} g2d.closePath(); g2d.stroke();
      const c=teamCentroid(tm); const [mx,my]=scale(c); g2d.fillStyle='rgba(255,255,255,0.6)'; g2d.fillText(tm.mission.type[0], mx+4, my-2);
    }
  }

  for(const e of entities){
    if(e.hidden) continue;
    const [x,y]=scale(e.pos);
    let col=e.faction===FRED?COLORS[FRED]:COLORS[FBLU]; if(e.role==='Structure') col='rgba(190,190,255,0.85)';
    const s=(e.type===T.Mother)?7:(e.role==='Structure'?5:4);
    g2d.fillStyle=col; g2d.fillRect(x-s,y-s,s*2,s*2);
    if(selectedId===e.id){
      g2d.strokeStyle='rgba(255,214,102,0.9)';
      g2d.strokeRect(x-s-2,y-s-2,s*2+4,s*2+4);
    }
    const cfg = cfgForEntity(e);
    if(el('showSpecs').checked || selectedId===e.id){
      const fr = calcFuelRange({ ...e, tank: cfg.tank, upkeep: cfg.upkeep });
      const rr = fr/world.size*w*mapCam.zoom;
      g2d.strokeStyle='rgba(255,214,102,0.25)';
      g2d.beginPath(); g2d.arc(x,y,rr,0,Math.PI*2); g2d.stroke();
      const baseRadar = cfg.radar || 0;
      const shared = Math.max(e.radarShared||0, baseRadar);
      const sr = shared/world.size*w*mapCam.zoom;
      if(sr>baseRadar/world.size*w*mapCam.zoom){
        g2d.strokeStyle='rgba(110,203,255,0.25)';
        g2d.beginPath(); g2d.arc(x,y,sr,0,Math.PI*2); g2d.stroke();
      }
    }

    if(el('showSpecs').checked){
      const tm = e.team>=0 ? teams.find(t=>t.id===e.team) : null;
      let mission = tm ? tm.mission.type : (e.intent?.kind==='Refuel' ? 'Refuel' : 'â€”');
      if(e.type===T.Constructor) mission = e.mission? e.mission.kind : 'â€”';
      if(e.intent?.kind==='DockQ' || e.mission?.kind===EMISSION.DockQueue) mission = 'DockQ';
      if(e.intent?.kind==='Docked' || e.mission?.kind===EMISSION.Docked) mission = 'Docked';
      if(e.intent?.kind==='Stalled' || e.mission?.kind===EMISSION.Stalled) mission = 'Stalled';
      const FM = e.flightMode==='Decoupled'?'D':'C';
      const rangeVal = calcFuelRange({ ...e, tank: cfg.tank, upkeep: cfg.upkeep }).toFixed(0);
      const sharedR = Math.max(e.radarShared||0, cfg.radar||0);
      let line = `HP ${(100*e.hp/e.hpMax|0)}%  F ${(100*e.fuel/e.tank|0)}%  M ${mission}  T ${tm?'Y':'N'}  FM ${FM}  ST ${e.subtask||'â€”'}`;
      line += `  RG ${rangeVal} RS ${sharedR} TC ${e.hasTargetComp?'Y':'N'}`;
        line += `  SIG ${sigFromPower(RTS_CFG, cfg.powerKw||e.powerKw||0,{ fuelUse:e.sigFuelUse||0, weaponFire:e.sigWeaponFire }).toFixed(2)}`;
      if(e.jammer){ line += `  JM ${e.jammer.strength}/${e.jammer.radius}`; }
      g2d.fillStyle=(e.fuel<=0)?'rgba(255,107,107,0.95)':(e.fuel<e.tank*RTS_CFG.thresholds.lowFuelUnit)?'rgba(255,214,102,0.9)':'rgba(230,230,230,0.8)';
      g2d.fillText(line, x+6, y-4);
      let warnY = y+9;
      if(e.blocker){ g2d.fillStyle='rgba(200,200,200,0.75)'; g2d.fillText(`âš  ${e.blocker}`, x+6, warnY); warnY+=11; }
      let warn=null;
      if(tm && tm.mission){
        let dest=null;
        if(tm.mission.type===MISSION.Defend){ const a=getById(tm.mission.defendId); dest=a? a.pos:null; }
        else if(tm.mission.type===MISSION.Escort){ const u=getById(tm.mission.escortId); dest=u? u.pos:null; }
        else if(tm.mission.type===MISSION.Siege){ const t=getById(tm.mission.targetId); dest=t? t.pos:null; }
        else if(tm.mission.type===MISSION.Harass){ dest=tm.mission.area; }
        else if(tm.mission.type===MISSION.SAD || tm.mission.type===MISSION.Patrol){ dest=tm.mission.point; }
        if(dest && calcDist(e.pos,dest) > (e.fuelRange!=null?e.fuelRange:calcFuelRange(e))){ warn='Mission out of range'; }
      }
      if(warn){ g2d.fillStyle='rgba(200,200,200,0.75)'; g2d.fillText(`âš  ${warn}`, x+6, warnY); }
    }

    // 2D overlay near storages (esp. Mother): show docks
    if(e.dockCtrl){
      g2d.fillStyle='rgba(182,193,204,0.9)';
      g2d.fillText(dockSummary(e), x+6, y+20);
    }
  }

  // Projectiles as streaks on minimap
  for(const p of projectiles){
    const dir = V.norm(p.vel);
    const head = scale(p.pos);
    const tail = scale( V.sub(p.pos, V.mul(dir, p.len||10)) );
    g2d.strokeStyle = p.color || (p.faction===FRED?COLORS[FRED]:COLORS[FBLU]);
    const prevLW = g2d.lineWidth;
    g2d.lineWidth = (p.thick||1.5)*0.6;
    g2d.beginPath(); g2d.moveTo(head[0],head[1]); g2d.lineTo(tail[0],tail[1]); g2d.stroke();
    g2d.lineWidth = prevLW;
  }

  g2d.strokeStyle='#1c2530'; g2d.strokeRect(0,0,w,h);
}

/* ============================ UPDATE KPI ============================ */

function updateKPI(){
  for(const fid of [FRED,FBLU]) pickPosture(fid);

  const r=factions[FRED], b=factions[FBLU];
  el('rOf').textContent = `${r.ore|0} / ${r.fuel|0}`;
  el('bOf').textContent = `${b.ore|0} / ${b.fuel|0}`;
  el('rStore').textContent = `W ${r.weaponStore.count}/${r.weaponStore.cap} R ${r.radarStore.count}/${r.radarStore.cap} P ${r.powerStore.count}/${r.powerStore.cap} A ${r.ammoStore.count}/${r.ammoStore.cap}`;
  el('bStore').textContent = `W ${b.weaponStore.count}/${b.weaponStore.cap} R ${b.radarStore.count}/${b.radarStore.cap} P ${b.powerStore.count}/${b.powerStore.cap} A ${b.ammoStore.count}/${b.ammoStore.cap}`;
  const postR = r.ration?.active ? 'FuelCrisis' : r.kpi.posture;
  const postB = b.ration?.active ? 'FuelCrisis' : b.kpi.posture;
  el('postures').textContent = `Red ${postR} â€¢ Blue ${postB}`;

  // Mission counts: single pass over teams
  let mP=0,mD=0,mE=0,mH=0,mS=0,mSAD=0;
  for(const t of teams){
    switch(t.mission.type){
      case MISSION.Patrol: mP++; break;
      case MISSION.Defend: mD++; break;
      case MISSION.Escort: mE++; break;
      case MISSION.Harass: mH++; break;
      case MISSION.Siege: mS++; break;
      case MISSION.SAD: mSAD++; break;
    }
  }
  el('missions').textContent = `P:${mP} D:${mD} E:${mE} H:${mH} S:${mS} SAD:${mSAD}`;

  // Hangar stats: count docked ships by faction and reason
  const hangStats = {
    [FRED]: { total:0, refuel:0, repair:0, deposit:0, loadFuel:0 },
    [FBLU]: { total:0, refuel:0, repair:0, deposit:0, loadFuel:0 }
  };
  for(const s of entities){
    if(!s.hangarCtrl) continue;
    for(const bay of s.hangarCtrl.bays){
      if(!bay.unitId || bay.phase!=='Service') continue;
      const u = getById(bay.unitId);
      if(!u || u.hp<=0) continue;
      const ops = bay.ops || u.dockIntent || {};
      const hs = hangStats[u.faction];
      hs.total++;
      if(ops.refuel>0 || ops.refuel===true) hs.refuel++;
      if(ops.repair>0 || ops.repair===true) hs.repair++;
      if(ops.depositOre>0 || ops.depositFuel>0 || ops.deposit===true) hs.deposit++;
      if(ops.loadFuel>0 || ops.loadFuel===true) hs.loadFuel++;
    }
  }
  function fmtHang(s){
    const parts=[];
    if(s.refuel) parts.push(`F${s.refuel}`);
    if(s.repair) parts.push(`R${s.repair}`);
    if(s.deposit) parts.push(`D${s.deposit}`);
    if(s.loadFuel) parts.push(`L${s.loadFuel}`);
    return `${s.total}${parts.length?` (${parts.join(' ')})`:''}`;
  }
  el('hangars').textContent = `Red ${fmtHang(hangStats[FRED])} â€¢ Blue ${fmtHang(hangStats[FBLU])}`;

  // Unit counts: single pass over entities
  let rC=0,rL=0,rH=0,rEW=0,rOP=0,rWP=0;
  let bC=0,bL=0,bH=0,bEW=0,bOP=0,bWP=0;
  let rRange=0,rRangeN=0,bRange=0,bRangeN=0;
  let rShare=0,bShare=0,rTC=0,bTC=0;
  for(const e of entities){
    if(e.hidden) continue;
    if(e.tank>0){
      const rg = calcFuelRange(e);
      if(e.faction===FRED){ rRange+=rg; rRangeN++; }
      else if(e.faction===FBLU){ bRange+=rg; bRangeN++; }
    }
    if(e.radarShare){ if(e.faction===FRED) rShare++; else if(e.faction===FBLU) bShare++; }
    if(e.hasTargetComp){ if(e.faction===FRED) rTC++; else if(e.faction===FBLU) bTC++; }
    switch(e.type){
      case T.Constructor:
        if(e.faction===FRED) rC++; else if(e.faction===FBLU) bC++;
        break;
      case T.Light:
        if(e.faction===FRED) rL++; else if(e.faction===FBLU) bL++;
        break;
      case T.Heavy:
        if(e.faction===FRED) rH++; else if(e.faction===FBLU) bH++;
        break;
      case T.EW:
        if(e.faction===FRED) rEW++; else if(e.faction===FBLU) bEW++;
        break;
      case T.Outpost:
        if(e.faction===FRED) rOP++; else if(e.faction===FBLU) bOP++;
        break;
      case T.Platform:
        if(e.faction===FRED) rWP++; else if(e.faction===FBLU) bWP++;
        break;
    }
  }
  el('unitRed').textContent = `C${rC} L${rL} H${rH} EW${rEW} OP${rOP} WP${rWP}`;
  el('unitBlu').textContent = `C${bC} L${bL} H${bH} EW${bEW} OP${bOP} WP${bWP}`;
  el('rangeRed').textContent = (rRangeN? (rRange/rRangeN).toFixed(1) : '0');
  el('rangeBlu').textContent = (bRangeN? (bRange/bRangeN).toFixed(1) : '0');
  el('radarShareRed').textContent = rShare;
  el('radarShareBlu').textContent = bShare;
  el('tcompRed').textContent = rTC;
  el('tcompBlu').textContent = bTC;
}

/* ============================ LOOP / CARD / UI ============================ */

let rotDrag=false,last=[0,0],skyDrag=false,skyLast=[0,0];
c3d.addEventListener('mousedown',e=>{
  if(e.altKey){ skyDrag=true; skyLast=[e.clientX,e.clientY]; }
  else{ rotDrag=true; last=[e.clientX,e.clientY]; }
});
window.addEventListener('mouseup',()=>{ rotDrag=false; skyDrag=false; });
window.addEventListener('mousemove',e=>{
  if(rotDrag){ const dx=e.clientX-last[0], dy=e.clientY-last[1]; last=[e.clientX,e.clientY]; rotY+=dx*0.005; rotX+=dy*0.005; }
  if(skyDrag){ const dx=e.clientX-skyLast[0], dy=e.clientY-skyLast[1]; skyLast=[e.clientX,e.clientY]; skyCam.yaw+=dx*0.005; skyCam.pitch+=dy*0.005; }
});
c3d.addEventListener('wheel',e=>{
  e.preventDefault();
  if(e.altKey){ skyCam.zoom=clamp(skyCam.zoom*(e.deltaY<0?0.9:1.1),0.2,5); generateStars(); }
  // Invert 3D zoom direction and greatly expand range
  else{ camZoom=clamp(camZoom*(e.deltaY<0?1.1:0.9),0.05,200); mapCam.zoom=camZoom; el('zoom').value=camZoom; clampMapCam(); draw2D(); }
});

let pan=false, panLast=[0,0];
c2d.addEventListener('mousedown',e=>{ if(e.button!==0) return; pan=true; panLast=[e.clientX,e.clientY]; });
c2d.addEventListener('mousemove',e=>{ if(!pan) return; const dx=e.clientX-panLast[0], dy=e.clientY-panLast[1]; panLast=[e.clientX,e.clientY]; mapCam.x -= dx*(world.size/(c2d.width*mapCam.zoom)); mapCam.y -= dy*(world.size/(c2d.height*mapCam.zoom)); clampMapCam(); draw2D(); });
c2d.addEventListener('mouseup',e=>{ if(e.button!==0) return; pan=false; });
c2d.addEventListener('wheel',e=>{ e.preventDefault(); mapCam.zoom=clamp(mapCam.zoom*(e.deltaY<0?1.1:0.9),0.05,200); camZoom=mapCam.zoom; el('zoom').value=mapCam.zoom; clampMapCam(); draw2D(); });

/* ===== Selection + Popup ===== */
const unitCard=el('unitCard');
c2d.addEventListener('click',e=>{
  const rect=c2d.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const w=c2d.width,h=c2d.height;
  let best=null,bd=12;
  for(const ent of entities){
    if(ent.hidden) continue;
    const [sx,sy]=scale2D(ent.pos,w,h);
    const d=Math.hypot(mx-sx,my-sy); if(d<bd){ bd=d; best=ent; }
  }
  selectedId = best? best.id : null;
  updateSelectedPanel();
  if(best){ showCard(best, e.clientX, e.clientY); } else { hideCard(); }
});
c2d.addEventListener('dblclick',e=>{
  const rect=c2d.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const w=c2d.width,h=c2d.height;
  let best=null,bd=12;
  for(const ent of entities){
    if(ent.hidden) continue;
    const [sx,sy]=scale2D(ent.pos,w,h);
    const d=Math.hypot(mx-sx,my-sy); if(d<bd){ bd=d; best=ent; }
  }
  if(best){
    followId = best.id;
    selectedId = best.id;
    showCard(best, e.clientX, e.clientY);
  } else {
    followId = null;
    camTarget=[0,0,0];
    hideCard();
  }
  updateSelectedPanel();
});
document.addEventListener('click', (e)=>{
  if(unitCard.style.display!=='none' && !unitCard.contains(e.target) && e.target!==c2d){ hideCard(); }
});
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){
    followId=null; camTarget=[0,0,0];
  } else if(e.key==='o' || e.key==='O'){
    camOrtho = !camOrtho; // toggle orthographic/perspective
  }
});
el('cardClose').onclick = hideCard;

function showCard(u, x, y){
  unitCard.style.display='block';
  const pad=10;
  unitCard.style.left = Math.max(pad, Math.min(window.innerWidth - unitCard.offsetWidth - pad, x+8))+'px';
  unitCard.style.top  = Math.max(pad, Math.min(window.innerHeight - unitCard.offsetHeight - pad, y+8))+'px';
  fillCard(u);
}
function hideCard(){ unitCard.style.display='none'; }
function fillCard(u){
  const cfg = cfgForEntity(u);
  el('cardTitle').textContent = `${u.faction===0?'Red':'Blue'} ${typeName(u.type)}`;
  el('cardType').textContent = typeName(u.type);
  el('cardFac').textContent = (u.faction===0?'Red':'Blue');
  el('cardMode').textContent = u.flightMode||'Coupled';
  el('cardHP').style.width = (100*u.hp/u.hpMax)+'%';
  el('cardFuel').style.width = (100*u.fuel/u.tank)+'%';
  el('cardTank').textContent = cfg.tank || 0;
  if(u.weapons && u.weapons.length){
    const info = formatUnitInfo(u, {}, RTS_CFG);
    const list = el('cardWeapons');
    list.innerHTML = '';
    for(const w of info.weapons){
      const li = document.createElement('li');
      const remaining = Math.max(0, w.packs - 1);
      li.textContent = `${w.key} (${w.class}:${w.ammo}, packs:${remaining})`;
      list.appendChild(li);
    }
  }else{
    const list = el('cardWeapons');
    list.innerHTML = '<li>â€”</li>';
  }
  const tm = u.team>=0 ? teams.find(t=>t.id===u.team) : null;
  let mission = tm ? tm.mission.type : (u.intent?.kind==='Refuel' ? 'Refuel' : 'â€”');
  if(u.type===T.Constructor) mission = u.mission? u.mission.kind : 'â€”';
  if(u.intent?.kind==='DockQ' || u.mission?.kind===EMISSION.DockQueue) mission = 'DockQ';
  if(u.intent?.kind==='Docked' || u.mission?.kind===EMISSION.Docked) mission = 'Docked';
  if(u.intent?.kind==='Stalled' || u.mission?.kind===EMISSION.Stalled) mission = 'Stalled';
  el('cardMission').textContent = mission;
  el('cardTeam').textContent = tm?`Yes (#${tm.id})`:'No';
  const xpTot = Math.min(100, (u.xp||0)).toFixed(1);
  const xpCtrl = (u.xpCtrl||0).toFixed(1);
  const xpThr = (u.xpThrottle||0).toFixed(1);
  el('cardXP').textContent = `${xpTot} / 100 (Ctrl ${xpCtrl} Thr ${xpThr})`;
  const sigVal = sigFromPower(RTS_CFG, cfg.powerKw||u.powerKw||0,{ fuelUse:u.sigFuelUse||0, weaponFire:u.sigWeaponFire }).toFixed(2);
  el('cardSig').textContent = sigVal;
  const jamVal = jammerStrength({faction:(u.faction===0?1:0)}, u).toFixed(2);
  if(el('cardJam')) el('cardJam').textContent = jamVal;
  const tcCount = (u.weapons||[]).reduce((n,w)=>n+(w.targetComputer?1:0),0);
  el('cardTC').textContent = tcCount;
  el('cardAssist').textContent = u.fireAssist || 'â€”';

  const status = (u.blocker||'OK');
  let dockPhase = '';
  if(u.dockIntent){
    const phase = u.dockIntent.state || 'Hold';
    const target = u.dockIntent.storeId;
    dockPhase = ` â€¢ Dock@ ${target} â€¢ ${phase}${u.dockIntent.holding?' (holding)':''}`;
  }
  let dockInfo = '';
  if(u.dockCtrl){
    dockInfo = ' â€¢ '+dockSummary(u);
  }
  el('cardStatus').innerHTML = `${u.subtask?('Sub: '+u.subtask+' â€¢ '):''}${status}${dockPhase}${dockInfo}`;
}
function updateCard(){
  if(unitCard.style.display==='none') return;
  if(!selectedId){ hideCard(); return; }
  const u=getById(selectedId); if(!u){ hideCard(); return; }
  fillCard(u);
}

function updateSelectedPanel(){
  const box=el('sel');
  if(!selectedId){ box.textContent='â€“'; return; }
  const u=getById(selectedId); if(!u){ box.textContent='â€“'; return; }
  const tm = u.team>=0 ? teams.find(t=>t.id===u.team) : null;
  let mission = tm ? tm.mission.type : (u.intent?.kind==='Refuel' ? 'Refuel' : 'â€”');
  if(u.type===T.Constructor) mission = u.mission? u.mission.kind : 'â€”';
  if(u.intent?.kind==='DockQ' || u.mission?.kind===EMISSION.DockQueue) mission = 'DockQ';
  if(u.intent?.kind==='Docked' || u.mission?.kind===EMISSION.Docked) mission = 'Docked';
  if(u.intent?.kind==='Stalled' || u.mission?.kind===EMISSION.Stalled) mission = 'Stalled';
  const cargo = u.cargo? `Cargo O:${u.cargo.ore|0} F:${u.cargo.fuel|0}` : '';
  const blocker = u.blocker? `\nBlocker: ${u.blocker}` : '';
  const dockline = u.dockCtrl? `\n${dockSummary(u)}` : (u.dockIntent? `\nDock@ ${u.dockIntent.storeId} â€¢ ${u.dockIntent.state}` : '');
  const subline = `Subtask: ${u.subtask||'â€”'}`;
  const xpTot = Math.min(100, (u.xp||0)).toFixed(1);
  const xpCtrl = (u.xpCtrl||0).toFixed(1);
  const xpThr = (u.xpThrottle||0).toFixed(1);
    const cfg = cfgForEntity(u);
    const sigVal = sigFromPower(RTS_CFG, cfg.powerKw||u.powerKw||0,{ fuelUse:u.sigFuelUse||0, weaponFire:u.sigWeaponFire }).toFixed(2);
  const tcCount = (u.weapons||[]).reduce((n,w)=>n+(w.targetComputer?1:0),0);
  const assist = u.fireAssist ? `\nAssist: ${u.fireAssist}` : '';
  const info = formatUnitInfo(u, {}, RTS_CFG);
  const weaponsLine = info.weapons.map(w=>`${w.key} (${w.class}:${w.ammo}, packs:${Math.max(0,w.packs-1)})`).join(', ') || 'â€”';
  const rangeVal = calcFuelRange({ ...u, tank: cfg.tank, upkeep: cfg.upkeep }).toFixed(1);
  const radarShared = u.radarShared||0;
  box.innerHTML =
`Type: ${typeName(u.type).padEnd(18)}  Faction: ${u.faction===0?'Red':'Blue'}
Mode: ${u.flightMode||'Coupled'}
HP/Fuel: ${(u.hp|0)} / ${(u.hpMax|0)}    ${((100*u.hp/u.hpMax)|0)}%  |  ${((100*u.fuel/u.tank)|0)}%
Weapons: ${weaponsLine}
Range: ${rangeVal}
  Radar: ${cfg.radar||u.radar||0} (Shared ${radarShared})  Share:${u.radarShare?'Y':'N'}  TC:${tcCount}  SCnt:${u.radarShareCount||0}
XP: ${xpTot} / 100 (Ctrl ${xpCtrl} Thr ${xpThr})
Mission: ${mission}  ${cargo}
${subline}
Teamed: ${tm?'Yes (#'+tm.id+')':'No'}
Pos: [${u.pos.map(v=>v.toFixed(1)).join(', ')}]
Sig: ${sigVal} (Power ${cfg.powerKw||u.powerKw||0}kW)${assist}${blocker}${dockline}`;
}

/* ============================ SIM CORE / INIT ============================ */

function clampInBounds(p){ const h=world.half*0.95; for(let i=0;i<3;i++){ if(p[i]<-h) p[i]=-h; if(p[i]>h) p[i]=h; } }

function stepSim(dt){
  tickCount++; if(endState) return;

  stepWeaponProduction(dt);
  processBuildQueues(dt);
  updateFuelRationing();           // evaluate fuel crisis before AI/teams

  for(const tm of teams) stepTeam(tm, dt);

    for(const e of entities){
      if(e.hidden) continue;

      e.sigFuelUse = 0;
      e.sigWeaponFire = false;

      if(e.fuel<=0) e.vel=[0,0,0];

    if(e.role==='Structure'){ e.fuel=Math.max(0, e.fuel-RTS_CFG.fuelUse.radarPerSec*dt); updateLowFuelStatus(e); tickSubtask(e); continue; }
    if(e.type===T.Mother){ stepMother(e,dt); e.fuel=Math.max(0, e.fuel - (e.upkeep||0)*dt - RTS_CFG.fuelUse.radarPerSec*dt); updateLowFuelStatus(e); e.prevVel=[...e.vel]; tickSubtask(e); continue; }
    if(e.type===T.Constructor){ stepConstructor(e,dt); e.fuel=Math.max(0, e.fuel - (e.upkeep||0)*dt - RTS_CFG.fuelUse.radarPerSec*dt); updateLowFuelStatus(e); e.prevVel=[...e.vel]; if(!e.hidden && e.hp>0) e.xp += dt*0.5; tickSubtask(e); continue; }
    stepCombatant(e,dt);
    e.fuel=Math.max(0, e.fuel - (e.upkeep||0)*dt - RTS_CFG.fuelUse.radarPerSec*dt);
    updateLowFuelStatus(e);
    if(!e.hidden && e.hp>0) e.xp = (e.xp||0) + dt;
    e.prevVel=[...e.vel];
    tickSubtask(e);
  }

  processDocking(dt);
  stepProjectiles(dt);
  stepFx(dt);
  stepComms(dt); // (C) intel/comms decay & delivery

  if((tickCount%180)===0) regroupTeams();

  if(endState){ renderVictory(); running=false; el('btnToggle').textContent='â–¶ Start'; el('state').textContent='ended'; }
}

/* === loop + controls === */
let lastT=performance.now(),accum=0,fpsSm=60,frames=0,facc=0,skipFrame=false,rafHandle=0;
function loop(t){
  const speed=+el('speed').value;
  const dtRaw=t-lastT; lastT=t;
  if(running) accum+=dtRaw;
  facc+=dtRaw; frames++; if(facc>500){ fpsSm=Math.round(frames*1000/facc); frames=0; facc=0; }
  el('fps').textContent=fpsSm;
  el('objCount').textContent = entities.length+' +R'+resources.length+' +P'+projectiles.length+' +FX'+fx.length;
  el('worldSz').textContent = `${world.size}uÂ³`;

  const dtFixed=(1/60)*1000;
  if(running && !skipFrame){
    while(accum>=dtFixed){
      stepSim((dtFixed/1000)*speed);
      accum-=dtFixed;
    }
  }
  if(skipFrame) skipFrame=false;
    if(viewMode==="2D"){
      draw2D();
    }else{
      draw3D();
    }
    if(document.getElementById('bnpEnable')?.checked){ BNPBridge.syncOnce(); }
    updateCard();
    updateSelectedPanel();
    updateKPI();
    rafHandle=requestAnimationFrame(loop);
}

el('btnToggle').onclick=()=>{
  running=!running;
  el('btnToggle').textContent=running?'â¸ Pause':'â–¶ Start';
  el('state').textContent=running?'running':'paused';
  accum=0;
  lastT=performance.now();
  if(running){
    skipFrame=true;
    cancelAnimationFrame(rafHandle);
    rafHandle=requestAnimationFrame(loop);
  }
};
el('btnStep').onclick=()=>{ const was=running; running=false; stepSim(1/60); if(was) running=true; };
el('btnReset').onclick=()=>{ reseedAll(); hideCard(); };

// BNP controls
const bnpEnableEl = el('bnpEnable');
if(bnpEnableEl){
  bnpEnableEl.onchange = ()=>{
    if(bnpEnableEl.checked){ if(!BNPBridge.attach()){ const s=el('bnpStatus'); if(s) s.textContent='unavailable'; bnpEnableEl.checked=false; } }
    else { BNPBridge.detach(); }
  };
}

function genAndSpawn(){
  genWorld();
  spawnFaction(FRED); spawnFaction(FBLU);
  regroupTeams(); updateKPI();
}
function reseedAll(){
  endState=null; tickCount=0; entities.length=0; projectiles.length=0; resources.length=0; teams.length=0; fx.length=0; byId.clear(); selectedId=null; nodeAssignments.clear();
  factions.length=0;
  genAndSpawn();
  el('victory').textContent='â€“'; el('sel').textContent='â€“';
}

reseedAll();
rafHandle=requestAnimationFrame(loop);

})();

})();

</script>
<script>
(()=>{const code=document.getElementById('bundle').textContent; const blob=new Blob([code],{type:'text/javascript'}); const url=URL.createObjectURL(blob); const s=document.createElement('script'); s.src=url; document.body.appendChild(s);})();
</script>
</body>
</html>
